%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,11pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}


        \usepackage{charter}
        \usepackage[defaultsans]{lato}
        \usepackage{inconsolata}
    

\title{Tinker User\textquotesingle{}s Guide}
\date{Dec 06, 2020}
\release{}
\author{TinkerTools Organization}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Introduction to the Software}
\label{\detokenize{text/introduction:introduction-to-the-software}}\label{\detokenize{text/introduction::doc}}

\section{What is Tinker?}
\label{\detokenize{text/introduction:what-is-tinker}}
Welcome to the Tinker molecular modeling package! Tinker is designed to be an easily used and flexible system of programs and routines for molecular mechanics and dynamics as well as other energy\sphinxhyphen{}based and structural manipulation calculations. It is intended to be modular enough to enable development of new computational methods and efficient enough to meet most production calculation needs. Rather than incorporating all the functionality in one monolithic program, Tinker provides a set of relatively small programs that interoperate to perform complex computations. New programs can be easily added by modelers with only limited programming experience.


\section{Features and Capabilities}
\label{\detokenize{text/introduction:features-and-capabilities}}
The series of major programs included in the distribution system perform the following core tasks:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{(}{)}%
\item {} 
building protein and nucleic acid models from sequence

\item {} 
energy minimization and structural optimization

\item {} 
analysis of energy distribution within a structure

\item {} 
molecular dynamics and stochastic dynamics

\item {} 
simulated annealing with a choice of cooling schedules

\item {} 
normal modes and vibrational frequencies

\item {} 
conformational search and global optimization

\item {} 
transition state location and conformational pathways

\item {} 
fitting of energy parameters to crystal data

\item {} 
distance geometry with pairwise metrization

\item {} 
molecular volumes and surface areas

\item {} 
free energy changes for structural mutations

\item {} 
advanced algorithms based on potential smoothing

\end{enumerate}

Many of the various energy minimization and molecular dynamics computations can be performed on full or partial structures, over Cartesian, internal or rigid body coordinates, and including a variety of boundary conditions and crystal cell types. Other programs are available to generate timing data and allow checking of potential function derivatives for coding errors. Special features are available to facilitate input and output of protein and nucleic acid structures. However, the basic core routines have no knowledge of biopolymer structure and can be used for general molecular systems.

Due to its emphasis on ease of modification, Tinker differs from many other currently available molecular modeling packages in that the user is expected to be willing to write simple “front\sphinxhyphen{}end” programs and make some alterations at the source code level. The main programs provided should be considered as templates for the users to change according to their wishes. All subroutines are internally documented and structured programming practices are adhered to throughout. The result, it is hoped, will be a calculational system which can be tailored to local needs and desires.

The core Tinker system consists of over 240,000 lines of source written entirely in a portable Fortran superset. Use is made of only some very common extensions that aid in writing highly structured code. The current version of the package has been ported to a wide range of computers with no or extremely minimal changes. Tested systems include: Ubuntu, CentOS and Red Hat Linux, Microsoft Windows 10 and earlier, Apple MacOS, and various older Unix\sphinxhyphen{}based workstations under vendor supplied Unix. At present, our new code is written on various Linux platforms, and occasionally tested for compatibility on various of the other machine and OS combinations listed above. At present, our primary source code development efforts are in Fortran, using a portable subset of Fortran90 with some common extensions. A machine\sphinxhyphen{}translated C version of Tinker is currently available, and a hand\sphinxhyphen{}translated optimized C version of a previous Tinker release is available for inspection. Conversion to C or C++ is under consideration, but not being actively pursued at this time.

The basic design of the energy function engine used by the Tinker system allows usage of several different parameter sets. At present we are distributing parameters that implement several Amber and CHARMM potentials, MM2, MM3, OPLS\sphinxhyphen{}UA, OPLS\sphinxhyphen{}AA, MMFF, Liam Dang’s polarizable potentials, and our own AMOEBA (Atomic Multipole Optimized Energetics for Biomolecular Applications), AMOEBA+, and HIPPO (Hydrogen\sphinxhyphen{}like Intermolecular Polarizable Potential) force fields. In most cases, the source code separates the geometric manipulations needed for energy derivatives from the actual form of the energy function itself. Several other literature parameter sets are being considered for possible future development (later versions of CHARMM and Amber, as well as GROMOS, ENCAD, MM4, UFF, etc.), and many of the alternative potential function forms reported in the literature can be implemented directly or after minor code changes.

Much of the software in the Tinker package has been heavily used and well tested, but some modules are still in a fairly early stage of development. Further work on the Tinker system is planned in three main areas: (1) extension and improvement of the potential energy parameters including additional parameterization and testing of our polarizable multipole AMOEBA force field, (2) coding of new computational algorithms including additional methods for free energy determination, torsional Monte Carlo and molecular dynamics sampling, advanced methods for long range interactions, better transition state location, and further application of the potential smoothing paradigm, and (3) further development of Force Field Explorer, a Java\sphinxhyphen{}based GUI front\sphinxhyphen{}end to the Tinker programs that provides for calculation setup, launch and control as well as basic molecular visualization.


\section{Contact Information}
\label{\detokenize{text/introduction:contact-information}}
Questions and comments regarding the Tinker package, including suggestions for improvements and changes should be made to the author:
\begin{quote}

Professor Jay William Ponder
Department of Chemistry, Box 1134
Washington University in Saint Louis
One Brookings Hall
Saint Louis, MO 63130 U.S.A.

office: Louderman Hall, Room 453
phone:  (314) 935\sphinxhyphen{}4275
fax:    (314) 935\sphinxhyphen{}4481
email:  \sphinxhref{mailto:ponder@dasher.wustl.edu}{ponder@dasher.wustl.edu}
\end{quote}

In addition, an Internet web site containing an online version of this User’s Guide, the most recent distribution version of the full Tinker package and other useful information can be found at \sphinxurl{https://dasher.wustl.edu/tinker/}, the Home Page for the Tinker Molecular Modeling Package. Tinker and related software packages are also available from GitHub at the site \sphinxurl{https://github.com/TinkerTools/Tinker.git/}.


\chapter{Installation on Your Computer}
\label{\detokenize{text/installation:installation-on-your-computer}}\label{\detokenize{text/installation::doc}}

\section{How to Obtain a Copy of Tinker}
\label{\detokenize{text/installation:how-to-obtain-a-copy-of-tinker}}
The Tinker package is distributed on the Internet at the Ponder lab’s Tinker web site located at \sphinxurl{https://dasher.wustl.edu/tinker/}, or via download from the Github site for the TinkerTools organization at \sphinxurl{https://github.com/TinkerTools/Tinker/}. After unpacking the distribution, you can build a set of Tinker executables on almost any machine with a Fortran compiler. Makefiles, a CMakeLists.txt file for cmake, as well as standalone scripts to compile, build object libraries, and link executables on a wide variety of machine\sphinxhyphen{}CPU\sphinxhyphen{}operating system combinations are provided.


\section{Prebuilt Tinker Executables}
\label{\detokenize{text/installation:prebuilt-tinker-executables}}
Pre\sphinxhyphen{}built Tinker executables for Linux, MacOS, and Windows are also available for download from the sites mentioned above. They should run on most recent vintage machines using the above operating systems, and can handle a maximum of 1 million atoms provided sufficient memory is available. The Linux executables require at least glibc\sphinxhyphen{}2.6 or later. Note starting with Tinker 8, we no longer provide pre\sphinxhyphen{}built executables for any 32\sphinxhyphen{}bit operating systems.

The provided executables are OpenMP capable, but do not support APBS or the Tinker\sphinxhyphen{}FFE interface. You will still need to have a copy of the complete Tinker distribution as it contains the parameter sets, examples, benchmarks, test files and documentation required to use the package.


\section{Building your Own Executables}
\label{\detokenize{text/installation:building-your-own-executables}}
The compilation and building of the Tinker executables should be easy for most of the common Linux, MacOS and Windows computers. We provide in the /make area of the distribution a Makefile that with minor modification can be used to build Tinker on any of these machines. As an alternative to Makefiles, we also provide machine\sphinxhyphen{}specific directories with three separate shell scripts to compile the source, build an object library, and link binary executables.

The first step in building Tinker using the script files is to run the appropriate compile.make script for your operating system and compiler version. Next you must use a library.make script to create an archive of object code modules. Finally, run a link.make script to produce the complete set of Tinker executables. The executables can be renamed and moved to wherever you like by editing and running the “rename” script. These steps will produce executables that can run from the command line, but without the capability to interact with the FFE GUI. Building FFE\sphinxhyphen{}enabled Tinker executables involves replacing the sockets.f source file with sockets.c, and included the object from the C code in the Tinker object library. Then executables must be linked against Java libraries in addition to the usual resources. Sample compgui.make and linkgui.make scripts are provided for systems capable of building GUI\sphinxhyphen{}enabled executables.

Regardless of your target machine, only a few small pieces of code can possibly require attention prior to building. The most common source alterations are to the master array dimensions found in the source file sizes.f. The basic limit is on the number of atoms allowed, “maxatm”. This parameter can be set to 1000000 or more on most workstations. Personal computers with minimal memory may need a lower limit, depending on available memory, swap space and other resources. A description of the other parameter values is contained in the header of the file.


\section{Tinker\sphinxhyphen{}FFE (Force Field Explorer)}
\label{\detokenize{text/installation:tinker-ffe-force-field-explorer}}
Tinker\sphinxhyphen{}FFE, formerly Force Field Explorer, is a Java\sphinxhyphen{}based GUI for the Tinker package. It provides visualization for Tinker molecule files, as well as launching of Tinker calculations from a graphical interface. Tinker\sphinxhyphen{}FFE for Linux, MacOS and Windows can be downloaded from the Ponder lab Tinker web site as “installation kits” containing the FFE GUI and an FFE\sphinxhyphen{}enabled version of Tinker. Tinker\sphinxhyphen{}FFE requires a 64\sphinxhyphen{}bit CPU and operating system, as 32\sphinxhyphen{}bit systems are no longer supported.

Integration with Tinker, including the ability to interactively run Tinker calculations, and to access molecule downloads from the PubChem, NCI and PDB databases make Tinker\sphinxhyphen{}FFE a useful tool in classroom teaching environments. For research work, we recommend using the latest command line version of Tinker for numerical calculations, and using FFE or another visualization program to view results. Several other visualization programs (including VMD, Avogadro, Jmol, MOLDEN, WebMO, some PyMOL versions, etc.) can display Tinker structure and MD trajectory files.

The Tinker\sphinxhyphen{}FFE Installer for Linux is provided as a gzipped shell script. Uncompress the the .gz archive to produce an .sh script, and then run the script. The script must have the “executable” attribute, set via “chmod +x installer\sphinxhyphen{}file\sphinxhyphen{}name.sh”, prior to being run.

The Tinker\sphinxhyphen{}FFE Installer for MacOS is provided as a .dmg disk image file. Double\sphinxhyphen{}click on the file to run the installer. MacOS 10.8 and later contains a security feature called Gatekeeper that keeps applications not obtained via the App Store or Apple\sphinxhyphen{}approved developers from being opened. Gatekeeper is enabled by default, and may result in the (incorrect!) error message: “Tinker\sphinxhyphen{}FFE Installer.app is damaged and can’t be opened.” To turn off Gatekeeper, go to the panel System Preferences \textgreater{} Security \& Privacy \textgreater{} General, and set “Allow apps downloaded from:” to “Anywhere”. This will require an Administrator account, and must be done before invoking the FFE installer. Once FFE is installed and launched for the first time, you can return the System Preference to its prior value. On Sierra (10.12) and later, the “Anywhere” option has been removed. In most cases the Security \& Privacy panel will open and permit the user to run the installer. Alternatively, the “Anywhere” option can be restored by running the command “sudo spctl \textendash{}master\sphinxhyphen{}disable” in a Terminal window.

The Tinker\sphinxhyphen{}FFE Installer for Windows is provided as a zipped executable. First, unzip the .zip file, then run the resulting executable .exe file. In order to perform minimizations or molecular dynamics from within FFE, some environment variables and symbolic links must be set prior to using the program. A batch file named “FFESetupWin.bat” is installed in the main Tinker\sphinxhyphen{}FFE directory, which by default resides in the user’s home directory. To complete the setup of FFE, this batch file should be run from a Command Prompt window following installation. It is only necessary to invoke this batch file once, as the settings should persist between logins.

For those wishing to modify the FFE GUI or build a version from source, we provide a complete development package for Tinker\sphinxhyphen{}FFE. This is a large download which contains the code for all components, including the Java source for FFE itself and the many required Java libraries. This package allows building Tinker\sphinxhyphen{}FFE on all three supported operating systems from a common code base. External requirements are the GNU compiler suite with gcc, g++ and gfortran (on Windows use MinGW\sphinxhyphen{}w64 compilers under Cygwin), and the Install4j Java installer builder. Note Install4j is a commercial product; only the compiler is needed, not the full Install4j GUI interface.


\section{Documentation and Other Information}
\label{\detokenize{text/installation:documentation-and-other-information}}
The documentation for the Tinker programs, including the guide you are currently reading, is located in the /doc subdirectory of the distribution. The documentation was prepared using the Sphinx documentation generator. Portable versions of the documentation are provided as PDF files and in HTML format for web display. Please read and return by mail the Tinker license. In particular, we note that Tinker is not an Open Source package as users are prohibited from redistribution of original or modified Tinker source code or binaries to other parties. While our intent is to distribute the Tinker code to anyone who wants it, the Ponder Lab would keep track of researchers using the package. The returned license forms also help us justify further development of Tinker. When new modules and capabilities become available, and when the inevitable bugs are uncovered, we will attempt to notify those who have returned a license form. Finally, we remind you that this software is copyrighted, and ask that it not be redistributed in any form.


\section{Where to Direct Questions}
\label{\detokenize{text/installation:where-to-direct-questions}}
Specific questions about the building or use of the Tinker package should be directed to \sphinxhref{mailto:ponder@dasher.wustl.edu}{ponder@dasher.wustl.edu}. Tinker related questions or comments of more general interest can be posted on Twitter @TINKERtoolsMD. The Tinker developers monitor this account and will respond to the site or the individual poster as appropriate.


\chapter{Types of Input \& Output Files}
\label{\detokenize{text/file-types:types-of-input-output-files}}\label{\detokenize{text/file-types::doc}}
This section describes the basic file types used by the Tinker package. Let’s say you wish to perform a calculation on a particular small organic molecule. Assume that the file name chosen for our input and output files is sample. Then all of the Tinker files will reside on the computer under the name sample.xxx where .xxx is any of the several extension types to be described below.

\sphinxstylestrong{SAMPLE.XYZ}

The .xyz file is the basic Tinker Cartesian coordinates file type. It contains a title line followed by one line for each atom in the structure. Each line contains: the sequential number within the structure, an atomic symbol or name, X\sphinxhyphen{}, Y\sphinxhyphen{}, and Z\sphinxhyphen{}coordinates, the force field atom type number of the atom, and a list of the atoms connected to the current atom. Except for programs whose basic operation is in torsional space, all Tinker calculations are done from some version of the .xyz format.

\sphinxstylestrong{SAMPLE.INT}

The .int file contains an internal coordinates representation of the molecular structure. It consists of a title line followed by one line for each atom in the structure. Each line contains: the sequential number within the structure, an atomic symbol or name, the force field atom type number of the atom, and internal coordinates in the usual Z\sphinxhyphen{}matrix format. For each atom the internal coordinates consist of a distance to some previously defined atom, and either two bond angles or a bond angle and a dihedral angle to previous atoms. The length, angle and dihedral definitions do not have to represent real bonded interactions. Following the last atom definition are two optional blank line separated sets of atom number pairs. The first list contains pairs of atoms that are covalently bonded, but whose bond length was not used as part of the atom definitions. These pairs are typically used to close ring structures. The second list contains {\color{red}\bfseries{}\textasciigrave{}\textasciigrave{}}bonds’’ that are to be broken, i.e., pairs of atoms that are not covalently bonded, but which were used to define a distance in the atom definitions.

\sphinxstylestrong{SAMPLE.KEY}

The keyword parameter file always has the extension .key and is optionally present during Tinker calculations. It contains values for any of a wide variety of switches and parameters that are used to change the course of the computation from the default. The detailed contents of this file is explained in a latter section of this User’s Guide. If a molecular system specific keyfile, in this case sample.key, is not present, the the Tinker program will look in the same directory for a generic file named Tinker.key.

\sphinxstylestrong{SAMPLE.DYN}

The .dyn file contains values needed to restart a molecular or stochastic dynamics computation. It stores the current position, current velocity and current and previous accelerations for each atom, as well as the size and shape of any periodic box or crystal unit cell. This information can be used to start a new dynamics run from the final state of a previous run. Upon startup, the dynamics programs always check for the presence of a .dyn file and make use of it whenever possible. The .dyn file is updated concurrent with the saving of a new dynamics trajectory snapshot.

\sphinxstylestrong{SAMPLE.END}

The .end file type provides a mechanism to gracefully stop a running Tinker calculation. At appropriate checkpoints during a calculation, Tinker will test for the presence of a sample.end file, and if found will terminate the calculation after updating the output. The .end file can be created at any time during a computation, and will be detected when the next checkpoint is reached. The file may be of zero size, and its contents are unimportant. In the current version of Tinker, the .end mechanism is only available within dynamics\sphinxhyphen{}based programs.

\sphinxstylestrong{SAMPLE.001, SAMPLE.002, ….}

Several types of computations produce files containing a three or more digit extension (.001 as shown; or .002, .137, .5678, etc.). These are referred to as cycle files, and are used to store various types of output structures. The cycle files from a given computation are identical in internal structure to either the .xyz or .int files described above. For example, the vibrational analysis program can save the tenth normal mode in sample.010. A molecular dynamics\sphinxhyphen{}based program might save its tenth 0.1 picosecond frame (or an energy minimizer its tenth partially minimized intermediate) in a file of the same name.

\sphinxstylestrong{SAMPLE.LOG}

The Force Field Explorer interface to Tinker saves results of all calculations launched from the GUI to a log file with the .log suffix. Any output that would normally be directed to the screen after starting a program from the command line is appended to this log file by Force Field Explorer.

\sphinxstylestrong{SAMPLE.ARC}

A Tinker archive file is simply a series of .xyz Cartesian coordinate files appended together one after another. This file can be used to condense the results from intermediate stages of an optimization, frames from a molecular dynamics trajectory, or set of normal mode vibrations into a single file for storage. Tinker archive files can be displayed as sequential frame “movies” by the Force Field Explorer modeling program.

\sphinxstylestrong{SAMPLE.PDB}

This file type contains coordinate information in the PDB format developed by the Brookhaven Protein Data Bank for deposition of model structures based on macromolecular X\sphinxhyphen{}ray diffraction and NMR data. Although Tinker itself does not use .pdb files directly for input/output, auxiliary programs are provided with the system for interconverting .pdb files with the .xyz format described above.

\sphinxstylestrong{SAMPLE.SEQ}

This file type contains the primary sequence of a biopolymer in the standard one\sphinxhyphen{}letter code with 50 residues per line. The .seq file for a biopolymer is generated automatically when a PDB file is converted to Tinker .xyz format or when using the PROTEIN or NUCLEIC programs to build a structure from sequence It is required for the reverse conversion of a Tinker file back to PDB format..

\sphinxstylestrong{SAMPLE.FRAC}

The fractional coordinates corresponding to the asymmetric unit of a crystal unit cell are stored in the .frac file. The internal format of this file is identical to the .xyz file; except that the coordinates are fractional instead of in Angstrom units.

\sphinxstylestrong{SAMPLE.MOL2}

File conversion to and from the Tripos Sybyl MOL2 file format is supported by Tinker. The utility programs XYZMOL2 and MOL2XYZ transform a Tinker XYZ file to MOL2 format, and the reverse.

\sphinxstylestrong{PARAMETER FILES (*.PRM)}

The potential energy parameter files distributed with the Tinker package all end in the extension .prm, although this is not required by the programs themselves. Each of these files contains a definition of the potential energy functional forms for that force field as well as values for individual energy parameters. For example, the mm3pro.prm file contains the energy parameters and definitions needed for a protein\sphinxhyphen{}specific version of the MM3 force field.


\chapter{Potential Energy Programs}
\label{\detokenize{text/energy-programs:potential-energy-programs}}\label{\detokenize{text/energy-programs::doc}}
This section of the manual contains a brief description of each of the Tinker potential energy programs. A detailed example showing how to run each program is included in a later section. The programs listed below are all part of the main, supported distribution. Additional source code for various unsupported programs can be found in the /other directory of the Tinker distribution.

\sphinxstylestrong{ALCHEMY}

ALCHEMY is a simple program to perform very basic free energy perturbation calculations. This program is provided mostly for demonstration purposes.  For example, we use ALCHEMY in a molecular modeling course laboratory exercise to perform such classic mutations as chloride to bromide and ethane to methanol in water. The present version uses the perturbation formula and windowing with an explicit mapping of atoms involved in the mutation (“Amber”\sphinxhyphen{}style), instead of thermodynamic integration and independent freely propagating groups of mutated atoms (“CHARMM”\sphinxhyphen{}style). Some of the code specific to this program is limited to the Amber and OPLS potential functional forms, but could be easily generalized to handle other potentials. A more general and sophisticated version is currently under development.

\sphinxstylestrong{ANALYZE}

ANALYZE provides information about a specific molecular structure. The program will ask for the name of a structure file, which must be in the Tinker XYZ file format, and the type of analysis desired. Options allow output of:  (1) total potential energy of the system, (2) breakdown of the energy by potential function type or over individual atoms, (3) computation of the total dipole moment and its components, moments of inertia and radius of gyration, (4) listing of the parameters used to compute selected interaction energies, (5) energies associated with specified individual interactions.

\sphinxstylestrong{ANNEAL}

ANNEAL performs a molecular dynamics simulated annealing computation. The program starts from a specified input molecular structure in Tinker XYZ format. The trajectory is updated using either a modified Beeman or a velocity Verlet integration method. The annealing protocol is implemented by allowing smooth changes between starting and final values of the system temperature via the Groningen method of coupling to an external bath. The scaling can be linear or sigmoidal in nature. In addition, parameters such as cutoff distance can be transformed along with the temperature. The user must input the desired number of dynamics steps for both the equilibration and cooling phases, a time interval for the dynamics steps, and an interval between coordinate/trajectory saves. All saved coordinate sets along the trajectory are placed in sequentially numbered cycle files.

\sphinxstylestrong{CRITICAL}

CRITICAL performs a least squares optimization of the norm of the gradient vector in order to find the nearest stationary or critical point. It is generally the preferred method for location of transition states, as long as a reasonable initial starting structure is available. For optimization to a local minimum structure, CRITICAL will usually converge to loose tolerance more slowly than MINIMIZE, and to tight tolerance more slowly than NEWTON. Since the program can converge to any order of stationary point, it is necessary to use the VIBRATE program to identify the number of negative frequencies at the final structure.

\sphinxstylestrong{DYNAMIC}

DYNAMIC performs a molecular dynamics (MD) or stochastic dynamics (SD) computation. Starts either from a specified input molecular structure (an XYZ file) or from a structure\sphinxhyphen{}velocity\sphinxhyphen{}acceleration set saved from a previous dynamics trajectory (a restart from a DYN file). MD trajectories are propagated using either a modified Beeman or a velocity Verlet integration method. SD is implemented via our own derivation of a velocity Verlet\sphinxhyphen{}based algorithm. In addition the program can perform full crystal calculations, and can operate in constant energy mode or with maintenance of a desired temperature and/or pressure using the Berendsen method of coupling to external baths. The user must input the desired number of dynamics steps, a time interval for the dynamics steps, and an interval between coordinate/trajectory saves. Coordinate sets along the trajectory can be saved as sequentially numbered cycle files or directly to a Tinker archive (ARC) file. At the same time that a point along the trajectory is saved, the complete information needed to restart the trajectory from that point is updated and stored in the DYN file.

\sphinxstylestrong{GDA}

GDA is a program to implement Straub’s Gaussian Density Annealing algorithm over an effective series of analytically smoothed potential energy surfaces. This method can be viewed as an extended stochastic version of the diffusion equation method of Scheraga, et al., and also has many similar features to the Tinker Potential Smoothing and Search (PSS) series of programs. The current version of GDA is similar to but does not exactly reproduce Straub’s published method and is limited to argon clusters and other simple systems involving only van der Waals interactions; further modification and development of this code is currently underway in the Ponder research group. As with other programs involving potential smoothing, GDA currently requires use of the smooth.prm force field parameters.

\sphinxstylestrong{MINIMIZE}

The MINIMIZE program performs a limited memory L\sphinxhyphen{}BFGS minimization of an input structure over Cartesian coordinates using a modified version of the algorithm of Jorge Nocedal. The method requires only the potential energy and gradient at each step along the minimization pathway. It requires storage space proportional to the number of atoms in the structure. The MINIMIZE procedure is recommended for preliminary minimization of trial structures to an RMS gradient of 1.0 to 0.1 kcal/mole/Ang. It has a relatively fast cycle time and is tolerant of poor initial structures, but converges in a slow, linear fashion near the minimum. The user supplies the name of the Tinker XYZ coordinates file and a target rms gradient value at which the minimization will terminate. Output consists of minimization statistics written to the screen or redirected to an output file, and the new coordinates written to updated XYZ files or to cycle files.

\sphinxstylestrong{MINIROT}

The MINIROT program uses the same limited memory L\sphinxhyphen{}BFGS method as MINIMIZE, but performs the computation in terms of dihedral angles instead of Cartesian coordinates. Output is saved in an updated .int file or in cycle files.

\sphinxstylestrong{MINRIGID}

The MINRIGID program is similar to MINIMIZE except that it operates on rigid bodies starting from a Tinker XYZ coordinate file and the rigid body group definitions found in the corresponding KEY file. Output is saved in an updated XYZ file or in cycle files.

\sphinxstylestrong{MONTE}

The MONTE program implements the Monte Carlo Minimization algorithm developed by Harold Scheraga’s group and others. The procedure takes Monte Carlo steps for either a single atom or a single torsional angle, then performs a minimization before application of the Metropolis sampling method. This results in effective sampling of a modified potential surface where the only possible energy levels are those of local minima on the original surface. The program can be easily modified to elaborate on the available move set.

\sphinxstylestrong{NEWTON}

NEWTON is a truncated Newton minimization method which requires potential energy, gradient and Hessian information. This procedure has significant advantages over standard Newton methods, and is able to minimize very large structures completely. Several options are provided with respect to minimization method and preconditioning of the Newton equations. The default options are recommended unless the user is familiar with the math involved. This program operates in Cartesian coordinate space and is fairly tolerant of poor input structures. Typical algorithm iteration times are longer than with nonlinear conjugate gradient or variable metric methods, but many fewer iterations are required for complete minimization. NEWTON is usually the best choice for minimizations to the 0.01 to 0.000001 kcal/mole/Ang level of RMS gradient convergence. Tests for directions of negative curvature can be removed, allowing NEWTON to be used for optimization to conformational transition state structures (this only works if the starting point is very close to the transition state). Input consists of a Tinker XYZ coordinates file; output is an updated set of minimized coordinates and minimization statistics.

\sphinxstylestrong{NEWTROT}

The NEWTROT program is similar to NEWTON except that it requires a .int file as input and then operates in terms of dihedral angles as the minimization variables. Since the dihedral space Hessian matrix of an arbitrary structure is often indefinite, this method will often not perform as well as the other, simpler dihedral angle based minimizers.

\sphinxstylestrong{OPTIMIZE}

The OPTIMIZE program performs a optimally conditioned variable metric minimization of an input structure over Cartesian coordinates using an algorithm due to William Davidon. The method does not perform line searches, but requires computation of energies and gradients as well as storage for an estimate of the inverse Hessian matrix. The program operates on Cartesian coordinates from a Tinker XYZ file. OPTIMIZE will typically converge somewhat faster and more completely than MINIMIZE. However, the need to store and manipulate a full inverse Hessian estimate limits its use to structures containing less than a few hundred atoms on workstation class machines. As with the other minimizers, OPTIMIZE needs input coordinates and an rms gradient cutoff criterion. The output coordinates are saved in updated .xyz files or as cycle files.

\sphinxstylestrong{OPTIROT}

The OPTIROT program is similar to OPTIMIZE except that it operates on dihedral angles starting from a Tinker INT internal coordinate file. This program is usually the preferred method for most dihedral angle optimization problems since Truncated Newton methods appear, in our hands, to lose some of their efficacy in moving from Cartesian to torsional coordinates.

\sphinxstylestrong{OPTRIGID}

The OPTRIGID program is similar to OPTIMIZE except that it operates on rigid bodies starting from a Tinker XYZ coordinate file and the rigid body atom group definitions found in the corresponding KEY file. Output is saved in an updated XYZ file or in cycle files.

\sphinxstylestrong{PATH}

The PATH program implements a variant of Elber’s Lagrangian multiplier\sphinxhyphen{}based reaction path following algorithm. The program takes as input a pair of structural minima as Tinker XYZ files, and then generates a user specified number of points along a path through conformational space connecting the input structures. The intermediate structures are output as Tinker cycle files, and the higher energy intermediates can be used as input to a Newton\sphinxhyphen{}based optimization to locate conformational transition states.

\sphinxstylestrong{PSS}

PSS implements our version of a potential smoothing and search algorithm for the global optimization of molecular conformation. An initial structure in .xyz format is first minimized in Cartesian coordinates on a series of increasingly smoothed potential energy surfaces. Then the smoothing procedure is reversed with minimization on each successive surface starting from the coordinates of the minimum on the previous surface. A local search procedure is used during the backtracking to explore for alternative minima better than the one found during the current minimization. The final result is usually a very low energy conformation or, in favorable cases, the global energy minimum conformation. The minimum energy coordinate sets found on each surface during both the forward smoothing and backtracking procedures are placed in sequentially numbered cycle files.

\sphinxstylestrong{PSSRIGID}

PSSRIGID implements the potential smoothing and search method as described above for the PSS program, but performs the computation in terms of keyfile\sphinxhyphen{}defined rigid body atom groups instead of Cartesian coordinates. Output is saved in numbered cycle files with the XYZ file format.

\sphinxstylestrong{PSSROT}

PSSROT implements the potential smoothing and search method as described above for the PSS program, but performs the computation in terms of a set of user\sphinxhyphen{}specified dihedral angles instead of Cartesian coordinates. Output is saved in numbered cycle files with the INT file format.

\sphinxstylestrong{SADDLE}

The SADDLE program locates a conformational transition state between two potential energy minima. SADDLE uses a conglomeration of ideas from the Bell\sphinxhyphen{}Crighton quadratic path and the Halgren\sphinxhyphen{}Lipscomb synchronous transit methods. The basic idea is to perform a nonlinear conjugate gradient optimization in a subspace orthogonal to a suitably defined reaction coordinate. The program requires as input the coordinates, as Tinker XYZ files, of the two minima and an rms gradient convergence criterion for the optimization. The current estimate of the transition state structure is written to the file TSTATE.XYZ. Crude transition state structures generated by SADDLE can sometimes be refined using the NEWTON program. Optionally, a scan of the interconversion pathway can be made at each major iteration.

\sphinxstylestrong{SCAN}

SCAN is a program for general conformational search of an entire potential energy surface via a basin hopping method. The program takes as input a Tinker XYZ coordinates file which is then minimized to find the first local minimum for a search list. A series of activations along various normal modes from this initial minimum are used as seed points for additional minimizations. Whenever a previously unknown local minimum is located it is added to the search list. When all minima on the search list have been subjected to the normal mode activation without locating additional new minima, the program terminates. The individual local minima are written to cycle files as they are discovered. While the SCAN program can be used on standard undeformed potential energy surfaces, we have found it to be most useful for quickly “scanning” a smoothed energy surface to enumerate the major basins of attraction spaning the entire surface.

\sphinxstylestrong{SNIFFER}

SNIFFER is a program that implements the Sniffer global optimization algorithm of Butler and Slaminka, a discrete version of Griewank’s global search trajectory method. The program takes an input Tinker XYZ coordinates file and shakes it vigorously via a modified dynamics trajectory before, hopefully, settling into a low lying minimum. Some trial and error is often required as the current implementation is sensitive to various parameters and tolerances that govern the computation. At present, these parameters are not user accessible, and must be altered in the source code. However, this method can do a good job of quickly optimizing conformation within a limited range of convergence.

\sphinxstylestrong{TESTGRAD}

The TESTGRAD program computes and compares the analytical and numerical first derivatives (i.e., the gradient vector) of the potential energy for a Cartesian coordinate input structure. The output can be used to test or debug the current potential or any added user defined energy terms.

\sphinxstylestrong{TESTHESS}

The TESTHESS program computes and compares the analytical and numerical second derivatives (i.e., the Hessian matrix) of the potential energy for a Cartesian coordinate input structure. The output can be used to test or debug the current potential or any added user defined energy terms.

\sphinxstylestrong{TESTPAIR}

The TESTPAIR program compares the efficiency of different nonbonded neighbor methods for the current molecular system. The program times the computation of energy and gradient for the van der Waals and charge\sphinxhyphen{}charge electrostatic potential terms using a simple double loop over all interactions and using the Method of Lights algorithm to select neighbors. The results can be used to decide whether the Method of Lights has any CPU time advantage for the current structure. Both methods should give exactly the same answer in all cases, since the identical individual interactions are computed by both methods. The default double loop method is faster when cutoffs are not used, or when the cutoff sphere contains about half or more of the total system of unit cell. In cases where the cutoff sphere is much smaller than the system size, the Method of Lights can be much faster since it avoids unnecessary calculation of distances beyond the cutoff range.

\sphinxstylestrong{TESTPOL}

TESTPOL computes and compares several different methods for determining polarization via atomic induced dipole moments. The available methods include direct polarization (“iAMOEBA”), mutual SCF iteration to varying levels of convergence (via PCG iteration), perturbation theory extrapolation (OPT2 through OPT6), and truncated conjugate gradient (TCG1 and TCG2) solvers. The program will also find the best set of OPT coefficients for the system considered.

\sphinxstylestrong{TESTROT}

The TESTROT program computes and compares the analytical and numerical first derivatives (i.e., the gradient vector) of the potential energy with respect to dihedral angles. Input is a Tinker INT internal coordinate file. The output can be used to test or debug the current potential functions or any added user defined energy terms.

\sphinxstylestrong{TESTVIR}

The TESTVIR program checks the accuracy of the analytical internal virial calculation by comparison against a numerical virial computed from the finite\sphinxhyphen{}difference derivative of the energy with respect to the lattice vectors.

\sphinxstylestrong{TIMER}

TIMER is a simple program to provide timing statistics for energy function calls within the Tinker package. TIMER requires an input XYZ file and outputs the CPU time (or wall clock time, on some machine types) needed to perform a specified number of energy, gradient and Hessian evaluations.

\sphinxstylestrong{TIMEROT}

The TIMEROT program is similar to TIMER, only it operates over dihedral angles via input of a Tinker INT internal coordinate file. In the current version, the torsional Hessian is computed numerically from the analytical torsional gradient.

\sphinxstylestrong{VIBBIG}

VIBBIG is a specialized program for the computing selected vibrational frequencies of a large input molecular system using a sliding block iterative method to avoid direct diagonalization of the full Hessian matrix. As implemented the program will first find the lowest frequency vibration and proceed to higher frequencies in order.

\sphinxstylestrong{VIBRATE}

VIBRATE is a program to perform vibrational analysis by computing and diagonalizing the full Hessian matrix (i.e., the second partial derivatives) for an input structure (a Tinker XYZ file). Eigenvalues and eigenvectors of the mass weighted Hessian (i.e., the vibrational frequencies and normal modes) are also calculated. Structures corresponding to individual normal mode motions can be saved in cycle files.

\sphinxstylestrong{VIBROT}

The program VIBROT forms the torsional Hessian matrix via numerical differentiation of the analytical torsional gradient. The Hessian is then diagonalized and the eigenvalues are output. The present version does not compute the kinetic energy matrix elements needed to convert the Hessian into the torsional normal modes; this will be added in a later version. The required input is a Tinker INT internal coordinate file.

\sphinxstylestrong{XTALFIT}

The XTALFIT program is of use in the automated fitting of potential parameters to crystal structure and thermodynamic data. XTALFIT takes as input several crystal structures (Tinker XYZ files with unit cell parameters in corresponding KEY files) as well as information on lattice energies and dipole moments of monomers. The current version uses a nonlinear least squares optimization to fit van der Waals and electrostatic parameters to the input data. Bounds can be placed on the values of the optimization parameters.

\sphinxstylestrong{XTALMIN}

XTALMIN is used to perform full crystal minimizations. The program takes as input the structure coordinates and unit cell lattice parameters. It then alternates cycles of Newton\sphinxhyphen{}style optimization of the structure and conjugate gradient optimization of the crystal lattice parameters. This alternating minimization is slower than more direct optimization of all parameters at once, but is somewhat more robust in our hands. The symmetry of the original crystal is not enforced, so interconversion of crystal forms may be observed in some cases.


\chapter{Analysis \& Utility Programs \& Scripts}
\label{\detokenize{text/analysis-programs:analysis-utility-programs-scripts}}\label{\detokenize{text/analysis-programs::doc}}
This section of the manual contains a brief description of each of the Tinker structure manipulation, geometric calculation and auxiliary programs. A detailed example showing how to run each program is included in a later section. The programs listed below are all part of the main, supported distribution. Additional source code for various unsupported programs can be found in the /other directory of the Tinker distribution.

\sphinxstylestrong{ARCHIVE}

ARCHIVE is a program for concatenating Tinker cycle files into a single archive file; useful for storing the intermediate results of minimizations, dynamics trajectories, and so on. The program can also extract individual cycle files from a Tinker archive.

\sphinxstylestrong{BAR}

The BAR program computes a free energy from sampling of adjacent “lambda” windows using the Bennett acceptance ratio (BAR) algorithm. Input consists of trajectories or configurations sampled from the adjacent windows, as well as keyfiles and parameters used to define the states for the simulations. In a first phase, the BAR program computes the energies of all structures from both simulations under the control of both sets of potential energy parameters, i.e., four sets of numbers which are written to an intermediate .bar file. In its second phase, BAR reads a .bar file and uses the free energy perturbation (FEP) and Bennett acceptance ratio formula to compute the free energy, enthalpy and entropy between the two states.

\sphinxstylestrong{CORRELATE}

The CORRELATE program to compute time correlation functions from collections of Tinker cycle files. Its use requires a user supplied function property that computes the value of the property for which a time correlation is desired for two input structures. A sample routine is supplied that computes either a velocity autocorrelation function or an rms structural superposition as a function of time. The main body of the program organizes the overall computation in an efficient manner and outputs the final time correlation function.

\sphinxstylestrong{CRYSTAL}

CRYSTAL is a program for the manipulation of crystal structures including interconversion of fractional and Cartesian coordinates, generation of the unit cell from an asymmetric unit, and building of a crystalline block of specified size via replication of a single unit cell. The present version can handle about 25 of the most common space groups, others can easily be added as needed by modification of the routine symmetry.

\sphinxstylestrong{DIFFUSE}

DIFFUSE computes the self\sphinxhyphen{}diffusion constant for a homogeneous liquid via the Einstein equation. A previously saved dynamics trajectory is read in and “unfolded” to reverse translation of molecules due to use of periodic boundary conditions. The average motion over all molecules is then used to compute the self\sphinxhyphen{}diffusion constant. While the current program assumes a homogeneous system, it should be easy to modify the code to handle diffusion of individual molecules or other desired effects.

\sphinxstylestrong{DISTGEOM}

The DISTGEOM program performs distance geometry calculations using variations on the classic metric matrix method. A user specified number of structures consistent with keyfile input distance and dihedral restraints is generated. Bond length and angle restraints are derived from the input structure. Trial distances between the triangle smoothed lower and upper bounds can be chosen via any of several metrization methods, including a very effective partial random pairwise scheme. The correct radius of gyration of the structure is automatically maintained by choosing trial distances from Gaussian distributions of appropriate mean and width. The initial embedded structures can be further refined against a geometric restraint\sphinxhyphen{}only potential using either a sequential minimization protocol or simulated annealing.

\sphinxstylestrong{DOCUMENT}

The DOCUMENT program is provided as a minimal listing and documentation tool. It operates on the Tinker source code, either individual files or the complete source listing produced by the command script listing.make, to generate lists of routines, common blocks or valid keywords. In addition, the program has the ability to output a formatted parameter listing from the standard Tinker parameter files.

\sphinxstylestrong{FREEFIX}

FREEFIX is a small utility to compute the analytical enthalpy, entropy and free energy associated with the release of a flat\sphinxhyphen{}bottomed harmonic distance restraint between two sites within a simulation system.

\sphinxstylestrong{INTEDIT}

INTEDIT allows interactive inspection and alteration of the internal coordinate definitions and values of a Tinker structure. If the structure is altered, the user has the option to write out a new internal coordinates file upon exit.

\sphinxstylestrong{INTXYZ}

The INTXYZ program to convert a Tinker .int internal coordinates formatted file into a Tinker .xyz Cartesian coordinates formatted file.

\sphinxstylestrong{MOLXYZ}

MOLXYZ is a program for converting a MDL (Molecular Design Limited) MOL file into a Tinker XYZ Cartesian coordinate file. The current version of the program converts the MDL atoms types into Tinker “tiny force field” atom types based on atomic number and connectivity (i.e., a tetravalent carbon is type 64).

\sphinxstylestrong{MOL2XYZ}

The MOL2XYZ program converts a Tripos Sybyl MOL2 file into a Tinker XYZ Cartesian coordinate file. The current version of the program converts the Sybyl MOL2 atoms types into Tinker “tiny force field” atom types based on atomic number and connectivity (i.e., a tetravalent carbon is type 64).

\sphinxstylestrong{NUCLEIC}

The NUCLEIC program automates building of nucleic acid structures. Upon interactive input of a nucleotide sequence with optional phosphate backbone angles, the program builds internal and Cartesian coordinates. Standard bond lengths and angles are used. Both DNA and RNA sequences are supported as are A\sphinxhyphen{}, B\sphinxhyphen{} and Z\sphinxhyphen{}form structures. Double helixes of complementary sequence can be automatically constructed via a rigid docking of individual strands.

\sphinxstylestrong{PDBXYZ}

PDBXYZ is a program for converting a Brookhaven Protein Data Bank file (a PDB file) into a Tinker .xyz Cartesian coordinate file. If the PDB file contains only protein/peptide amino acid residues, then standard protein connectivity is assumed, and transferred to the .xyz file. For non\sphinxhyphen{}protein portions of the PDB file, atom connectivity is determined by the program based on interatomic distances. The program also has the ability to add or remove hydrogen atoms from a protein as required by the force field specified during the computation.

\sphinxstylestrong{POLARIZE}

POLARIZE is a simple program for computing molecular polarizability from an atom\sphinxhyphen{}based distributed model of polarizability. POLARIZE implements whichever damped interaction model is specified via keyfile and parameter settings. A Tinker .xyz file is required as input. The output consists of the overall polarizability tensor in the global coordinates and its eigenvalues.

\sphinxstylestrong{POLEDIT}

POLEDIT is a program for manipulating and processing polarizable atomic multipole models. Its primary use is to read a distributed multipole analysis (DMA) from output of the GDMA or Psi4 quantum chemistry programs. The program defines local coordinate frames, sets atomic polarizabilities, removes molecular mechanics polarization from the quantum DMA, averages over symmetrical atoms and outputs parameters in Tinker format. There are additional invocation options to only change local coordinate frame definitions or remove intramolecular polarization from an existing multipole model.

\sphinxstylestrong{POTENTIAL}

The POTENTIAL program performs electrostatic potential comparisons and fitting. POTENTIAL can compare two different force field electrostatic models via computing the RMS between the electrostatic potentials on a grid of points outside the molecular envelope. An electrostatic potential grid can also be generated from quantum chemistry output, and compare against a force field model. Finally, a flexible fitting of a force field model to an existing potential grid is available. The program can also take as model input a set of different molecules containing common types, and multiple conformations of a single molecule.

\sphinxstylestrong{PRMEDIT}

PRMEDIT is a program for formatting and renumbering Tinker force field parameter files. When atom types or classes are added to a parameter file, this utility program has the ability to renumber all the atom records sequentially, and alter type and class numbers in all other parameter entries to maintain consistency.

\sphinxstylestrong{PROTEIN}

The PROTEIN program automates building of peptide and protein structures. Upon interactive input of an amino acid sequence with optional phi/psi/omega/chi angles, D/L chirality, etc., the program builds internal and Cartesian coordinates. Standard bond lengths and angles are assumed for the peptide. The program will optionally convert the structure to a cyclic peptide, or add either or both N\sphinxhyphen{} and C\sphinxhyphen{}terminal capping groups. Atom type numbers are automatically assigned for the specified force field. The final coordinates and a sequence file are produced as the output.

\sphinxstylestrong{RADIAL}

The RADIAL program finds the pair radial distribution function between two atom types. The user supplies the two atom names for which the distribution function is to be computed, and the width of the distance bins for data analysis. A previously saved dynamics trajectory is read as input. The raw radial distribution and a spline smoothed version are then output from zero to a distance equal to half the minimum periodic box dimension. The atom names are matched to the atom name column of the Tinker .xyz file, independent of atom type.

\sphinxstylestrong{SPACEFILL}

The SPACEFILL program computes the volume and surface areas of molecules. Using a modified version of Connolly’s original analytical description of the molecular surface, the program determines either the van der Waals, accessible or molecular (contact/reentrant) volume and surface area. Both surface area and volume are broken down into their geometric components, and surface area is decomposed into the convex contribution for each individual atom. The probe radius is input as a user option, and atomic radii can be set via the keyword file. If Tinker archive files are used as input, the program will compute the volume and surface area of each structure in the input file.

\sphinxstylestrong{SPECTRUM}

SPECTRUM is a program to compute a power spectrum from velocity autocorrelation data. As input, this program requires a velocity autocorrelation function as produced by the CORRELATE program. This data, along with a user input time step, are Fourier transformed to generate the spectral intensities over a wavelength range. The result is a power spectrum, and the positions of the bands are those predicted for an infrared or Raman spectrum. However, the data is not weighted by molecular dipole moment derivatives as would be required to produce correct IR intensities.

\sphinxstylestrong{SUPERPOSE}

The SUPERPOSE program is used to superimpose two molecular structures in 3\sphinxhyphen{}dimensions. A variety of options for input of the atom sets to be used during the superposition are presented interactively to the user. The superposition can be mass\sphinxhyphen{}weighted if desired, and the coordinates of the second structure superimposed on the first structure are optionally output. If Tinker archive files are used as input, the program will compute all pairwise superpositions between structures in the input files.

\sphinxstylestrong{TORSFIT}

TORSFIT is a program for setting force field parameters for torsional terms by fitting 1\sphinxhyphen{}fold to 6\sphinxhyphen{}fold torsional amplitudes to the difference between a quantum chemistry rotational profile and a force field rotational profile without any torsional terms.

\sphinxstylestrong{VALENCE}

VALENCE is a program for setting force field parameters for local valence terms, either from quantum chemistry data or from embedded empirical rules. {[}This program is still under development.{]}

\sphinxstylestrong{XYZEDIT}

XYZEDIT is a program to perform a variety of manipulations on an input Tinker .xyz Cartesian coordinates formatted file. The present version of the program has the following interactively selectable options: (1) Offset the Numbers of the Current Atoms, (2) Deletion of Individual Specified Atoms, (3) Deletion of Specified Types of Atoms, (4) Deletion of Atoms outside Cutoff Range, (5) Insertion of Individual Specified Atoms, (6) Replace Old Atom Type with a New Type, (7) Assign Connectivities based on Distance, (8) Convert Units from Bohrs to Angstroms, (9) Invert thru Origin to give Mirror Image, (10) Translate Center of Mass to the Origin, (11) Translate a Specified Atom to the Origin, (12) Translate and Rotate to Inertial Frame, (13) Move to Specified Rigid Body Coordinates, (14) Create and Fill a Periodic Boundary Box, (15) Soak Current Molecule in Box of Solvent, (16) Append another XYZ file to Current One. In most cases, multiply options can be applied sequentially to an input file. At the end of the editing process, a new version of the original .xyz file is written as output.

\sphinxstylestrong{XYZINT}

XYZINT converts a Tinker .xyz Cartesian coordinate formatted file into a Tinker .int internal coordinates formatted file. This program can optionally use an existing internal coordinates file as a template for the connectivity information.

\sphinxstylestrong{XYZMOL2}

XYZMOL2 is a program to convert a Tinker .xyz Cartesian coordinates file into a Tripos Sybyl MOL2 file. The conversion generates only the MOLECULE, ATOM, BOND and SUBSTRUCTURE record type in the MOL2 file. Generic Sybyl atom types are used in most cases; while these atom types may need to be altered in some cases, Sybyl is usually able to correctly display the resulting MOL2 file.

\sphinxstylestrong{XYZPDB}

The XYZPDB program converts a Tinker .xyz Cartesian coordinate file into a Brookhaven Protein Data Bank file (a PDB file). A Tinker .seq file with the biopolymer sequence must be present if the output PDB file is to be formatted as a protein or nucleic acid with a defined sequence.


\chapter{Force Field Parameter Sets}
\label{\detokenize{text/parameters:force-field-parameter-sets}}\label{\detokenize{text/parameters::doc}}
The Tinker package is distributed with several force field parameter sets, implementing a selection of widely used literature force fields as well as the Tinker force field currently under construction in the Ponder lab. We try to exactly reproduce the intent of the original authors of our distributed, third\sphinxhyphen{}party force fields. In all cases the parameter sets have been validated against literature reports, results provided by the original developers, or calculations made with the authentic programs. With the few exceptions noted below, Tinker calculations can be treated as authentic results from the genuine force fields. A brief description of each parameter set, including some still in preparation and not distributed with the current version, is provided below with lead literature references for the force field:

\sphinxstylestrong{AMOEBA.PRM}

Parameters for the AMOEBA polarizable atomic multipole force field. As of the current Tinker release, we have completed parametrization for a number of ions and small organic molecules. For further information, or if you are interested in developing or testing parameters for other small molecules, please contact the Ponder lab.

P. Ren and J. W. Ponder, A Consistent Treatment of Inter\sphinxhyphen{} and Intramolecular Polarization in Molecular Mechanics Calculations, J. Comput. Chem., 23, 1497\sphinxhyphen{}1506 (2002)

P. Ren and J. W. Ponder, Polarizable Atomic Multipole Water Model for Molecular Mechanics Simulation, J. Phys. Chem. B, 107, 5933\sphinxhyphen{}5947 (2003)

P. Ren and J. W. Ponder, Ion Solvation Thermodynamics from Simulation with a Polarizable Force Field, A. Grossfield, J. Am. Chem. Soc., 125, 15671\sphinxhyphen{}15682 (2003)

\sphinxstylestrong{AMOEBAPRO.PRM}

Preliminary protein parameters for the AMOEBA polarizable atomic multipole force field. While the distributed parameters are still subject to minor alteration as we continue validation, they are now stable enough for other groups to begin using them. For further information, or if you are interested in testing the protein parameter set, please contact the Ponder lab.

J. W. Ponder and D. A. Case, Force Fields for Protein Simulation, Adv. Prot. Chem., 66, 27\sphinxhyphen{}85 (2003)

P. Ren and J. W. Ponder, Polarizable Atomic Multipole\sphinxhyphen{}based Potential for Proteins: Model and Parameterization, in preparation

\sphinxstylestrong{AMBER94.PRM}

AMBER ff94 parameters for proteins and nucleic acids. Note that with their “Cornell” force field, the Kollman group has devised separate, fully independent partial charge values for each of the N\sphinxhyphen{} and C\sphinxhyphen{}terminal amino acid residues. At present, the terminal residue charges for Tinker’s version maintain the correct formal charge, but redistributed somewhat at the alpha carbon atoms from the original Kollman group values. The total magnitude of the redistribution is less than 0.01 electrons in most cases.

W. D. Cornell, P. Cieplak, C. I. Bayly, I. R. Gould, K. M. Merz, Jr., D. M. Ferguson, D. C. Spellmeyer, T. Fox, J. W. Caldwell and P. A. Kollman, A Second Generation Force Field for the Simulation of Proteins, Nucleic Acids, and Organic Molecules, J. Am. Chem. Soc., 117, 5179\sphinxhyphen{}5197 (1995)  {[}ff94{]}

G. Moyna, H. J. Williams, R. J. Nachman and A. I. Scott, Conformation in Solution and Dynamics of a Structurally Constrained Linear Insect Kinin Pentapeptide Analogue, Biopolymers, 49, 403\sphinxhyphen{}413 (1999)  {[}AIB charges{]}

W. S. Ross and C. C. Hardin, Ion\sphinxhyphen{}Induced Stabilization of the G\sphinxhyphen{}DNA Quadruplex: Free Energy Perturbation Studies, J. Am. Chem. Soc., 116, 4363\sphinxhyphen{}4366 (1994)   {[}alkali metal ions{]}

J. Aqvist, Ion\sphinxhyphen{}Water Interaction Potentials Derived from Free Energy Perturbation Simulations, J. Phys. Chem., 94, 8021\sphinxhyphen{}8024, 1990  {[}alkaline earth Ions, radii adapted for Amber combining rule{]}

Current force field parameter values and suggested procedures for development of parameters for additional molecules are available from the Amber web site in the Case lab at Scripps, \sphinxurl{http://amber.scripps.edu/}

\sphinxstylestrong{AMBER96.PRM}

AMBER ff96 parameters for proteins and nucleic acids. The only change from the ff94 parameter set is in the torsional parameters for the protein phi/psi angles. These values were altered to give better agreement with  changes of ff96 with LMP2 QM results from the Friesner lab on alanine dipeptide and tetrapeptide.

P. Kollman, R. Dixon, W. Cornell, T. Fox, C. Chipot and A. Pohorille, The Development/ Application of a ‘Minimalist’ Organic/Biochemical Molecular Mechanic Force Field using a Combination of ab Initio Calculations and Experimental Data, in Computer Simulation of Biomolecular Systems, W. F. van Gunsteren, P. K. Weiner, A. J. Wilkinson, eds., Volume 3, 83\sphinxhyphen{}96 (1997)  {[}ff96{]}

Current force field parameter values and suggested procedures for development of parameters for additional molecules are available from the Amber web site in the Case lab at Scripps, \sphinxurl{http://amber.scripps.edu/}

\sphinxstylestrong{AMBER98.PRM}

AMBER ff98 parameters for proteins and nucleic acids. The only change from the ff94 parameter set is in the glycosidic torsional parameters that control sugar pucker.

T. E. Cheatham III, P. Cieplak and P. A. Kollman, A Modified Version of the Cornell et al. Force Field with Improved Sugar Pucker Phases and Helical Repeat, J. Biomol. Struct. Dyn., 16, 845\sphinxhyphen{}862 (1999)

Current force field parameter values and suggested procedures for development of parameters for additional molecules are available from the Amber web site in the Case lab at Scripps, \sphinxurl{http://amber.scripps.edu/}

\sphinxstylestrong{AMBER99.PRM}

AMBER ff99 parameters for proteins and nucleic acids. The original partial charges from the ff94 parameter set are retained, but many of the bond, angle and torsional parameters have been revised to provide better general agreement with experiment.

J. Wang, P. Cieplak and P. A. Kollman, How Well Does a Restrained Electrostatic Potential (RESP) Model Perform in Calcluating Conformational Energies of Organic and Biological Molecules?, J. Comput. Chem., 21, 1049\sphinxhyphen{}1074 (2000)

Current force field parameter values and suggested procedures for development of parameters for additional molecules are available from the Amber web site in the Case lab at Scripps, \sphinxurl{http://amber.scripps.edu/}

\sphinxstylestrong{CHARMM19.PRM}

CHARMM19 united\sphinxhyphen{}atom parameters for proteins. The nucleic acid parameter are not yet implemented. There are some differences between authentic CHARMM19 and the Tinker version due to replacement of CHARMM impropers by torsions for cases that involve atoms not bonded to the trigonal atom and Tinker’s use of all possible torsions across a bond instead of a single torsion per bond.

E. Neria, S. Fischer and M. Karplus, Simulation of Activation Free Energies in Molecular Systems, J. Chem. Phys., 105, 1902\sphinxhyphen{}1921 (1996)

L. Nilsson and M. Karplus, Empirical Energy Functions for Energy Minimizations and Dynamics of Nucleic Acids, J. Comput. Chem., 7, 591\sphinxhyphen{}616 (1986)

W. E. Reiher III, Theoretical Studies of Hydrogen Bonding, Ph.D. Thesis, Department of Chemistry, Harvard University, Cambridge, MA, 1985

\sphinxstylestrong{CHARMM22.PRM}

CHARMM22 all\sphinxhyphen{}atom parameters for proteins and lipids. Most of the nucleic acid and small model compound parameters are not yet implemented. We plan to provide these additional parameters in due course.

N. Foloppe and A. D. MacKerell, Jr., All\sphinxhyphen{}Atom Empirical Force Field for Nucleic Acids: 1) Parameter Optimization Based on Small Molecule and Condensed Phase Macromolecular Target Data, J. Comput. Chem., 21, 86\sphinxhyphen{}104 (2000)  {[}CHARMM27{]}

N. Banavali and A. D. MacKerell, Jr., All\sphinxhyphen{}Atom Empirical Force Field for Nucleic Acids: 2) Application to Molecular Dynamics Simulations of DNA and RNA in Solution, J. Comput. Chem., 21, 105\sphinxhyphen{}120 (2000)

A. D. MacKerrell, Jr., et al., All\sphinxhyphen{}Atom Empirical Potential for Molecular Modeling and Dynamics Studies of Proteins, J. Phys. Chem. B, 102, 3586\sphinxhyphen{}3616 (1998)  {[}CHARMM22{]}

A. D. MacKerell, Jr., J. Wiorkeiwicz\sphinxhyphen{}Kuczera and M. Karplus, An All\sphinxhyphen{}Atom Empirical Energy Function for the Simulation of Nucleic Acids, J. Am. Chem. Soc., 117, 11946\sphinxhyphen{}11975 (1995)

S. E. Feller, D. Yin, R. W. Pastor and A. D. MacKerell, Jr., Molecular Dynamics Simulation of Unsaturated Lipids at Low Hydration: Parametrization and Comparison with Diffraction Studies, Biophysical Journal, 73, 2269\sphinxhyphen{}2279 (1997)  {[}alkenes{]}

R. H. Stote and M. Karplus, Zinc Binding in Proteins and Solution \sphinxhyphen{} A Simple but Accurate Nonbonded Representation, Proteins, 23, 12\sphinxhyphen{}31 (1995)  {[}zinc ion{]}

Current and legacy parameter values are available from the CHARMM force field web site on Alex MacKerell’s  Research Interests page at the University of Maryland School of Pharmacy, \sphinxurl{https://rxsecure.umaryland.edu/research/amackere/research.html/}

\sphinxstylestrong{DUDEK.PRM}

Protein\sphinxhyphen{}only parameters for the early 1990’s Tinker force field with multipole values of Dudek and Ponder. The current file contains only the multipole values from the 1995 paper by Dudek and Ponder. This set is now superceeded by the more recent Tinker force field developed by Pengyu Ren (see WATER.PRM, below).

M. J. Dudek and J. W. Ponder, Accurate Electrostatic Modelling of the Intramolecular Energy of Proteins, J. Comput. Chem., 16, 791\sphinxhyphen{}816 (1995)

\sphinxstylestrong{ENCAD.PRM}

ENCAD parameters for proteins and nucleic acids.  (in preparation)

M. Levitt, M. Hirshberg, R. Sharon and V. Daggett, Potential Energy Function and Parameters for Simulations of the Molecular Dynamics of Protein and Nucleic Acids in Solution, Comp. Phys. Commun., 91, 215\sphinxhyphen{}231 (1995)

M. Levitt, M. Hirshberg, R. Sharon, K. E. Laidig and V. Daggett, Calibration and Testing of a Water Model for Simulation of the Molecular Dynamics of Protein and Nucleic Acids in Solution, J. Phys. Chem. B, 101, 5051\sphinxhyphen{}5061 (1997)  {[}F3C water{]}

\sphinxstylestrong{HOCH.PRM}

Simple NMR\sphinxhyphen{}NOE force field of Hoch and Stern.

J. C. Hoch and A. S. Stern, A Method for Determining Overall Protein Fold from NMR Distance Restraints, J. Biomol. NMR, 2, 535\sphinxhyphen{}543 (1992)

\sphinxstylestrong{MM2.PRM}

Full MM2(1991) parameters including ?\sphinxhyphen{}systems. The anomeric and electronegativity correction terms included in some later versions of MM2 are not implemented.

N. L. Allinger, Conformational Analysis. 130. MM2. A Hydrocarbon Force Field Utilizing V1 and V2 Torsional Terms, J. Am. Chem. Soc., 99, 8127\sphinxhyphen{}8134 (1977)

J. T. Sprague, J. C. Tai, Y. Yuh and N. L. Allinger, The MMP2 Calculational Method, J. Comput. Chem., 8, 581\sphinxhyphen{}603 (1987)

J. C. Tai and N. L. Allinger, Molecular Mechanics Calculations on Conjugated Nitrogen\sphinxhyphen{}Containing Heterocycles, J. Am. Chem. Soc., 110, 2050\sphinxhyphen{}2055 (1988)

J. C. Tai, J.\sphinxhyphen{}H. Lii and N. L. Allinger, A Molecular Mechanics (MM2) Study of Furan, Thiophene, and Related Compounds, J. Comput. Chem., 10, 635\sphinxhyphen{}647 (1989)

N. L. Allinger, R. A. Kok and M. R. Imam, Hydrogen Bonding in MM2, J. Comput. Chem., 9, 591\sphinxhyphen{}595 (1988)

L. Norskov\sphinxhyphen{}Lauritsen and N. L. Allinger, A Molecular Mechanics Treatment of the Anomeric Effect, J. Comput. Chem., 5, 326\sphinxhyphen{}335 (1984)

All parameters distributed with Tinker are from the “MM2 (1991) Parameter Set”, as provided by N. L. Allinger, University of Georgia

\sphinxstylestrong{MM3.PRM}

Full MM3(2000) parameters including pi\sphinxhyphen{}systems. The directional hydrogen bonding term and electronegativity bond length corrections are implemented, but the anomeric and Bohlmann correction terms are not implemented.

N. L. Allinger, Y. H. Yuh and J.\sphinxhyphen{}H. Lii, Molecular Mechanics. The MM3 Force Field for Hydrocarbons. 1, J. Am. Chem. Soc., 111, 8551\sphinxhyphen{}8566 (1989)

J.\sphinxhyphen{}H. Lii and N. L. Allinger, Molecular Mechanics. The MM3 Force Field for Hydrocarbons. 2. Vibrational Frequencies and Thermodynamics, J. Am. Chem. Soc., 111, 8566\sphinxhyphen{}8575 (1989)

J.\sphinxhyphen{}H. Lii and N. L. Allinger, Molecular Mechanics. The MM3 Force Field for Hydrocarbons. 3. The van der Waals’ Potentials and Crystal Data for Aliphatic and Aromatic Hydrocarbons, J. Am. Chem. Soc., 111, 8576\sphinxhyphen{}8582 (1989)

N. L. Allinger, H. J. Geise, W. Pyckhout, L. A. Paquette and J. C. Gallucci, Structures of Norbornane and Dodecahedrane by Molecular Mechanics Calculations (MM3), X\sphinxhyphen{}ray Crystallography, and Electron Diffraction, J. Am. Chem. Soc., 111, 1106\sphinxhyphen{}1114 (1989)  {[}stretch\sphinxhyphen{}torsion cross term{]}

N. L. Allinger, F. Li and L. Yan, Molecular Mechanics. The MM3 Force Field for Alkenes, J. Comput. Chem., 11, 848\sphinxhyphen{}867 (1990)

N. L. Allinger, F. Li, L. Yan and J. C. Tai, Molecular Mechanics (MM3) Calculations on Conjugated Hydrocarbons, J. Comput. Chem., 11, 868\sphinxhyphen{}895 (1990)

J.\sphinxhyphen{}H. Lii and N. L. Allinger, Directional Hydrogen Bonding in the MM3 Force Field. I, J. Phys. Org. Chem., 7, 591\sphinxhyphen{}609 (1994)

J.\sphinxhyphen{}H. Lii and N. L. Allinger, Directional Hydrogen Bonding in the MM3 Force Field. II, J. Comput. Chem., 19, 1001\sphinxhyphen{}1016 (1998)

All parameters distributed with Tinker are from the “MM3 (2000) Parameter Set”, as provided by N. L. Allinger, University of Georgia, August 2000

\sphinxstylestrong{MM3PRO.PRM}

Protein\sphinxhyphen{}only version of the MM3 parameters.

J.\sphinxhyphen{}H. Lii and N. L. Allinger, The MM3 Force Field for Amides, Polypeptides and Proteins, J. Comput. Chem., 12, 186\sphinxhyphen{}199 (1991)

\sphinxstylestrong{OPLSUA.PRM}

Complete OPLS\sphinxhyphen{}UA with united\sphinxhyphen{}atom parameters for proteins and many classes of organic molecules. Explicit hydrogens on polar atoms and aromatic carbons.

W. L. Jorgensen and J. Tirado\sphinxhyphen{}Rives, The OPLS Potential Functions for Proteins. Energy Minimizations for Crystals of Cyclic Peptides and Crambin, J. Am. Chem. Soc., 110, 1657\sphinxhyphen{}1666 (1988)  {[}peptide and proteins{]}

W. L. Jorgensen and D. L. Severance, Aromatic\sphinxhyphen{}Aromatic Interactions: Free Energy Profiles for the Benzene Dimer in Water, Chloroform, and Liquid Benzene, J. Am. Chem. Soc., 112, 4768\sphinxhyphen{}4774 (1990)  {[}aromatic hydrogens{]}

S. J. Weiner, P. A. Kollman, D. A. Case, U. C. Singh, C. Ghio, G. Alagona, S. Profeta, Jr. and P. Weiner, A New Force Field for Molecular Mechanical Simulation of Nucleic Acids and Proteins, J. Am. Chem. Soc., 106, 765\sphinxhyphen{}784 (1984)  {[}united\sphinxhyphen{}atom “AMBER/OPLS” local geometry{]}

S. J. Weiner, P. A. Kollman, D. T. Nguyen and D. A. Case, An All Atom Force Field for Simulations of Proteins and Nucleic Acids, J. Comput. Chem., 7, 230\sphinxhyphen{}252 (1986)  {[}all\sphinxhyphen{}atom “AMBER/OPLS” local geometry{]}

L. X. Dang and B. M. Pettitt, Simple Intramolecular Model Potentials for Water, J. Phys. Chem., 91, 3349\sphinxhyphen{}3354 (1987)  {[}flexible TIP3P and SPC water{]}

W. L. Jorgensen, J. D. Madura and C. J. Swenson, Optimized Intermolecular Potential Functions for Liquid Hydrocarbons, J. Am. Chem. Soc., 106, 6638\sphinxhyphen{}6646 (1984)  {[}hydrocarbons{]}

W. L. Jorgensen, E. R. Laird, T. B. Nguyen and J. Tirado\sphinxhyphen{}Rives, Monte Carlo Simulations of Pure Liquid Substituted Benzenes with OPLS Potential Functions, J. Comput. Chem., 14, 206\sphinxhyphen{}215 (1993)  {[}substituted benzenes{]}

E. M. Duffy, P. J. Kowalczyk and W. L. Jorgensen, Do Denaturants Interact with Aromatic Hydrocarbons in Water?, J. Am. Chem. Soc., 115, 9271\sphinxhyphen{}9275 (1993)  {[}benzene, naphthalene, urea, guanidinium, tetramethyl ammonium{]}

W. L. Jorgensen and C. J. Swenson, Optimized Intermolecular Potential Functions for Amides and Peptides. Structure and Properties of Liquid Amides, J. Am. Chem. Soc., 106, 765\sphinxhyphen{}784 (1984)  {[}amides{]}

W. L. Jorgensen, J. M. Briggs and M. L. Contreras, Relative Partition Coefficients for Organic Solutes form Fluid Simulations, J. Phys. Chem., 94, 1683\sphinxhyphen{}1686 (1990)  {[}chloroform, pyridine, pyrazine, pyrimidine{]}

J. M. Briggs, T. B. Nguyen and W. L. Jorgensen, Monte Carlo Simulations of Liquid Acetic Acid and Methyl Acetate with the OPLS Potential Functions, J. Phys. Chem., 95, 3315\sphinxhyphen{}3322 (1991)  {[}acetic acid, methyl acetate{]}

H. Liu, F. Muller\sphinxhyphen{}Plathe and W. F. van Gunsteren, A Force Field for Liquid Dimethyl Sulfoxide and Physical Properties of Liquid Dimethyl Sulfoxide Calculated Using Molecular Dynamics Simulation, J. Am. Chem. Soc., 117, 4363\sphinxhyphen{}4366 (1995)  {[}dimethyl sulfoxide{]}

J. Gao, X. Xia and T. F. George, Importance of Bimolecular Interactions in Developing Empirical Potential Functions for Liquid Ammonia, J. Phys. Chem., 97, 9241\sphinxhyphen{}9246 (1993)  {[}ammonia{]}

J. Aqvist, Ion\sphinxhyphen{}Water Interaction Potentials Derived from Free Energy Perturbation Simulations, J. Phys. Chem., 94, 8021\sphinxhyphen{}8024 (1990)  {[}metal ions{]}

W. S. Ross and C. C. Hardin, Ion\sphinxhyphen{}Induced Stabilization of the G\sphinxhyphen{}DNA Quadruplex: Free Energy Perturbation Studies, J. Am. Chem. Soc., 116, 4363\sphinxhyphen{}4366 (1994)  {[}alkali metal ions{]}

J. Chandrasekhar, D. C. Spellmeyer and W. L. Jorgensen, Energy Component Analysis for Dilute Aqueous Solutions of Li+, Na+, F\sphinxhyphen{}, and Cl\sphinxhyphen{} Ions, J. Am. Chem. Soc., 106, 903\sphinxhyphen{}910 (1984)  {[}halide ions{]}

Most parameters distributed with Tinker are from “OPLS and OPLS\sphinxhyphen{}AA Parameters for Organic Molecules, Ions, and Nucleic Acids” as provided by W. L. Jorgensen, Yale University, October 1997

\sphinxstylestrong{OPLSAA.PRM}

OPLS\sphinxhyphen{}AA force field with all\sphinxhyphen{}atom parameters for proteins and many general classes of organic molecules.

W. L. Jorgensen, D. S. Maxwell and J. Tirado\sphinxhyphen{}Rives, Development and Testing of the OPLS All\sphinxhyphen{}Atom Force Field on Conformational Energetics and Properties of Organic Liquids, J. Am. Chem. Soc., 117, 11225\sphinxhyphen{}11236 (1996)

D. S. Maxwell, J. Tirado\sphinxhyphen{}Rives and W. L. Jorgensen, A Comprehensive Study of the Rotational Energy Profiles of Organic Systems by Ab Initio MO Theory, Forming a Basis for Peptide Torsional Parameters, J. Comput. Chem., 16, 984\sphinxhyphen{}1010 (1995)

W. L. Jorgensen and N. A. McDonald, Development of an All\sphinxhyphen{}Atom Force Field for Heterocycles. Properties of Liquid Pyridine and Diazenes, THEOCHEM\sphinxhyphen{}J. Mol. Struct., 424, 145\sphinxhyphen{}155 (1998)

N. A. McDonald and W. L. Jorgensen, Development of an All\sphinxhyphen{}Atom Force Field for Heterocycles. Properties of Liquid Pyrrole, Furan, Diazoles, and Oxazoles, J. Phys. Chem. B, 102, 8049\sphinxhyphen{}8059 (1998)

R. C. Rizzo and W. L. Jorgensen, OPLS All\sphinxhyphen{}Atom Model for Amines: Resolution of the Amine Hydration Problem, J. Am. Chem. Soc., 121, 4827\sphinxhyphen{}4836 (1999)

M. L. P. Price, D. Ostrovsky and W. L. Jorgensen, Gas\sphinxhyphen{}Phase and Liquid\sphinxhyphen{}State Properties of Esters, Nitriles, and Nitro Compounds with the OPLS\sphinxhyphen{}AA Force Field, J. Comput. Chem., 22, 1340\sphinxhyphen{}1352 (2001)

All parameters distributed with Tinker are from “OPLS and OPLS\sphinxhyphen{}AA Parameters for Organic Molecules, Ions, and Nucleic Acids” as provided by W. L. Jorgensen, Yale University, October 1997

\sphinxstylestrong{OPLSAAL.PRM}

An improved OPLS\sphinxhyphen{}AA parameter set for proteins in which the only change is a reworking of many of the backbone and sidechain torsional parameters to give better agreement with LMP2 QM calculations. This parameter set is also known as OPLS(2000).

G. A. Kaminsky, R. A. Friesner, J. Tirado\sphinxhyphen{}Rives and W. L. Jorgensen, Evaluation and Reparametrization of the OPLS\sphinxhyphen{}AA Force Field for Proteins via Comparison with Accurate Quantum Chemical Calculations on Peptides, J. Phys. Chem. B, 105, 6474\sphinxhyphen{}6487 (2001)

\sphinxstylestrong{SMOOTH.PRM}

Version of OPLS\sphinxhyphen{}UA for use with potential smoothing. Largely adapted largely from standard OPLS\sphinxhyphen{}UA parameters with modifications to the vdw and improper torsion terms.

R. V. Pappu, R. K. Hart and J. W. Ponder, Analysis and Application of Potential Energy Smoothing and Search Methods for Global Optimization, J. Phys, Chem. B, 102, 9725\sphinxhyphen{}9742 (1998)  {[}smoothing modifications{]}

\sphinxstylestrong{SMOOTHAA.PRM}

Version of OPLS\sphinxhyphen{}AA for use with potential smoothing. Largely adapted largely from standard OPLS\sphinxhyphen{}AA parameters with modifications to the vdw and improper torsion terms.

R. V. Pappu, R. K. Hart and J. W. Ponder, Analysis and Application of Potential Energy Smoothing and Search Methods for Global Optimization, J. Phys, Chem. B, 102, 9725\sphinxhyphen{}9742 (1998)  {[}smoothing modifications{]}

\sphinxstylestrong{WATER.PRM}

The AMOEBA water parameters for a polarizable atomic multipole electrostatics model. This model is equal or better to the best available water models for many bulk and cluster properties.

P. Ren and J. W. Ponder, A Polarizable Atomic Multipole Water Model for Molecular Mechanics Simulation, J. Phys. Chem. B, 107, 5933\sphinxhyphen{}5947 (2003)

P. Ren and J. W. Ponder, Ion Solvation Thermodynamics from Simulation with a Polarizable Force Field, A. Grossfield, J. Am. Chem. Soc., 125, 15671\sphinxhyphen{}15682 (2003)

P. Ren and J. W. Ponder, Temperature and Pressure Dependence of the AMOEBA Water Model, J. Phys. Chem. B, 108, 13427\sphinxhyphen{}13437 (2004)

An earlier version the AMOEBA water model is described in: Yong Kong, Multipole Electrostatic Methods for Protein Modeling with Reaction Field Treatment, Biochemistry \& Molecular Biophysics, Washington University, St. Louis, August, 1997 {[}available from \sphinxurl{http://dasher.wustl.edu/ponder/}{]}


\chapter{Special Features \& Methods}
\label{\detokenize{text/special-features:special-features-methods}}\label{\detokenize{text/special-features::doc}}
This section contains several short notes with further information about Tinker methodology, algorithms and special features. The discussion is not intended to be exhaustive, but rather to explain features and capabilities so that users can make more complete use of the package.


\section{File  Version Numbers}
\label{\detokenize{text/special-features:file-version-numbers}}
All of the input and output file types routinely used by the Tinker package are capable of existing as multiple versions of a base file name. For example, if the program XYZINT is run on the input file molecule.xyz, the output internal coordinates file will be written to molecule.int. If a file named molecule.int is already present prior to running XYZINT, then the output will be written instead to the next available version, in this case to molecule.int\_2. In fact the output is generally written to the lowest available, previously unused version number (molecule.int\_3, molecule.int\_4, etc., as high as needed). Input file names are handled similarly. If simply molecule or molecule.xyz is entered as the input file name upon running XYZINT, then the highest version of molecule.xyz will be used as the actual input file. If an explicit version number is entered as part of the input file name, then the specified version will be used as the input file.

The version number scheme will be recognized by many older users as a holdover from the VMS origins of the first version of the Tinker software. It has been maintained to make it easier to chain together multiple calculations that may create several new versions of a given file, and to make it more difficult to accidently overwrite a needed result. The version scheme applies to most uses of many common Tinker file types such as .xyz, .int, .key, .arc. It is not used when an overwritten file update is obviously the correct action, for example, the .dyn molecular dynamics restart files. For those users who prefer a more Unix\sphinxhyphen{}like operation, and do not desire use of file versions, this feature can be turned off by adding the NOVERSION keyword to the applicable Tinker keyfile.

The version scheme as implemented in Tinker does have two known quirks. First, it becomes impossible to directly use the original unversioned copy of a file if higher version numbers are present. For example, if the files molecule.xyz and molecule.xyz\_2 both exist, then molecule.xyz cannot be accessed as input by XYZINT. If molecule.xyz is entered in response to the input file name question, molecule.xyz\_2 (or the highest present version number) will be used as input. The only workaround is to copy or rename molecule.xyz to something else, say molecule.new, and use that name for the input file. Secondly, missing version numbers always end the search for the highest available version number; i.e., version numbers are assumed to be consecutive and without gaps. For example, if molecule.xyz, molecule.xyz\_2 and molecule.xyz\_4 are present, but not molecule.xyz\_3, then molecule.xyz\_2 will be used as input to XYZINT if molecule is given as the input file name. Similarly, output files will fill in gaps in an already existing set of file versions.


\section{Command Line Options}
\label{\detokenize{text/special-features:command-line-options}}
Most of the Tinker programs support a selection of command line arguments and options. Many programs will take all the usual interactive input on the original command line used to invoke the program.

The name of the keyfile to be used for a calculation is read from the argument following a \sphinxhyphen{}k (equivalent to either \sphinxhyphen{}key or \sphinxhyphen{}keyfile, case insensitive) command line argument. Note that the \sphinxhyphen{}k options can appear anywhere on the command line following the executable name.

Similar to the keyfile option just described, the number of OpenMP threads to be used during a calculation can be specified as \sphinxhyphen{}t (equivalent to \sphinxhyphen{}threads, case insensitive) followed by an integer number.

All other command line arguments, excepting the name of the executable program itself, are treated as input arguments. These input arguments are read from left to right and interpreted in order as the answers to questions that would be asked by an interactive invocation of the same Tinker program. For example, the following command line:

newton molecule \sphinxhyphen{}k test a a 0.01

will invoke the NEWTON program on the structure file molecule.xyz using the keyfile test.key, automatic mode {[}a{]} for both the method and preconditioning, and 0.01 for the RMS gradient per atom termination criterion in kcal/mole/Ang. Provided that the force field parameter set, etc. is provided in test.key, the above compuation will procede directly from the command line invocation without further interactive input.


\section{Use on Windows Systems}
\label{\detokenize{text/special-features:use-on-windows-systems}}
Tinker executables for Microsoft PC systems should be run from the DOS or Command Prompt window available under the various versions of Windows. The Tinker executable directory should be added to your path via the autoexec.bat file or similar. If a Command Prompt window, set the number of scrollable lines to a very large number, so that you will be able to inspect screen output after it moves by. Alternatively, Tinker programs which generate large amounts of screen output should be run such that output will be redirected to a file. This can be accomplished by running the Tinker program in batch mode or by using the build\sphinxhyphen{}in Unix\sphinxhyphen{}like output redirection. For example, the command:

dynamic \textless{} molecule.inp \textgreater{} molecule.log

will run the Tinker dynamic program taking input from the file molecule.inp and sending output to molecule.log. Also note that command line options as described above are available with the distributed Tinker executables.

If the distributed Tinker executables are run directly from Windows by double clicking on the program icon, then the program will run in its own window. However, upon completion of the program the window will close and screen output will be lost. Any output files written by the program will, of course, still be available. The Windows behavior can be changed by adding the EXIT\sphinxhyphen{}PAUSE keyword to the keyfile. This keyword causes the executation window to remain open after completion until the “Return/Enter” key is pressed.

An alternative to Command Prompt windows is to use the PowerShell window available on Windows 10 systems, which provides a better emulation of many of the standard features of Linux shells and MacOS Terminal.

Yet another alternative, particularly attractive to those already familiar with Linux or Unix systems, is to download the Cygwin package currently available under GPL license from the site \sphinxurl{http://source.redhat.com/cygwin/}. The cygwin tools provide many of the GNU tools, including a bash shell window from which Tinker programs can be run.

Finally on Windows 10 systems, it is possible to download and install the Windows Subsystem for Linux (WSL), and then run the Tinker Linux executables from within WSL.


\section{Use on MacOS Systems}
\label{\detokenize{text/special-features:use-on-macos-systems}}
The command line versions of the Tinker executables are best run on MacOS in a “Terminal” application window where behavior is essentially identical to that in a Linux terminal.


\section{Atom Types vs. Atom Classes}
\label{\detokenize{text/special-features:atom-types-vs-atom-classes}}
Manipulation of atom types and the proliferation of parameters as atoms are further subdivided into new types is the bane of force field calculation. For example, if each topologically distinct atom arising from the 20 natural amino acids is given a different atom type, then about 300 separate type are required (this ignores the different N\sphinxhyphen{} and C\sphinxhyphen{}terminal forms of the residues, diastereotopic hydrogens, etc.). However, all these types lead to literally thousands of different force field parameters. In fact, there are many thousands of distinct torsional parameters alone. It is impossible at present to fully optimize each of these parameters; and even if we could, a great many of the parameters would be nearly identical. Two somewhat complimentary solutions are available to handle the proliferation of parameters. The first is to specify the molecular fragments to which a given parameter can be applied in terms of a chemical structure language, SMILES strings for example.

A second general approach is to use hierarchical cascades of parameter groups. Tinker uses a simple version of this scheme. Each Tinker force field atom has both an atom type number and an atom class number. The types are subsets of the atom classes, i.e., several different atom types can belong to the same atom class. Force field parameters that are somewhat less sensitive to local environment, such as local geometry terms, are then provided and assigned based on atom class. Other energy parameters, such as electrostatic parameters, that are very environment dependent are assigned over the atom types. This greatly reduces the number of independent multiple\sphinxhyphen{}atom parameters like the four\sphinxhyphen{}atom torsional parameters.


\section{Calculations on Partial Structures}
\label{\detokenize{text/special-features:calculations-on-partial-structures}}
Two methods are available for performing energetic calculations on portions or substructures within a full molecular system. Tinker allows division of the entire system into active and inactive parts which can be defined via keywords. In subsequent calculations, such as minimization or dynamics, only the active portions of the system are allowed to move. The force field engine responds to the active/inactive division by computing all energetic interactions involving at least one active atom; i.e., any interaction whose energy can change with the motion of one or more active atoms is computed.

The second method for partial structure computation involves dividing the original system into a set of atom groups. As before, the groups can be specified via appropriate keywords. The current Tinker implementation allows specification of up to a maximum number of groups as given in the sizes.i dimensioning file. The groups must be disjoint in that no atom can belong to more than one group. Further keywords allow the user to specify which intra\sphinxhyphen{} and intergroup sets of energetic interactions will contribute to the total force field energy. Weights for each set of interactions in the total energy can also be input. A specific energetic interaction is assigned to a particular intra\sphinxhyphen{} or intergroup set if all the atoms involved in the interaction belong to the group (intra\sphinxhyphen{}) or pair of groups (inter\sphinxhyphen{}). Interactions involving atoms from more than two groups are not computed.

Note that the groups method and active/inactive method use different assignment procedures for individual interactions. The active/inactive scheme is intended for situations where only a portion of a system is allowed to move, but the total energy needs to reflect the presence of the remaining inactive portion of the structure. The groups method is intended for use in rigid body calculations, and is needed for certain kinds of free energy perturbation calculations.


\section{Metal Complexes and Hypervalent Species}
\label{\detokenize{text/special-features:metal-complexes-and-hypervalent-species}}
The distribution version of Tinker comes dimensioned for a maximum atomic coordination number of four as needed for standard organic compounds. In order to use Tinker for calculations on species containing higher coordination numbers, simply change the value of the parameter maxval in the master dimensioning file sizes.i and rebuilt the package. Note that this parameter value should not be set larger than necessary since large values can slow the execution of portions of some Tinker programs.

Many molecular mechanics approaches to inorganic and metal structures use an angle bending term which is softer than the usual harmonic bending potential. Tinker implements a Fourier bending term similar to that used by the Landis group’s SHAPES force field. The parameters for specific Fourier angle terms are supplied via the ANGLEF parameter and keyword format. Note that a Fourier term will only be used for a particular angle if a corresponding harmonic angle term is not present in the parameter file.

We previously worked with the Anders Carlsson group at Washington University in St. Louis to add their transition metal ligand field term to Tinker. Support for this additional potential functional form is present in the distributed Tinker source code. We plan to develop energy routines and parameterization around alternative forms for handling transition metals, including the ligand field formulation proposed by Rob Deeth and coworkers.


\section{Neighbor Methods for Nonbonded Terms}
\label{\detokenize{text/special-features:neighbor-methods-for-nonbonded-terms}}
In addition to standard double loop methods, the Method of Lights is available to speed neighbor searching. This method based on taking intersections of sorted atom lists can be much faster for problems where the cutoff distance is significantly smaller than half the maximal cell dimension. The current version of Tinker does not implement the “neighbor list” schemes common to many other simulation packages.


\section{Periodic Boundary Conditions}
\label{\detokenize{text/special-features:periodic-boundary-conditions}}
Both spherical cutoff images or replicates of a cell are supported by all Tinker programs that implement periodic boundary conditions. Whenever the cutoff distance is too large for the minimum image to be the only relevant neighbor (i.e., half the minimum box dimension for orthogonal cells), Tinker will automatically switch from the image formalism to use of replicated cells.


\section{Distance Cutoffs for Energy Functions}
\label{\detokenize{text/special-features:distance-cutoffs-for-energy-functions}}
Polynomial energy switching over a window is used for terms whose energy is small near the cutoff distance. For monopole electrostatic interactions, which are quite large in typical cutoff ranges, a two polynomial multiplicative\sphinxhyphen{}additive shifted energy switch unique to Tinker is applied. The Tinker method is similar in spirit to the force switching methods of Steinbach and Brooks, J. Comput. Chem., 15, 667\sphinxhyphen{}683 (1994). While the particle mesh Ewald method is preferred when periodic boundary conditions are present, Tinker’s shifted energy switch with reasonable switching windows is quite satisfactory for most routine modeling problems. The shifted energy switch minimizes the perturbation of the energy and the gradient at the cutoff to acceptable levels. Problems should arise only if the property you wish to monitor is known to require explicit inclusion of long range components (i.e., calculation of the dielectric constant, etc.).


\section{Ewald Summations Methods}
\label{\detokenize{text/special-features:ewald-summations-methods}}
Tinker contains a versions of the Ewald summation technique for inclusion of long range electrostatic interactions via periodic boundaries. The particle mesh Ewald (PME) method is available for simple charge\sphinxhyphen{}charge potentials, while regular Ewald is provided for polarizable atomic multipole interactions. The accuracy and speed of the regular and PME calculations is dependent on several interrelated parameters. For both methods, the Ewald coefficient and real\sphinxhyphen{}space cutoff distance must be set to reasonable and complementary values. Additional control variables for regular Ewald are the fractional coverage and number of vectors used in reciprocal space. For PME the additional control values are the B\sphinxhyphen{}spline order and charge grid dimensions. Complete control over all of these parameters is available via the Tinker keyfile mechanism. By default Tinker will select a set of parameters which provide a reasonable compromise between accuracy and speed, but these should be checked and modified as necessary for each individual system.


\section{Continuum Solvation Models}
\label{\detokenize{text/special-features:continuum-solvation-models}}
Several alternative continuum solvation algorithms are contained within Tinker. All of these are accessed via the SOLVATE keyword and its modifiers. Two simple surface area methods are implemented: the ASP method of Eisenberg and McLachlan, and the SASA method from Scheraga’s group. These methods are applicable to any of the standard Tinker force fields. Various schemes based on the generalized Born formalism are also available: the original 1990 numerical “Onion\sphinxhyphen{}shell” GB/SA method from Still’s group, the 1997 analytical GB/SA method also due to Still, a pairwise descreening algorithm originally proposed by Hawkins, Cramer and Truhlar, and the analytical continuum solvation (ACE) method of Schaefer and Karplus. At present, the generalized Born methods should only be used with force fields having simple partial charge electrostatic interactions.

Some further comments are in order regarding the GB/SA\sphinxhyphen{}style solvation models. The Onion\sphinxhyphen{}shell model is provided mostly for comparison purposes. It uses an exact, analytical surface area calculation for the cavity term and the numerical scheme described in the original paper for the polarization term. This method is very slow, especially for large systems, and does not contain the contribution of the Born radii chain rule term to the first derivatives. We recommend its use only for single\sphinxhyphen{}point energy calculations. The other GB/SA methods (“analytical” Still, H\sphinxhyphen{}C\sphinxhyphen{}T pairwise descreening, and ACE) use an approximate cavity term based on Born radii, and do contain fully correct derivatives including the Born radii chain rule contribution. These methods all scale in CPU time with the square of the size of the system, and can be used with minimization, molecular dynamics and large molecules.

Finally, we note that the ACE solvation model should not be used with the current version of Tinker. The algorithm is fully implemented in the source code, but parameterization is not complete. As of late 2000, parameter values are only available in the literature for use of ACE with the older CHARMM19 force field. We plan to develop values for use with more modern all\sphinxhyphen{}atom force fields, and these will be incorporated into Tinker sometime in the future.


\section{Polarizable Multipole Electrostatics}
\label{\detokenize{text/special-features:polarizable-multipole-electrostatics}}
Atomic multipole electrostatics through the quadrupole moment is supported by the current version of Tinker, as is either mutual or direct dipole polarization. Ewald summation is available for inclusion of long range interactions. Calculations are implemented via a mixture of the CCP5 algorithms of W. Smith and the Applequist\sphinxhyphen{}Dykstra Cartesian polytensor method. At present analytical energy and Cartesian gradient code is provided.

The Tinker package allows intramolecular polarization to be treated via a version of the interaction damping scheme of Thole. To implement the Thole scheme, it is necessary to set all the mutual\sphinxhyphen{}1x\sphinxhyphen{}scale keywords to a value of one. The other polarization scaling keyword series, direct\sphinxhyphen{}1x\sphinxhyphen{}scale and polar\sphinxhyphen{}1x\sphinxhyphen{}scale, can be set independently to enable a wide variety of polarization models. In order to use an Applequist\sphinxhyphen{}style model without polarization damping, simply set the polar\sphinxhyphen{}damp keyword to zero.


\section{Potential Energy Smoothing}
\label{\detokenize{text/special-features:potential-energy-smoothing}}
Versions of our Potential Smoothing and Search (PSS) methodology have been implemented within Tinker. This methods belong to the same general family as Scheraga’s Diffusion Equation Method, Straub’s Gaussian Density Annealing, Shalloway’s Packet Annealing and Verschelde’s Effective Diffused Potential, but our algorithms reflect our own ongoing research in this area. In many ways the Tinker potential smoothing methods are the deterministic analog of stochastic simulated annealing. The PSS algorithms are very powerful, but are relatively new and are still undergoing modification, testing and calibration within our research group. This version of Tinker also includes a basin\sphinxhyphen{}hopping conformational scanning algorithm in the program SCAN which is particularly effective on smoothed potential surfaces.


\section{Distance Geometry Metrization}
\label{\detokenize{text/special-features:distance-geometry-metrization}}
A much improved and very fast random pairwise metrization scheme is available which allows good sampling during trial distance matrix generation without the usual structural anomalies and CPU constraints of other metrization procedures. An outline of the methodology and its application to NMR NOE\sphinxhyphen{}based structure refinement is described in the paper by Hodsdon, et al. in Journal of Molecular Biology, 264, 585\sphinxhyphen{}602 (1996). We have obtained good results with something like the keyword phrase trial\sphinxhyphen{}distribution pairwise 5, which performs 5\% partial random pairwise metrization. For structures over several hundred atoms, a value less than 5 for the percentage of metrization should be fine.


\chapter{Use of the Keyword Control File}
\label{\detokenize{text/keywords:use-of-the-keyword-control-file}}\label{\detokenize{text/keywords::doc}}

\section{Using Keywords to Control Tinker Calculations}
\label{\detokenize{text/keywords:using-keywords-to-control-tinker-calculations}}
This section contains detailed descriptions of the keyword parameters used to define or alter the course of a Tinker calculation. The keyword control file is optional in the sense that all of the Tinker programs will run in the absence of a keyfile and will simply use default values or query the user for needed information. However, the keywords allow use of a wide variety of algorithmic and procedural options, many of which are unavailable interactively.

Keywords are read from the keyword control file. All programs look first for a keyfile with the same base name as the input molecular system and ending in the extension .key. If this file does not exist, then Tinker tries to use a generic keyfile with the name Tinker.key and located in the same directory as the input system. If neither a system\sphinxhyphen{}specific nor a generic keyfile is present, Tinker will continue by using default values for keyword options and asking interactive questions as necessary.

Tinker searches the keyfile during the course of a calculation for relevant keywords that may be present. All keywords must appear as the first word on the line. Any blank space to the left of the keyword is ignored, and all contents of the keyfiles are case insensitive. Some keywords take modifiers; i.e., Tinker looks further on the same line for additional information, such as the value of some parameter related to the keyword. Modifier information is read in free format, but must be completely contained on the same line as the original keyword. Any lines contained in the keyfile which do not qualify as valid keyword lines are treated as comments and are simply ignored.

Several keywords take a list of integer values (atom numbers, for example) as modifiers. For these keywords the integers can simply be listed explicitly and separated by spaces, commas or tabs. If a range of numbers is desired, it can be specified by listing the negative of the first number of the range, followed by a separator and the last number of the range. For example, the keyword line ACTIVE 4 \sphinxhyphen{}9 17 23 could be used to add atoms 4, 9 through 17, and 23 to the set of active atoms during a Tinker calculation.


\section{Keywords Grouped by Functionality}
\label{\detokenize{text/keywords:keywords-grouped-by-functionality}}
Listed below are the available Tinker keywords sorted into groups by general function. The section ends with an alphabetical list containing each individual keyword, along with a brief description of its action, possible keyword modifiers, and usage examples.


\subsection{OUTPUT CONTROL KEYWORDS}
\label{\detokenize{text/keywords:output-control-keywords}}
ARCHIVE DEBUG   DIGITS
ECHO    EXIT\sphinxhyphen{}PAUSE      NOVERSION
OVERWRITE       PRINTOUT        SAVE\sphinxhyphen{}CYCLE
SAVE\sphinxhyphen{}FORCE      SAVE\sphinxhyphen{}INDUCED    SAVE\sphinxhyphen{}VELOCITY
VERBOSE WRITEOUT


\subsection{FORCE FIELD SELECTION KEYWORDS}
\label{\detokenize{text/keywords:force-field-selection-keywords}}
FORCEFIELD      PARAMETERS


\subsection{POTENTIAL FUNCTION SELECTION KEYWORDS}
\label{\detokenize{text/keywords:potential-function-selection-keywords}}
ANGANGTERM      ANGLETERM       BONDTERM
CHARGETERM      CHGDPLTERM      DIPOLETERM
EXTRATERM       IMPROPTERM      IMPTORSTERM
METALTERM       MPOLETERM       OPBENDTERM
OPDISTTERM      PITORSTERM      POLARIZETERM
RESTRAINTERM    RXNFIELDTERM    SOLVATETERM
STRBNDTERM      STRTORTERM      TORSIONTERM
TORTORTERM      UREYTERM        VDWTERM


\subsection{POTENTIAL FUNCTION PARAMETER KEYWORDS}
\label{\detokenize{text/keywords:potential-function-parameter-keywords}}
ANGANG  ANGLE   ANGLE3
ANGLE4  ANGLE5  ANGLEF
ATOM    BIOTYPE BOND
BOND3   BOND4   BOND5
CHARGE  DIPOLE  DIPOLE3
DIPOLE4 DIPOLE5 ELECTNEG
HBOND   IMPROPER        IMPTORS
METAL   MULTIPOLE       OPBEND
OPDIST  PIATOM  PIBOND
PITORS  POLARIZE        SOLVATE
STRBND  STRTORS TORSION
TORSION4        TORSION5        TORTOR
UREYBRAD        VDW     VDW14
VDWPR


\subsection{ENERGY UNIT CONVERSION KEYWORDS}
\label{\detokenize{text/keywords:energy-unit-conversion-keywords}}
ANGLEUNIT       ANGANGUNIT      BONDUNIT
ELECTRIC        IMPROPUNIT      IMPTORUNIT
OPBENDUNIT      OPDISTUNIT      PITORSUNIT
STRBNDUNIT      STRTORUNIT      TORSIONUNIT
TORTORUNIT      UREYUNIT


\subsection{LOCAL GEOMETRY FUNCTIONAL FORM KEYWORDS}
\label{\detokenize{text/keywords:local-geometry-functional-form-keywords}}
ANGLE\sphinxhyphen{}CUBIC     ANGLE\sphinxhyphen{}QUARTIC   ANGLE\sphinxhyphen{}PENTIC
ANGLE\sphinxhyphen{}SEXTIC    BOND\sphinxhyphen{}CUBIC      BOND\sphinxhyphen{}QUARTIC
BONDTYPE        MM2\sphinxhyphen{}STRBND      PISYSTEM
UREY\sphinxhyphen{}CUBIC      UREY\sphinxhyphen{}QUARTIC


\subsection{VDW \& REPULSION\sphinxhyphen{}DISPERSION FUNCTIONAL FORM KEYWORDS}
\label{\detokenize{text/keywords:vdw-repulsion-dispersion-functional-form-keywords}}
A\sphinxhyphen{}EXPTERM       B\sphinxhyphen{}EXPTERM       C\sphinxhyphen{}EXPTERM
DELTA\sphinxhyphen{}HALGREN   DISP\sphinxhyphen{}12\sphinxhyphen{}SCALE   DISP\sphinxhyphen{}13\sphinxhyphen{}SCALE
DISP\sphinxhyphen{}14\sphinxhyphen{}SCALE   DISP\sphinxhyphen{}15\sphinxhyphen{}SCALE   EPSILONRULE
GAMMA\sphinxhyphen{}HALGREN   GAUSSTYPE       RADIUSRULE
RADIUSSIZE      RADIUSTYPE      VDW\sphinxhyphen{}12\sphinxhyphen{}SCALE
VDW\sphinxhyphen{}13\sphinxhyphen{}SCALE    VDW\sphinxhyphen{}14\sphinxhyphen{}SCALE    VDW\sphinxhyphen{}15\sphinxhyphen{}SCALE
VDW\sphinxhyphen{}CORRECTION  VDWINDEX        VDWTYPE


\subsection{ELECTROSTATICS FUNCTIONAL FORM KEYWORDS}
\label{\detokenize{text/keywords:electrostatics-functional-form-keywords}}
CHG\sphinxhyphen{}12\sphinxhyphen{}SCALE    CHG\sphinxhyphen{}13\sphinxhyphen{}SCALE    CHG\sphinxhyphen{}14\sphinxhyphen{}SCALE
CHG\sphinxhyphen{}15\sphinxhyphen{}SCALE    CHG\sphinxhyphen{}BUFFER      DIELECTRIC
DIRECT\sphinxhyphen{}11\sphinxhyphen{}SCALE DIRECT\sphinxhyphen{}12\sphinxhyphen{}SCALE DIRECT\sphinxhyphen{}13\sphinxhyphen{}SCALE
DIRECT\sphinxhyphen{}14\sphinxhyphen{}SCALE MPOLE\sphinxhyphen{}12\sphinxhyphen{}SCALE  MPOLE\sphinxhyphen{}13\sphinxhyphen{}SCALE
MPOLE\sphinxhyphen{}14\sphinxhyphen{}SCALE  MPOLE\sphinxhyphen{}15\sphinxhyphen{}SCALE  MUTUAL\sphinxhyphen{}11\sphinxhyphen{}SCALE
MUTUAL\sphinxhyphen{}12\sphinxhyphen{}SCALE MUTUAL\sphinxhyphen{}13\sphinxhyphen{}SCALE MUTUAL\sphinxhyphen{}14\sphinxhyphen{}SCALE
POLAR\sphinxhyphen{}12\sphinxhyphen{}SCALE  POLAR\sphinxhyphen{}13\sphinxhyphen{}SCALE  POLAR\sphinxhyphen{}14\sphinxhyphen{}SCALE
POLAR\sphinxhyphen{}15\sphinxhyphen{}SCALE  POLAR\sphinxhyphen{}ASPC      POLAR\sphinxhyphen{}EPS
POLAR\sphinxhyphen{}SOR       POLARIZATION    REACTIONFIELD


\subsection{NONBONDED CUTOFF KEYWORDS}
\label{\detokenize{text/keywords:nonbonded-cutoff-keywords}}
CHG\sphinxhyphen{}CUTOFF      CHG\sphinxhyphen{}TAPER       CUTOFF
DPL\sphinxhyphen{}CUTOFF      DPL\sphinxhyphen{}TAPER       HESS\sphinxhyphen{}CUTOFF
LIGHTS  MPOLE\sphinxhyphen{}CUTOFF    MPOLE\sphinxhyphen{}TAPER
NEIGHBOR\sphinxhyphen{}GROUPS NEUTRAL\sphinxhyphen{}GROUPS  POLYMER\sphinxhyphen{}CUTOFF
TAPER   TRUNCATE        VDW\sphinxhyphen{}CUTOFF
VDW\sphinxhyphen{}TAPER


\subsection{EWALD SUMMATION KEYWORDS}
\label{\detokenize{text/keywords:ewald-summation-keywords}}
DPME\sphinxhyphen{}GRID       DPME\sphinxhyphen{}ORDER      EWALD
EWALD\sphinxhyphen{}ALPHA     EWALD\sphinxhyphen{}BOUNDARY  EWALD\sphinxhyphen{}CUTOFF
PME\sphinxhyphen{}GRID        PME\sphinxhyphen{}ORDER       PPME\sphinxhyphen{}ORDER


\subsection{CRYSTAL LATTICE \& PERIODIC BOUNDARY KEYWORDS}
\label{\detokenize{text/keywords:crystal-lattice-periodic-boundary-keywords}}
A\sphinxhyphen{}AXIS  B\sphinxhyphen{}AXIS  C\sphinxhyphen{}AXIS
ALPHA   BETA    GAMMA
NO\sphinxhyphen{}SYMMETRY     OCTAHEDRON      SPACEGROUP
X\sphinxhyphen{}AXIS  Y\sphinxhyphen{}AXIS  Z\sphinxhyphen{}AXIS


\subsection{NEIGHBOR LIST KEYWORDS}
\label{\detokenize{text/keywords:neighbor-list-keywords}}
CHG\sphinxhyphen{}LIST        LIST\sphinxhyphen{}BUFFER     MPOLE\sphinxhyphen{}LIST
NEIGHBOR\sphinxhyphen{}LIST   VDW\sphinxhyphen{}LIST


\subsection{OPTIMIZATION KEYWORDS}
\label{\detokenize{text/keywords:optimization-keywords}}
ANGMAX  CAPPA   FCTMIN
HGUESS  INTMAX  LBFGS\sphinxhyphen{}VECTORS
MAXITER NEWHESS NEXTITER
SLOPEMAX        STEEPEST\sphinxhyphen{}DESCENT        STEPMAX
STEPMIN


\subsection{MOLECULAR DYNAMICS KEYWORDS}
\label{\detokenize{text/keywords:molecular-dynamics-keywords}}
BEEMAN\sphinxhyphen{}MIXING   DEGREES\sphinxhyphen{}FREEDOM INTEGRATOR
REMOVE\sphinxhyphen{}INERTIA


\subsection{THERMOSTAT \& BAROSTAT KEYWORDS}
\label{\detokenize{text/keywords:thermostat-barostat-keywords}}
ANISO\sphinxhyphen{}PRESSURE  BAROSTAT        COLLISION
COMPRESS        FRICTION        FRICTION\sphinxhyphen{}SCALING
TAU\sphinxhyphen{}PRESSURE    TAU\sphinxhyphen{}TEMPERATURE THERMOSTAT
VOLUME\sphinxhyphen{}MOVE     VOLUME\sphinxhyphen{}SCALE    VOLUME\sphinxhyphen{}TRIAL


\subsection{TRANSITION STATE KEYWORDS}
\label{\detokenize{text/keywords:transition-state-keywords}}
DIVERGE GAMMAMIN        REDUCE
SADDLEPOINT


\subsection{DISTANCE GEOMETRY KEYWORDS}
\label{\detokenize{text/keywords:distance-geometry-keywords}}
TRIAL\sphinxhyphen{}DISTANCE  TRIAL\sphinxhyphen{}DISTRIBUTION


\subsection{VIBRATIONAL ANALYSIS KEYWORDS}
\label{\detokenize{text/keywords:vibrational-analysis-keywords}}
IDUMP   VIB\sphinxhyphen{}ROOTS       VIB\sphinxhyphen{}TOLERANCE


\subsection{IMPLICIT SOLVATION KEYWORDS}
\label{\detokenize{text/keywords:implicit-solvation-keywords}}
BORN\sphinxhyphen{}RADIUS     GK\sphinxhyphen{}RADIUS       GKC
GKR     SOLVENT\sphinxhyphen{}PRESSURE        SURFACE\sphinxhyphen{}TENSION


\subsection{POISSON\sphinxhyphen{}BOLTZMANN KEYWORDS}
\label{\detokenize{text/keywords:poisson-boltzmann-keywords}}
AGRID   APBS\sphinxhyphen{}GRID       BCFL
CGCENT  CGRID   FGCENT
FGRID   ION     MG\sphinxhyphen{}AUTO
MG\sphinxhyphen{}MANUAL       PB\sphinxhyphen{}RADIUS       PDIE
SDENS   SDIE    SMIN
SRAD    SRFM    SWIN


\subsection{MATHEMATICAL ALGORITHM KEYWORDS}
\label{\detokenize{text/keywords:mathematical-algorithm-keywords}}
FFT\sphinxhyphen{}PACKAGE     RANDOMSEED


\subsection{PARALLELIZATION KEYWORDS}
\label{\detokenize{text/keywords:parallelization-keywords}}
OPENMP\sphinxhyphen{}THREADS


\subsection{FREE ENERGY PERTURBATION KEYWORDS}
\label{\detokenize{text/keywords:free-energy-perturbation-keywords}}
CHG\sphinxhyphen{}LAMBDA      DPL\sphinxhyphen{}LAMBDA      LAMBDA
LIGAND  MPOLE\sphinxhyphen{}LAMBDA    MUTATE
POLAR\sphinxhyphen{}LAMBDA    VDW\sphinxhyphen{}ANNIHILATE  VDW\sphinxhyphen{}LAMBDA


\subsection{PARTIAL STRUCTURE KEYWORDS}
\label{\detokenize{text/keywords:partial-structure-keywords}}
ACTIVE  GROUP   GROUP\sphinxhyphen{}INTER
GROUP\sphinxhyphen{}INTRA     GROUP\sphinxhyphen{}MOLECULE  GROUP\sphinxhyphen{}SELECT
INACTIVE


\subsection{CONSTRAINT \& RESTRAINT KEYWORDS}
\label{\detokenize{text/keywords:constraint-restraint-keywords}}
BASIN   ENFORCE\sphinxhyphen{}CHIRALITY       RATTLE
RATTLE\sphinxhyphen{}DISTANCE RATTLE\sphinxhyphen{}EPS      RATTLE\sphinxhyphen{}LINE
RATTLE\sphinxhyphen{}ORIGIN   RATTLE\sphinxhyphen{}PLANE    RESTRAIN\sphinxhyphen{}ANGLE
RESTRAIN\sphinxhyphen{}DISTANCE       RESTRAIN\sphinxhyphen{}GROUPS RESTRAIN\sphinxhyphen{}POSITION
RESTRAIN\sphinxhyphen{}TORSION        SPHERE  WALL


\subsection{PARAMETER FITTING KEYWORDS}
\label{\detokenize{text/keywords:parameter-fitting-keywords}}
FIT\sphinxhyphen{}ANGLE       FIT\sphinxhyphen{}BOND        FIT\sphinxhyphen{}OPBEND
FIT\sphinxhyphen{}STRBND      FIT\sphinxhyphen{}TORSION     FIT\sphinxhyphen{}UREY
FIX\sphinxhyphen{}ANGLE       FIX\sphinxhyphen{}BOND        FIX\sphinxhyphen{}DIPOLE
FIX\sphinxhyphen{}MONOPOLE    FIX\sphinxhyphen{}OPBEND      FIX\sphinxhyphen{}QUADRUPOLE
FIX\sphinxhyphen{}STRBND      FIX\sphinxhyphen{}TORSION     FIX\sphinxhyphen{}UREY
POTENTIAL\sphinxhyphen{}ATOMS POTENTIAL\sphinxhyphen{}FIT   POTENTIAL\sphinxhyphen{}OFFSET
POTENTIAL\sphinxhyphen{}SHELLS        POTENTIAL\sphinxhyphen{}SPACING       RESP\sphinxhyphen{}WEIGHT
RESPTYPE        TARGET\sphinxhyphen{}DIPOLE   TARGET\sphinxhyphen{}QUADRUPOLE


\subsection{POTENTIAL SMOOTHING KEYWORDS}
\label{\detokenize{text/keywords:potential-smoothing-keywords}}
DEFORM  DIFFUSE\sphinxhyphen{}CHARGE  DIFFUSE\sphinxhyphen{}TORSION
DIFFUSE\sphinxhyphen{}VDW     SMOOTHING


\section{Description of Individual Keywords}
\label{\detokenize{text/keywords:description-of-individual-keywords}}
The following is an alphabetical list of the Tinker keywords along with a brief description of the action of each keyword and required or optional parameters that can be used to extend or modify each keyword. The format of possible modifiers, if any, is shown in brackets following each keyword.

\sphinxstylestrong{A\sphinxhyphen{}AXIS {[}real{]}}  Sets the value of the a\sphinxhyphen{}axis length for a crystal unit cell, or, equivalently, the X\sphinxhyphen{}axis length for a periodic box. The length value in Angstroms is listed after the keyword. Equivalent to the X\sphinxhyphen{}AXIS keyword.

\sphinxstylestrong{A\sphinxhyphen{}EXPTERM {[}real{]}}  Sets the value of the “A” premultiplier term in the Buckingham van der Waals function, i.e., the value of A in the formula Evdw = epsilon * \{ A exp{[}\sphinxhyphen{}B(Ro/R){]} \sphinxhyphen{} C (Ro/R)6 \}.

\sphinxstylestrong{ACTIVE {[}integer list{]}}  Sets the list of active atoms during a Tinker computation. Individual potential energy terms are computed when at least one atom involved in the term is active. For Cartesian space calculations, active atoms are those allowed to move. For torsional space calculations, rotations are allowed when all atoms on one side of the rotated bond are active. Multiple ACTIVE lines can be present in the keyfile and are treated cumulatively.  On each line the keyword can be followed by one or more atom numbers or atom ranges. The presence of any ACTIVE keyword overrides any INACTIVE keywords in the keyfile.

\sphinxstylestrong{ACTIVE\sphinxhyphen{}SPHERE {[}4 reals, or 1 integer \& 1 real{]}}  Provides an alternative to the ACTIVE and INACTIVE keywords for specification of subsets of active atoms. If four real number modifiers are provided, the first three are taken as X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}coordinates and the fourth is the radius of a sphere centered at these coordinates. In this case, all atoms within the sphere at the start of the calculation are active throughout the calculation, while all other atoms are inactive. Similarly if one integer and real number are given, an “active” sphere with radius set by the real is centered on the system atom with atom number given by the integer modifier. Multiple SPHERE keyword lines can be present in a single keyfile, and the list of active atoms specified by the spheres is cumulative.

\sphinxstylestrong{AGRID {[}3 reals{]}}  Sets grid dimensions along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes which are passed on to the Tinker APBS interface for use in Poisson\sphinxhyphen{}Boltzmann calculations.

\sphinxstylestrong{ALPHA {[}real{]}}  Sets the value of the alpha angle of a crystal unit cell, i.e., the angle between the b\sphinxhyphen{}axis and c\sphinxhyphen{}axis of a unit cell, or, equivalently, the angle between the Y\sphinxhyphen{}axis and Z\sphinxhyphen{}axis of a periodic box. The default value in the absence of the ALPHA keyword is 90 degrees.

\sphinxstylestrong{ANGANG {[}1 integer \& 3 reals{]}}  Provides the values for a single angle\sphinxhyphen{}angle cross term potential parameter.

\sphinxstylestrong{ANGANGTERM {[}NONE/ONLY{]}}  Controls use of the angle\sphinxhyphen{}angle cross term potential energy. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{ANGANGUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the angle\sphinxhyphen{}angle cross term potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default of (Pi/180)\textasciicircum{}2 = 0.0003046 is used, if the ANGANGUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{ANGCFLUX {[}3 integers \& 4 reals{]}}

\sphinxstylestrong{ANGLE {[}3 integers \& 4 reals{]}}  Provides the values for a single bond angle bending parameter. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant value for the angle and up to three ideal bond angles in degrees. In most cases only one ideal bond angle is given, and that value is used for all occurrences of the specified bond angle. If all three ideal angles are given, the values apply when the central atom of the angle is attached to 0, 1 or 2 additional hydrogen atoms, respectively. This “hydrogen environment” option is provided to implement the corresponding feature of Allinger’s MM force fields. The default units for the force constant are kcal/mole/radian2, but this can be controlled via the ANGLEUNIT keyword.

\sphinxstylestrong{ANGLE\sphinxhyphen{}CUBIC {[}real{]}}  Sets the value of the cubic term in the Taylor series expansion form of the bond angle bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the angle bending energy unit conversion factor, the force constant, and the cube of the deviation of the bond angle from its ideal value gives the cubic contribution to the angle bending energy. The default value in the absence of the ANGLE\sphinxhyphen{}CUBIC keyword is zero; i.e., the cubic angle bending term is omitted.

\sphinxstylestrong{ANGLE\sphinxhyphen{}PENTIC {[}real{]}}  Sets the value of the fifth power term in the Taylor series expansion form of the bond angle bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the angle bending energy unit conversion factor, the force constant, and the fifth power of the deviation of the bond angle from its ideal value gives the pentic contribution to the angle bending energy. The default value in the absence of the ANGLE\sphinxhyphen{}PENTIC keyword is zero; i.e., the pentic angle bending term is omitted.

\sphinxstylestrong{ANGLE\sphinxhyphen{}QUARTIC {[}real{]}}  Sets the value of the quartic term in the Taylor series expansion form of the bond angle bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the angle bending energy unit conversion factor, the force constant, and the forth power of the deviation of the bond angle from its ideal value gives the quartic contribution to the angle bending energy. The default value in the absence of the ANGLE\sphinxhyphen{}QUARTIC keyword is zero; i.e., the quartic angle bending term is omitted.

\sphinxstylestrong{ANGLE\sphinxhyphen{}SEXTIC {[}real{]}}  Sets the value of the sixth power term in the Taylor series expansion form of the bond angle bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the angle bending energy unit conversion factor, the force constant, and the sixth power of the deviation of the bond angle from its ideal value gives the sextic contribution to the angle bending energy. The default value in the absence of the ANGLE\sphinxhyphen{}SEXTIC keyword is zero; i.e., the sextic angle bending term is omitted.

\sphinxstylestrong{ANGLE3 {[}3 integers \& 4 reals{]}}  Provides the values for a single bond angle bending parameter specific to atoms in 3\sphinxhyphen{}membered rings. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant value for the angle and up to three ideal bond angles in degrees. If all three ideal angles are given, the values apply when the central atom of the angle is attached to 0, 1 or 2 additional hydrogen atoms, respectively. The default units for the force constant are kcal/mole/radian\textasciicircum{}2, but this can be controlled via the ANGLEUNIT keyword. If any ANGLE3 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special ANGLE3 parameters be given for all angles in 3\sphinxhyphen{}membered rings. In the absence of any ANGLE3 keywords, standard ANGLE parameters will be used for bonds in 3\sphinxhyphen{}membered rings.

\sphinxstylestrong{ANGLE4 {[}3 integers \& 4 reals{]}}  Provides the values for a single bond angle bending parameter specific to atoms in 4\sphinxhyphen{}membered rings. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant value for the angle and up to three ideal bond angles in degrees. If all three ideal angles are given, the values apply when the central atom of the angle is attached to 0, 1 or 2 additional hydrogen atoms, respectively. The default units for the force constant are kcal/mole/radian\textasciicircum{}2, but this can be controlled via the ANGLEUNIT keyword. If any ANGLE4 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special ANGLE4 parameters be given for all angles in 4\sphinxhyphen{}membered rings. In the absence of any ANGLE4 keywords, standard ANGLE parameters will be used for bonds in 4\sphinxhyphen{}membered rings.

\sphinxstylestrong{ANGLE5 {[}3 integers \& 4 reals{]}}  Provides the values for a single bond angle bending parameter specific to atoms in 5\sphinxhyphen{}membered rings. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant value for the angle and up to three ideal bond angles in degrees. If all three ideal angles are given, the values apply when the central atom of the angle is attached to 0, 1 or 2 additional hydrogen atoms, respectively. The default units for the force constant are kcal/mole/radian\textasciicircum{}2, but this can be controlled via the ANGLEUNIT keyword. If any ANGLE5 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special ANGLE5 parameters be given for all angles in 5\sphinxhyphen{}membered rings. In the absence of any ANGLE5 keywords, standard ANGLE parameters will be used for bonds in 5\sphinxhyphen{}membered rings.

\sphinxstylestrong{ANGLEF {[}3 integers \& 3 reals{]}}  Provides the values for a single bond angle bending parameter for a SHAPES\sphinxhyphen{}style Fourier potential function. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant value for the angle, the angle shift in degrees, and the periodicity value. Note that the force constant should be given as the “harmonic” value and not the native Fourier value. The default units for the force constant are kcal/mole/radian\textasciicircum{}2, but this can be controlled via the ANGLEUNIT keyword.

\sphinxstylestrong{ANGLEP} {[}3 integers \& 3 reals{]}**  Provides the values for a single projected in\sphinxhyphen{}plane bond angle bending parameter. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant value for the angle and up to two ideal bond angles in degrees. In most cases only one ideal bond angle is given, and that value is used for all occurrences of the specified bond angle. If all two ideal angles are given, the values apply when the central atom of the angle is attached to 0 or 1 additional hydrogen atoms, respectively. This “hydrogen environment” option is provided to implement the corresponding feature of Allinger’s MM force fields. The default units for the force constant are kcal/mole/radian2, but this can be controlled via the ANGLEUNIT keyword.

\sphinxstylestrong{ANGLETERM {[}NONE/ONLY{]}}  Controls use of the bond angle bending potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{ANGLEUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the bond angle bending potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of (Pi/180)\textasciicircum{}2 = 0.0003046 is used, if the ANGLEUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{ANGMAX {[}real{]}}  Set the maximum permissible angle between the current optimization search direction and the negative of the gradient direction. If this maximum angle value is exceeded, the optimization routine will note an error condition and may restart from the steepest descent direction. The default value in the absence of the ANGMAX keyword is usually 88 degrees for conjugate gradient methods and 180 degrees (i.e., ANGMAX is disabled) for variable metric optimizations.

\sphinxstylestrong{ANGTORS}

\sphinxstylestrong{ANGTORTERM}

\sphinxstylestrong{ANGTORUNIT}

\sphinxstylestrong{ANISO\sphinxhyphen{}PRESSURE}  Invokes use of full anisotropic pressure during dynamics simulations. When using this option, the three axis lengths and axis angles vary separately in response to the pressure tensor. The default, in the absence of the keyword, is isotropic pressure based on the average of the diagonal of the pressure tensor.

\sphinxstylestrong{APBS\sphinxhyphen{}GRID}

\sphinxstylestrong{ATOM {[}2 integers, name, quoted string, integer, real \& integer{]}}  Provides the values needed to define a single force field atom type.

\sphinxstylestrong{AUX\sphinxhyphen{}TAUTEMP}

\sphinxstylestrong{AUX\sphinxhyphen{}TEMP}

\sphinxstylestrong{B\sphinxhyphen{}AXIS {[}real{]}}  Sets the value of the b\sphinxhyphen{}axis length for a crystal unit cell, or, equivalently,  the Y\sphinxhyphen{}axis length for a periodic box. The length value in Angstroms is listed after the keyword. If the keyword is absent, the b\sphinxhyphen{}axis length is set equal to the a\sphinxhyphen{}axis length. Equivalent to the Y\sphinxhyphen{}AXIS keyword.

\sphinxstylestrong{B\sphinxhyphen{}EXPTERM {[}real{]}}  Sets the value of the “B” exponential factor in the Buckingham van der Waals function, i.e., the value of B in the formula Evdw = epsilon * \{ A exp{[}\sphinxhyphen{}B(Ro/R){]} \sphinxhyphen{} C (Ro/R)6 \}.

\sphinxstylestrong{BAROSTAT {[}BERENDSEN{]}}  Selects a barostat algorithm for use during molecular dynamics. At present only one modifier is available, a Berendsen bath coupling method. The default in the absence of the BAROSTAT keyword is to use the BERENDSEN algorithm.

\sphinxstylestrong{BASIN {[}2 reals{]}}  Presence of this keyword turns on a “basin” restraint potential function that serves to drive the system toward a compact structure. The actual function is a Gaussian of the form Ebasin = epsilon * A exp{[}\sphinxhyphen{}B R\textasciicircum{}2{]}, summed over all pairs of atoms where R is the distance between atoms. The A and B values are the depth and width parameters given as modifiers to the BASIN keyword. This potential is currently used to control the degree of expansion during potential energy smooth procedures through the use of shallow, broad basins.

\sphinxstylestrong{BCFL}

\sphinxstylestrong{BEEMAN\sphinxhyphen{}MIXING}

\sphinxstylestrong{BETA {[}real{]}}  Sets the value of the ? angle of a crystal unit cell, i.e., the angle between the a\sphinxhyphen{}axis and c\sphinxhyphen{}axis of a unit cell, or, equivalently, the angle between the X\sphinxhyphen{}axis and Z\sphinxhyphen{}axis of a periodic box. The default value in the absence of the BETA keyword is to set the beta angle equal to the alpha angle as given by the keyword ALPHA.

\sphinxstylestrong{BIOTYPE {[}integer, name, quoted string \& integer{]}}  Provides the values to define the correspondence between a single biopolymer atom type and its force field atom type.

\sphinxstylestrong{BOND {[}2 integers \& 2 reals{]}}  Provides the values for a single bond stretching parameter. The integer modifiers give the atom class numbers for the two kinds of atoms involved in the bond which is to be defined. The real number modifiers give the force constant value for the bond and the ideal bond length in Angstroms. The default units for the force constant are kcal/mole/Ang\textasciicircum{}2, but this can be controlled via the BONDUNIT keyword.

\sphinxstylestrong{BOND\sphinxhyphen{}CUBIC {[}real{]}}  Sets the value of the cubic term in the Taylor series expansion form of the bond stretching potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the bond stretching energy unit conversion factor, the force constant, and the cube of the deviation of the bond length from its ideal value gives the cubic contribution to the bond stretching energy. The default value in the absence of the BOND\sphinxhyphen{}CUBIC keyword is zero; i.e., the cubic bond stretching term is omitted.

\sphinxstylestrong{BOND\sphinxhyphen{}QUARTIC {[}real{]}}  Sets the value of the quartic term in the Taylor series expansion form of the bond stretching potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the bond stretching energy unit conversion factor, the force constant, and the forth power of the deviation of the bond length from its ideal value gives the quartic contribution to the bond stretching energy. The default value in the absence of the BOND\sphinxhyphen{}QUARTIC keyword is zero; i.e., the quartic bond stretching term is omitted.

\sphinxstylestrong{BOND3 {[}2 integers \& 2 reals{]}}  Provides the values for a single bond stretching parameter specific to atoms in 3\sphinxhyphen{}membered rings. The integer modifiers give the atom class numbers for the two kinds of atoms involved in the bond which is to be defined. The real number modifiers give the force constant value for the bond and the ideal bond length in Angstroms. The default units for the force constant are kcal/mole/Ang\textasciicircum{}2, but this can be controlled via the BONDUNIT keyword. If any BOND3 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special BOND3 parameters be given for all bonds in 3\sphinxhyphen{}membered rings. In the absence of any BOND3 keywords, standard BOND parameters will be used for bonds in 3\sphinxhyphen{}membered rings.

\sphinxstylestrong{BOND4 {[}2 integers \& 2 reals{]}}  Provides the values for a single bond stretching parameter specific to atoms in 4\sphinxhyphen{}membered rings. The integer modifiers give the atom class numbers for the two kinds of atoms involved in the bond which is to be defined. The real number modifiers give the force constant value for the bond and the ideal bond length in Angstroms. The default units for the force constant are kcal/mole/Ang\textasciicircum{}2, but this can be controlled via the BONDUNIT keyword. If any BOND4 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special BOND4 parameters be given for all bonds in 4\sphinxhyphen{}membered rings. In the absence of any BOND4 keywords, standard BOND parameters will be used for bonds in 4\sphinxhyphen{}membered rings

\sphinxstylestrong{BOND5 {[}2 integers \& 2 reals{]}}  Provides the values for a single bond stretching parameter specific to atoms in 5\sphinxhyphen{}membered rings. The integer modifiers give the atom class numbers for the two kinds of atoms involved in the bond which is to be defined. The real number modifiers give the force constant value for the bond and the ideal bond length in Angstroms. The default units for the force constant are kcal/mole/Ang\textasciicircum{}2, but this can be controlled via the BONDUNIT keyword. If any BOND5 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special BOND5 parameters be given for all bonds in 5\sphinxhyphen{}membered rings. In the absence of any BOND5 keywords, standard BOND parameters will be used for bonds in 5\sphinxhyphen{}membered rings

\sphinxstylestrong{BONDTERM {[}NONE/ONLY{]}}  Controls use of the bond stretching potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{BONDTYPE {[}HARMONIC/MORSE{]}}  Chooses the functional form of the bond stretching potential. The HARMONIC option selects a Taylor series expansion containing terms from harmonic through quartic. The MORSE option selects a Morse potential fit to the ideal bond length and stretching force constant parameter values. The default is to use the HARMONIC potential.

\sphinxstylestrong{BONDUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the bond stretching potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the BONDUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{BORN\sphinxhyphen{}RADIUS}

\sphinxstylestrong{C\sphinxhyphen{}AXIS {[}real{]}}  Sets the value of the C\sphinxhyphen{}axis length for a crystal unit cell, or, equivalently, the Z\sphinxhyphen{}axis length for a periodic box. The length value in Angstroms is listed after the keyword. If the keyword is absent, the C\sphinxhyphen{}axis length is set equal to the A\sphinxhyphen{}axis length. Equivalent to the Z\sphinxhyphen{}AXIS keyword.

\sphinxstylestrong{C\sphinxhyphen{}EXPTERM {[}real{]}}  Sets the value of the “C” dispersion multiplier in the Buckingham van der Waals function, i.e., the value of C in the formula Evdw = epsilon * \{ A exp{[}\sphinxhyphen{}B(Ro/R){]} \sphinxhyphen{} C (Ro/R)6 \}.

\sphinxstylestrong{CAPPA {[}real{]}}  Sets the normal termination criterion for the line search phase of Tinker optimization routines. The line search exits successfully if the ratio of the current gradient projection on the line to the projection at the start of the line search falls below the value of CAPPA. A default value of 0.1 is used in the absence of the CAPPA keyword.

\sphinxstylestrong{CGCENT {[}3 reals{]}}  Sets grid dimensions along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes which are passed on to the Tinker APBS interface for use in Poisson\sphinxhyphen{}Boltzmann calculations.

\sphinxstylestrong{CGRID {[}3 reals{]}}  Sets grid dimensions along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes which are passed on to the Tinker APBS interface for use in Poisson\sphinxhyphen{}Boltzmann calculations.

\sphinxstylestrong{CHARGE {[}1 integer \& 1 real{]}}  Provides a value for a single atomic partial charge electrostatic parameter. The integer modifier, if positive, gives the atom type number for which the charge parameter is to be defined. Note that charge parameters are given for atom types, not atom classes. If the integer modifier is negative, then the parameter value to follow applies only to the individual atom whose atom number is the negative of the modifier. The real number modifier gives the values of the atomic partial charge in electrons.

\sphinxstylestrong{CHARGE\sphinxhyphen{}CUTOFF {[}real{]}}  Sets the cutoff distance value in Angstroms for charge\sphinxhyphen{}charge electrostatic potential energy interactions. The energy for any pair of sites beyond the cutoff distance will be set to zero. Other keywords can be used to select a smoothing scheme near the cutoff distance. The default cutoff distance in the absence of the CHG\sphinxhyphen{}CUTOFF keyword is infinite for nonperiodic systems and 9.0 for periodic systems.

\sphinxstylestrong{CHARGE\sphinxhyphen{}LIST}

\sphinxstylestrong{CHARGE\sphinxhyphen{}TAPER {[}real{]}}  Modifies the cutoff window for charge\sphinxhyphen{}charge electrostatic potential energy interactions. It is similar in form and action to the TAPER keyword, except that its value applies only to the charge\sphinxhyphen{}charge potential. The default value in the absence of the CHG\sphinxhyphen{}TAPER keyword is to begin the cutoff window at 0.65 of the corresponding cutoff distance.

\sphinxstylestrong{CHARGETERM {[}NONE/ONLY{]}}  Controls use of the charge\sphinxhyphen{}charge potential energy term between pairs of atomic partial charges. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{CHARGETRANSFER}

\sphinxstylestrong{CHG\sphinxhyphen{}11\sphinxhyphen{}SCALE}

\sphinxstylestrong{CHG\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to charge\sphinxhyphen{}charge electrostatic interactions between 1\sphinxhyphen{}2 connected atoms, i.e., atoms that are directly bonded. The default value of 0.0 is used, if the CHG\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{CHG\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to charge\sphinxhyphen{}charge electrostatic interactions between 1\sphinxhyphen{}3 connected atoms, i.e., atoms separated by two covalent bonds. The default value of 0.0 is used, if the CHG\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{CHG\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to charge\sphinxhyphen{}charge electrostatic interactions between 1\sphinxhyphen{}4 connected atoms, i.e., atoms separated by three covalent bonds. The default value of 1.0 is used, if the CHG\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{CHG\sphinxhyphen{}15\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to charge\sphinxhyphen{}charge electrostatic interactions between 1\sphinxhyphen{}5 connected atoms, i.e., atoms separated by four covalent bonds. The default value of 1.0 is used, if the CHG\sphinxhyphen{}15\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{CHG\sphinxhyphen{}BUFFER}

\sphinxstylestrong{CHGDPLTERM {[}NONE/ONLY{]}}  Controls use of the charge\sphinxhyphen{}dipole potential energy term between atomic partial charges and bond dipoles. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{CHGPEN}

\sphinxstylestrong{CHGTRN}

\sphinxstylestrong{CHGTRN\sphinxhyphen{}CUTOFF}

\sphinxstylestrong{CHGTRN\sphinxhyphen{}TAPER}

\sphinxstylestrong{CHGTRNTERM}

\sphinxstylestrong{COLLISION {[}real{]}}  Sets the value of the random collision frequency used in the Andersen stochastic collision dynamics thermostat. The supplied value has units of fs\sphinxhyphen{}1 atom\sphinxhyphen{}1 and is multiplied internal to Tinker by the time step in fs and N\textasciicircum{}2/3 where N is the number of atoms. The default value used in the absence of the COLLISION keyword is 0.1 which is appropriate for many systems but may need adjustment to achieve adequate temperature control without perturbing the dynamics.

\sphinxstylestrong{COMPRESS {[}real{]}}  Sets the value of the bulk solvent isothermal compressibility in 1/Atm for use during pressure computation and scaling in molecular dynamics computations. The default value used in the absence of the COMPRESS keyword is 0.000046, appropriate for water. This parameter serves as a scale factor for the Groningen\sphinxhyphen{}style pressure bath coupling time, and its exact value should not be of critical importance.

\sphinxstylestrong{CUTOFF {[}real{]}}  Sets the cutoff distance value for all nonbonded potential energy interactions. The energy for any of the nonbonded potentials of a pair of sites beyond the cutoff distance will be set to zero. Other keywords can be used to select a smoothing scheme near the cutoff distance, or to apply different cutoff distances to various nonbonded energy terms.

\sphinxstylestrong{D\sphinxhyphen{}EQUALS\sphinxhyphen{}P}

\sphinxstylestrong{DEBUG}  Turns on printing of detailed information and intermediate values throughout the progress of a Tinker computation; not recommended for use with large structures or full potential energy functions since a summary of every individual interaction will usually be output.

\sphinxstylestrong{DEFORM {[}real{]}}  Sets the amount of diffusion equation\sphinxhyphen{}style smoothing that will be applied to the potential energy surface when using the SMOOTH force field. The real number option is equivalent to the “time” value in the original Piela, et al. formalism; the larger the value, the greater the smoothing. The default value is zero, meaning that no smoothing will be applied.

\sphinxstylestrong{DEGREES\sphinxhyphen{}FREEDOM {[}integer{]}}  Sets the number of degrees of freedom during a dynamics calculation. The integer modifier is used by thermostating methods and in other places as the number of degrees of freedom, overriding the value determined by the Tinker code at dynamics startup. In the absence of the keyword, the programs will automatically compute the correct value based on the number of atoms active during dynamics, bond or other constrains, and use of periodic boundary conditions.

\sphinxstylestrong{DELTA\sphinxhyphen{}HALGREN {[}real{]}}  Sets the value of the delta parameter in Halgren’s buffered 14\sphinxhyphen{}7 vdw potential energy functional form. In the absence of the DELTA\sphinxhyphen{}HALGREN keyword, a default value of 0.07 is used.

\sphinxstylestrong{DEWALD}

\sphinxstylestrong{DEWALD\sphinxhyphen{}ALPHA}

\sphinxstylestrong{DEWALD\sphinxhyphen{}CUTOFF}

\sphinxstylestrong{DIELECTRIC {[}real{]}}  Sets the value of the bulk dielectric constant used to damp all electrostatic interaction energies for any of the Tinker electrostatic potential functions. The default value is force field dependent, but is usually equal to 1.0 (for Allinger’s MM force fields the default is 1.5).

\sphinxstylestrong{DIELECTRIC\sphinxhyphen{}OFFSET}

\sphinxstylestrong{DIFFUSE\sphinxhyphen{}CHARGE {[}real{]}}  Used during potential function smoothing procedures to specify the effective diffusion coefficient to be applied to the smoothed form of the Coulomb’s Law charge\sphinxhyphen{}charge potential function. In the absence of the DIFFUSE\sphinxhyphen{}CHARGE keyword, a default value of 3.5 is used.

\sphinxstylestrong{DIFFUSE\sphinxhyphen{}TORSION {[}real{]}}  Used during potential function smoothing procedures to specify the effective diffusion coefficient to be applied to the smoothed form of the torsion angle potential function. In the absence of the DIFFUSE\sphinxhyphen{}TORSION keyword, a default value of 0.0225 is used.

\sphinxstylestrong{DIFFUSE\sphinxhyphen{}VDW {[}real{]}}  Used during potential function smoothing procedures to specify the effective diffusion coefficient to be applied to the smoothed Gaussian approximation to the Lennard\sphinxhyphen{}Jones van der Waals potential function. In the absence of the DIFFUSE\sphinxhyphen{}VDW keyword, a default value of 1.0 is used.

\sphinxstylestrong{DIGITS {[}integer{]}}  Controls the number of digits of precision  output by Tinker in reporting potential energies and atomic coordinates. The allowed values for the integer modifier are 4, 6 and 8. Input values less than 4 will be set to 4, and those greater than 8 will be set to 8. Final energy values reported by most Tinker programs will contain the specified number of digits to the right of the decimal point. The number of decimal places to be output for atomic coordinates is generally two larger than the value of DIGITS. In the absence of the DIGITS keyword a default value of 4 is used, and  energies will be reported to 4 decimal places with coordinates to 6 decimal places.

\sphinxstylestrong{DIME}

\sphinxstylestrong{DIPOLE {[}2 integers \& 2 reals{]}}  Provides the values for a single bond dipole electrostatic parameter. The integer modifiers give the atom type numbers for the two kinds of atoms involved in the bond dipole which is to be defined. The real number modifiers give the value of the bond dipole in Debyes and the position of the dipole site along the bond. If the bond dipole value is positive, then the first of the two atom types is the positive end of the dipole. For a negative bond dipole value, the first atom type listed is negative. The position along the bond is an optional modifier that gives the postion of the dipole site as a fraction between the first atom type (position=0) and the second atom type (position=1). The default for the dipole position in the absence of a specified value is 0.5, placing the dipole at the midpoint of the bond.

\sphinxstylestrong{DIPOLE\sphinxhyphen{}CUTOFF {[}real{]}}  Sets the cutoff distance value in Angstroms for bond dipole\sphinxhyphen{}bond dipole electrostatic potential energy interactions. The energy for any pair of bond dipole sites beyond the cutoff distance will be set to zero. Other keywords can be used to select a smoothing scheme near the cutoff distance. The default cutoff distance in the absence of the DPL\sphinxhyphen{}CUTOFF keyword is essentially infinite for nonperiodic systems and 10.0 for periodic systems.

\sphinxstylestrong{DIPOLE\sphinxhyphen{}TAPER {[}real{]}}  Modifies the cutoff windows for bond dipole\sphinxhyphen{}bond dipole electrostatic potential energy interactions. It is similar in form and action to the TAPER keyword, except that its value applies only to the vdw potential. The default value in the absence of the DPL\sphinxhyphen{}TAPER keyword is to begin the cutoff window at 0.75 of the dipole cutoff distance.

\sphinxstylestrong{DIPOLE3 {[}2 integers \& 2 reals{]}}  Provides the values for a single bond dipole electrostatic parameter specific to atoms in 3\sphinxhyphen{}membered rings. The integer modifiers give the atom type numbers for the two kinds of atoms involved in the bond dipole which is to be defined. The real number modifiers give the value of the bond dipole in Debyes and the position of the dipole site along the bond. The default for the dipole position in the absence of a specified value is 0.5, placing the dipole at the midpoint of the bond. If any DIPOLE3 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special DIPOLE3 parameters be given for all bond dipoles in 3\sphinxhyphen{}membered rings. In the absence of any DIPOLE3 keywords, standard DIPOLE parameters will be used for bonds in 3\sphinxhyphen{}membered rings.

\sphinxstylestrong{DIPOLE4 {[}2 integers \& 2 reals{]}}  Provides the values for a single bond dipole electrostatic parameter specific to atoms in 4\sphinxhyphen{}membered rings. The integer modifiers give the atom type numbers for the two kinds of atoms involved in the bond dipole which is to be defined. The real number modifiers give the value of the bond dipole in Debyes and the position of the dipole site along the bond. The default for the dipole position in the absence of a specified value is 0.5, placing the dipole at the midpoint of the bond. If any DIPOLE4 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special DIPOLE4 parameters be given for all bond dipoles in 4\sphinxhyphen{}membered rings. In the absence of any DIPOLE4 keywords, standard DIPOLE parameters will be used for bonds in 4\sphinxhyphen{}membered rings.

\sphinxstylestrong{DIPOLE5 {[}2 integers \& 2 reals{]}}  Provides the values for a single bond dipole electrostatic parameter specific to atoms in 5\sphinxhyphen{}membered rings. The integer modifiers give the atom type numbers for the two kinds of atoms involved in the bond dipole which is to be defined. The real number modifiers give the value of the bond dipole in Debyes and the position of the dipole site along the bond. The default for the dipole position in the absence of a specified value is 0.5, placing the dipole at the midpoint of the bond. If any DIPOLE5 keywords are present, either in the master force field parameter file or the keyfile, then Tinker requires that special DIPOLE5 parameters be given for all bond dipoles in 5\sphinxhyphen{}membered rings. In the absence of any DIPOLE5 keywords, standard DIPOLE parameters will be used for bonds in 5\sphinxhyphen{}membered rings.

\sphinxstylestrong{DIPOLETERM {[}NONE/ONLY{]}}  Controls use of the dipole\sphinxhyphen{}dipole potential energy term between pairs of bond dipoles. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{DIRECT\sphinxhyphen{}11\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the permanent (direct) field due to atoms within a polarization group during an induced dipole calculation, i.e., atoms that are in the same polarization group as the atom being polarized. The default value of 0.0 is used, if the DIRECT\sphinxhyphen{}11\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DIRECT\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the permanent (direct) field due to atoms in 1\sphinxhyphen{}2 polarization groups during an induced dipole calculation, i.e., atoms that are in polarization groups directly connected to the group containing the atom being polarized. The default value of 0.0 is used, if the DIRECT\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DIRECT\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the permanent (direct) field due to atoms in 1\sphinxhyphen{}3 polarization groups during an induced dipole calculation, i.e., atoms that are in polarization groups separated by one group from the group containing the atom being polarized. The default value of 0.0 is used, if the DIRECT\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DIRECT\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the permanent (direct) field due to atoms in 1\sphinxhyphen{}4 polarization groups during an induced dipole calculation, i.e., atoms that are in polarization groups separated by two groups from the group containing the atom being polarized. The default value of 1.0 is used, if the DIRECT\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DISP\sphinxhyphen{}12\sphinxhyphen{}SCALE}

\sphinxstylestrong{DISP\sphinxhyphen{}13\sphinxhyphen{}SCALE}

\sphinxstylestrong{DISP\sphinxhyphen{}14\sphinxhyphen{}SCALE}

\sphinxstylestrong{DISP\sphinxhyphen{}15\sphinxhyphen{}SCALE}

\sphinxstylestrong{DISP\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to dispersion potential interactions between 1\sphinxhyphen{}2 connected atoms, i.e., atoms that are directly bonded. The default value of 0.0 is used, if the DISP\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DISP\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to dispersion potential interactions between 1\sphinxhyphen{}3 connected atoms, i.e., atoms separated by two covalent bonds. The default value of 0.0 is used, if the DISP\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DISP\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to dispersion potential interactions between 1\sphinxhyphen{}4 connected atoms, i.e., atoms separated by three covalent bonds. The default value of 1.0 is used, if the DISP\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DISP\sphinxhyphen{}15\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to dispersion potential interactions between 1\sphinxhyphen{}5 connected atoms, i.e., atoms separated by four covalent bonds. The default value of 1.0 is used, if the DISP\sphinxhyphen{}15\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{DISP\sphinxhyphen{}CORRECTION}

\sphinxstylestrong{DISP\sphinxhyphen{}CUTOFF}

\sphinxstylestrong{DISP\sphinxhyphen{}LIST}

\sphinxstylestrong{DISP\sphinxhyphen{}TAPER}

\sphinxstylestrong{DISPERSION}

\sphinxstylestrong{DISPERSIONTERM}

\sphinxstylestrong{DIVERGE {[}real{]}}  Used by the SADDLE program to set the maximum allowed value of the ratio of the gradient length along the path to the total gradient norm at the end of a cycle of minimization perpendicular to the path. If the value provided by the DIVERGE keyword is exceeded, then another cycle of maximization along the path is required. A default value of 0.005 is used in the absence of the DIVERGE keyword.

\sphinxstylestrong{DPME\sphinxhyphen{}GRID {[}3 integers{]}}  Sets the dimensions of the reciprocal space grid used during particle mesh Ewald summation for dispersion. The three modifiers give the size along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes, respectively. If either the Y\sphinxhyphen{} or Z\sphinxhyphen{}axis dimensions are omitted, then they are set equal to the X\sphinxhyphen{}axis dimension. The default in the absence of the PME\sphinxhyphen{}GRID keyword is to set the grid size along each axis to the smallest power of 2, 3 and/or 5 which is at least as large as 0.8 times the axis length in Angstoms.

\sphinxstylestrong{DPME\sphinxhyphen{}ORDER {[}integer{]}}  Sets the order of the B\sphinxhyphen{}spline interpolation used during particle mesh Ewald summation for dispersion. A default value of 4 is used in the absence of the DPME\sphinxhyphen{}ORDER keyword.

\sphinxstylestrong{ECHO {[}text string{]}}  Causes whatever text follows it on the line to be copied directly to the output file. This keyword is also active in parameter files. It has no default value; if no text follows the ECHO keyword, a blank line is placed in the output file.

\sphinxstylestrong{ELE\sphinxhyphen{}LAMBDA}

\sphinxstylestrong{ELECTNEG {[}3 integers \& 1 real{]}}  Provides the values for a single electronegativity bond length correction parameter. The first two integer modifiers give the atom class numbers of the atoms involved in the bond to be corrected. The third integer modifier is the atom class of an electronegative atom. In the case of a primary correction, an atom of this third class must be directly bonded to an atom of the second atom class. For a secondary correction, the third class is one atom removed from an atom of the second class. The real number modifier is the value in Angstroms by which the original ideal bond length is to be corrected.

\sphinxstylestrong{ELECTRIC}

\sphinxstylestrong{ENFORCE\sphinxhyphen{}CHIRALITY}  Causes the chirality found at chiral tetravalent centers in the input structure to be maintained during Tinker calculations. The test for chirality is not exhaustive; two identical monovalent atoms connected to a center cause it to be marked as non\sphinxhyphen{}chiral, but large equivalent substituents are not detected. Trivalent “chiral” centers, for example the alpha carbon in united\sphinxhyphen{}atom protein structures, are not enforced as chiral.

\sphinxstylestrong{EPSILONRULE {[}GEOMETRIC/ARITHMETIC/HARMONIC/HHG{]}}  Selects the combining rule used to derive the ? value for van der Waals interactions. The default in the absence of the EPSILONRULE keyword is to use the GEOMETRIC mean of the individual epsilon values of the two atoms involved in the van der Waals interaction.

\sphinxstylestrong{EWALD}  Turns on the use of Ewald summation during computation of electrostatic interactions in periodic systems. In the current version of Tinker, regular Ewald is used for polarizable atomic multipoles, and smooth particle mesh Ewald (PME) is used for charge\sphinxhyphen{}charge interactions. Ewald summation is not available for interactions involving bond\sphinxhyphen{}centered dipoles. By default, in the absence of the EWALD keyword, distance\sphinxhyphen{}based cutoffs are used for electrostatic interactions.

\sphinxstylestrong{EWALD\sphinxhyphen{}ALPHA {[}real{]}}  Sets the value of the Ewald coefficient which controls the width of the Gaussian screening charges during particle mesh Ewald summation. In the absence of the EWALD\sphinxhyphen{}ALPHA keyword, a value is chosen which causes interactions outside the real\sphinxhyphen{}space cutoff to be below a fixed tolerance. For most standard applications of Ewald summation, the program default should be used.

\sphinxstylestrong{EWALD\sphinxhyphen{}BOUNDARY}  Invokes the use of insulating (ie, vacuum) boundary conditions during Ewald summation, corresponding to the media surrounding the system having a dielectric value of 1. The default in the absence of the EWALD\sphinxhyphen{}BOUNDARY keyword is to use conducting (ie, tinfoil) boundary conditions where the surrounding media is assumed to have an infinite dielectric value.

\sphinxstylestrong{EWALD\sphinxhyphen{}CUTOFF {[}real{]}}  Sets the value in Angstroms of the real\sphinxhyphen{}space distance cutoff for use during Ewald summation. By default, in the absence of the EWALD\sphinxhyphen{}CUTOFF keyword, a value of 9.0 is used.

\sphinxstylestrong{EXIT\sphinxhyphen{}PAUSE}  Causes Tinker programs to pause and wait for a carriage return at the end of executation prior to returning control to the operating system. This is useful to keep the execution window open following termination on machines running Microsoft Windows or Apple MacOS. The default in the absence of the EXIT\sphinxhyphen{}PAUSE keyword, is to return control to the operating system immediately at program termination.

\sphinxstylestrong{EXTRATERM {[}NONE/ONLY{]}}  Controls use of the user defined extra potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{FCTMIN {[}real{]}}  Sets a convergence criterion for successful completion of a Tinker optimization. If the value of the optimization objective function, typically the potential energy, falls below the value set by FCTMIN, then the optimization is deemed to have converged. The default value in the absence of the FCTMIN keyword is \sphinxhyphen{}1000000, effectively removing this criterion as a possible agent for termination.

\sphinxstylestrong{FFT\sphinxhyphen{}PACKAGE}

\sphinxstylestrong{FGCENT {[}3 reals{]}}  Sets grid dimensions along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes which are passed on to the Tinker APBS interface for use in Poisson\sphinxhyphen{}Boltzmann calculations.

\sphinxstylestrong{FGRID {[}3 reals{]}}  Sets grid dimensions along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes which are passed on to the Tinker APBS interface for use in Poisson\sphinxhyphen{}Boltzmann calculations.

\sphinxstylestrong{FIT\sphinxhyphen{}ANGLE}

\sphinxstylestrong{FIT\sphinxhyphen{}BOND}

\sphinxstylestrong{FIT\sphinxhyphen{}OPBEND}

\sphinxstylestrong{FIT\sphinxhyphen{}STRBND}

\sphinxstylestrong{FIT\sphinxhyphen{}TORSION}

\sphinxstylestrong{FIT\sphinxhyphen{}UREY}

\sphinxstylestrong{FIX\sphinxhyphen{}ANGLE}

\sphinxstylestrong{FIX\sphinxhyphen{}BOND}

\sphinxstylestrong{FIX\sphinxhyphen{}DIPOLE}

\sphinxstylestrong{FIX\sphinxhyphen{}MONOPOLE}

\sphinxstylestrong{FIX\sphinxhyphen{}OPBEND}

\sphinxstylestrong{FIX\sphinxhyphen{}QUADRUPOLE}

\sphinxstylestrong{FIX\sphinxhyphen{}STRBND}

\sphinxstylestrong{FIX\sphinxhyphen{}TORSION}

\sphinxstylestrong{FIX\sphinxhyphen{}UREY}

\sphinxstylestrong{FORCEFIELD {[}name{]}}  Provides a name for the force field to be used in the current calculation. Its value is usually set in the master force field parameter file for the calculation (see the PARAMETERS keyword) instead of in the keyfile.

\sphinxstylestrong{FRICTION {[}real{]}}  Sets the value of the frictional coefficient in 1/ps for use with stochastic dynamics. The default value used in the absence of the FRICTION keyword is 91.0, which is generally appropriate for water.

\sphinxstylestrong{FRICTION\sphinxhyphen{}SCALING}  Turns on the use of atomic surface area\sphinxhyphen{}based scaling of the frictional coefficient during stochastic dynamics. When in use, the coefficient for each atom is multiplied by that atom’s fraction of exposed surface area. The default in the absence of the keyword is to omit the scaling and use the full coefficient value for each atom.

\sphinxstylestrong{GAMMA {[}real{]}}  Sets the value of the gamma angle of a crystal unit cell, i.e., the angle between the a\sphinxhyphen{}axis and b\sphinxhyphen{}axis of a unit cell, or, equivalently, the angle between the X\sphinxhyphen{}axis and Y\sphinxhyphen{}axis of a periodic box. The default value in the absence of the GAMMA keyword is to set the gamma angle equal to the gamma angle as given by the keyword ALPHA.

\sphinxstylestrong{GAMMA\sphinxhyphen{}HALGREN {[}real{]}}  Sets the value of the gamma parameter in Halgren’s buffered 14\sphinxhyphen{}7 vdw potential energy functional form. In the absence of the GAMMA\sphinxhyphen{}HALGREN keyword, a default value of 0.12 is used.

\sphinxstylestrong{GAMMAMIN {[}real{]}}  Sets the convergence target value for gamma during searches for maxima along the quadratic synchronous transit used by the SADDLE program. The value of gamma is the square of the ratio of the gradient projection along the path to the total gradient. A default value of 0.00001 is used in the absence of the GAMMAMIN keyword.

\sphinxstylestrong{GAUSSTYPE {[}LJ\sphinxhyphen{}2/LJ\sphinxhyphen{}4/MM2\sphinxhyphen{}2/MM3\sphinxhyphen{}2/IN\sphinxhyphen{}PLACE{]}}  Specifies the underlying vdw form that a Gaussian vdw approximation will attempt to fit as the number of terms to be used in a Gaussian approximation of the Lennard\sphinxhyphen{}Jones van der Waals potential. The text modifier gives the name of the functional form to be used. Thus LJ\sphinxhyphen{}2 as a modifier will result in a 2\sphinxhyphen{}Gaussian fit to a Lennard\sphinxhyphen{}Jones vdw potential. The GAUSSTYPE keyword only takes effect when VDWTYPE is set to GAUSSIAN. This keyword has no default value.

\sphinxstylestrong{GCENT {[}3 reals{]}}  Sets grid dimensions along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes which are passed on to the Tinker APBS interface for use in Poisson\sphinxhyphen{}Boltzmann calculations.

\sphinxstylestrong{GK\sphinxhyphen{}RADIUS}

\sphinxstylestrong{GKC}

\sphinxstylestrong{GKR}

\sphinxstylestrong{GROUP {[}integer, integer list{]}}  Defines an atom group as a substructure within the full input molecular structure. The value of the first integer is the group number which must be in the range from 1 to the maximum number of allowed groups. The remaining intergers give the atom or atoms contained in this group as one or more atom numbers or ranges. Multiple keyword lines can be used to specify additional atoms in the same group. Note that an atom can only be in one group, the last group to which it is assigned is the one used.

\sphinxstylestrong{GROUP\sphinxhyphen{}INTER}  Assigns a value of 1.0 to all inter\sphinxhyphen{}group interactions and a value of 0.0 to all intra\sphinxhyphen{}group interactions. For example, combination with the GROUP\sphinxhyphen{}MOLECULE keyword provides for rigid\sphinxhyphen{}body calculations.

\sphinxstylestrong{GROUP\sphinxhyphen{}INTRA}  Assigns a value of 1.0 to all intra\sphinxhyphen{}group interactions and a value of 0.0 to all inter\sphinxhyphen{}group interactions.

\sphinxstylestrong{GROUP\sphinxhyphen{}MOLECULE}  Sets each individual molecule in the system to be a separate atom group, but does not assign weights to group\sphinxhyphen{}group interactions.

\sphinxstylestrong{GROUP\sphinxhyphen{}SELECT {[}2 integers, real{]}}  Assigns a weight in the final potential energy of a specified set of intra\sphinxhyphen{} or intergroup interactions. The integer modifiers give the group numbers of the groups involved. If the two numbers are the same, then an intragroup set of interactions is specified. The real modifier gives the weight by which all energetic interactions in this set will be multiplied before incorporation into the final potential energy. If omitted as a keyword modifier, the weight will be set to 1.0 by default. If any SELECT\sphinxhyphen{}GROUP keywords are present, then any set of interactions not specified in a SELECT\sphinxhyphen{}GROUP keyword is given a zero weight. The default when no SELECT\sphinxhyphen{}GROUP keywords are specified is to use all intergroup interactions with a weight of 1.0 and to set all intragroup interactions to zero.

\sphinxstylestrong{HBOND {[}2 integers \& 2 reals{]}}  Provides the values for the MM3\sphinxhyphen{}style directional hydrogen bonding parameters for a single pair of atoms. The integer modifiers give the pair of atom class numbers for which hydrogen bonding parameters are to be defined. The two real number modifiers give the values of the minimum energy contact distance in Angstroms and the well depth at the minimum distance in kcal/mole.

\sphinxstylestrong{HEAVY\sphinxhyphen{}HYDROGEN}

\sphinxstylestrong{HESSIAN\sphinxhyphen{}CUTOFF {[}real{]}}  Defines a lower limit for significant Hessian matrix elements. During computation of the Hessian matrix of partial second derivatives, any matrix elements with absolute value below HESS\sphinxhyphen{}CUTOFF will be set to zero and omitted from the sparse matrix Hessian storage scheme used by Tinker. For most calculations, the default in the absence of this keyword is zero, i.e., all elements will be stored. For most Truncated Newton optimizations the Hessian cutoff will be chosen dynamically by the optimizer.

\sphinxstylestrong{HGUESS {[}real{]}}  Sets an initial guess for the average value of the diagonal elements of the scaled inverse Hessian matrix used by the optimally conditioned variable metric optimization routine. A default value of 0.4 is used in the absence of the HGUESS keyword.

\sphinxstylestrong{IEL\sphinxhyphen{}SCF}

\sphinxstylestrong{IMPROPER {[}4 integers \& 2 reals{]}}  Provides the values for a single CHARMM\sphinxhyphen{}style improper dihedral angle parameter.

\sphinxstylestrong{IMPROPTERM {[}NONE/ONLY{]}}  Controls use of the CHARMM\sphinxhyphen{}style improper dihedral angle potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{IMPROPUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the CHARMM\sphinxhyphen{}style improper dihedral angle potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the IMPROPUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{IMPTORS {[}4 integers \& up to 3 real/real/integer triples{]}}  Provides the values for a single AMBER\sphinxhyphen{}style improper torsional angle parameter. The first four integer modifiers give the atom class numbers for the atoms involved in the improper torsional angle to be defined. By convention, the third atom class of the four is the trigonal atom on which the improper torsion is centered. The torsional angle computed is literally that defined by the four atom classes in the order specified by the keyword. Each of the remaining triples of real/real/integer modifiers give the half\sphinxhyphen{}amplitude, phase offset in degrees and periodicity of a particular improper torsional term, respectively. Periodicities through 3\sphinxhyphen{}fold are allowed for improper torsional parameters.

\sphinxstylestrong{IMPTORSTERM {[}NONE/ONLY{]}}  Controls use of the AMBER\sphinxhyphen{}style improper torsional angle potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{IMPTORSUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the AMBER\sphinxhyphen{}style improper torsional angle potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the IMPTORSUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{INACTIVE {[}integer list{]}}  Sets the list of inactive atoms during a Tinker computation. Individual potential energy terms are not computed when all atoms involved in the term are inactive. For Cartesian space calculations, inactive atoms are not allowed to move. For torsional space calculations, rotations are not allowed when there are inactive atoms on both sides of the rotated bond. Multiple INACTIVE lines can be present in the keyfile, and on each line the keyword can be followed by one or more atom numbers or ranges. If any INACTIVE keys are found, all atoms are set to active except those listed on the INACTIVE lines. The ACTIVE keyword overrides all INACTIVE keywords found in the keyfile.

\sphinxstylestrong{INDUCE\sphinxhyphen{}12\sphinxhyphen{}SCALE}

\sphinxstylestrong{INDUCE\sphinxhyphen{}13\sphinxhyphen{}SCALE}

\sphinxstylestrong{INDUCE\sphinxhyphen{}14\sphinxhyphen{}SCALE}

\sphinxstylestrong{INDUCE\sphinxhyphen{}15\sphinxhyphen{}SCALE}

\sphinxstylestrong{INTEGRATOR {[}VERLET/BEEMAN/STOCHASTIC/RIGIDBODY{]}}  Chooses the integration method for propagation of dynamics trajectories. The keyword is followed on the same line by the name of the option. Standard Newtonian MD can be run using either VERLET for the Velocity Verlet method, or BEEMAN for the velocity form of Bernie Brook’s “Better Beeman” method. A Velocity Verlet\sphinxhyphen{}based stochastic dynamics trajectory is selected by the STOCHASTIC modifier. A rigid\sphinxhyphen{}body dynamics method is selected by the RIGIDBODY modifier. The default integration scheme is MD using the BEEMAN method.

\sphinxstylestrong{INTMAX {[}integer{]}}  Sets the maximum number of interpolation cycles that will be allowed during the line search phase of an optimization. All gradient\sphinxhyphen{}based Tinker optimization routines use a common line search routine involving quadratic extrapolation and cubic interpolation. If the value of INTMAX is reached, an error status is set for the line search and the search is repeated with a much smaller initial step size. The default value in the absence of this keyword is optimization routine dependent, but is usually in the range 5 to 10.

\sphinxstylestrong{ION}

\sphinxstylestrong{LAMBDA {[}real{]}}  Sets the value of the lambda path parameter for free energy perturbation calculations. The real number modifier specifies the position along the mutation path and must be a number in the range from 0 (initial state) to 1 (final state). The actual atoms involved in the mutation are given separately in individual MUTATE keyword lines.

\sphinxstylestrong{LBFGS\sphinxhyphen{}VECTORS {[}integer{]}}  Sets the number of correction vectors used by the limited\sphinxhyphen{}memory L\sphinxhyphen{}BFGS optimization routine. The current maximum allowable value, and the default in the absence of the LBFGS\sphinxhyphen{}VECTORS keyword is 15.

\sphinxstylestrong{LIGAND}

\sphinxstylestrong{LIGHTS}  Turns on Method of Lights neighbor generation for the partial charge electrostatics and any of the van der Waals potentials. This method will yield identical energetic results to the standard double loop method. Method of Lights will be faster when the volume of a sphere with radius equal to the nonbond cutoff distance is significantly less than half the volume of the total system (i.e., the full molecular system, the crystal unit cell or the periodic box). It requires less storage than pairwise neighbor lists.

\sphinxstylestrong{LIST\sphinxhyphen{}BUFFER {[}real{]}}  Sets the size of the neighbor list buffer in Angstroms. This value is added to the actual cutoff distance to determine which pairs will be kept on the neighbor list. The same buffer value is used for all neighbor lists. The default value in the absence of 2.0 is used in the absence of the LIST\sphinxhyphen{}BUFFER keyword.

\sphinxstylestrong{MAXITER {[}integer{]}}  Sets the maximum number of minimization iterations that will be allowed for any Tinker program that uses any of the nonlinear optimization routines. The default value in the absence of this keyword is program dependent, but is always set to a very large number.

\sphinxstylestrong{METAL}  Provides the values for a single transition metal ligand field parameter. Note this keyword is present in the code, but not active in the current version of Tinker.

\sphinxstylestrong{METALTERM {[}NONE/ONLY{]}}  Controls use of the transition metal ligand field potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{MG\sphinxhyphen{}AUTO}

\sphinxstylestrong{MG\sphinxhyphen{}MANUAL}

\sphinxstylestrong{MMFF\sphinxhyphen{}PIBOND}

\sphinxstylestrong{MMFFANGLE}

\sphinxstylestrong{MMFFAROM}

\sphinxstylestrong{MMFFBCI}

\sphinxstylestrong{MMFFBOND}

\sphinxstylestrong{MMFFBONDER}

\sphinxstylestrong{MMFFCOVRAD}

\sphinxstylestrong{MMFFDEFSTBN}

\sphinxstylestrong{MMFFEQUIV}

\sphinxstylestrong{MMFFOPBEND}

\sphinxstylestrong{MMFFPBCI}

\sphinxstylestrong{MMFFPROP}

\sphinxstylestrong{MMFFSTRBND}

\sphinxstylestrong{MMFFTORSION}

\sphinxstylestrong{MMFFVDW}

\sphinxstylestrong{MPOLE\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to permanent atomic multipole electrostatic interactions between 1\sphinxhyphen{}2 connected atoms, i.e., atoms that are directly bonded. The default value of 0.0 is used, if the MPOLE\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MPOLE\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to permanent atomic multipole  electrostatic interactions between 1\sphinxhyphen{}3 connected atoms, i.e., atoms separated by two covalent bonds. The default value of 0.0 is used, if the MPOLE\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MPOLE\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to permanent atomic multipole  electrostatic interactions between 1\sphinxhyphen{}4 connected atoms, i.e., atoms separated by three covalent bonds. The default value of 1.0 is used, if the MPOLE\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MPOLE\sphinxhyphen{}15\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to permanent atomic multipole  electrostatic interactions between 1\sphinxhyphen{}5 connected atoms, i.e., atoms separated by four covalent bonds. The default value of 1.0 is used, if the MPOLE\sphinxhyphen{}15\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MPOLE\sphinxhyphen{}CUTOFF {[}real{]}}  Sets the cutoff distance value in Angstroms for atomic multipole potential energy interactions. The energy for any pair of sites beyond the cutoff distance will be set to zero. Other keywords can be used to select a smoothing scheme near the cutoff distance. The default cutoff distance in the absence of the MPOLE\sphinxhyphen{}CUTOFF keyword is infinite for nonperiodic systems and 9.0 for periodic systems.

\sphinxstylestrong{MPOLE\sphinxhyphen{}LIST}

\sphinxstylestrong{MPOLE\sphinxhyphen{}TAPER {[}real{]}}  Modifies the cutoff window for atomic multipole potential energy interactions. It is similar in form and action to the TAPER keyword, except that its value applies only to the atomic multipole potential. The default value in the absence of the MPOLE\sphinxhyphen{}TAPER keyword is to begin the cutoff window at 0.65 of the corresponding cutoff distance.

\sphinxstylestrong{MULTIPOLE {[}5 lines with: 3 or 4 integers \& 1 real; 3 reals; 1 real; 2 reals; 3 reals{]}}  Provides the values for a set of atomic multipole parameters at a single site. A complete keyword entry consists of three consequtive lines, the first line containing the MULTIPOLE keyword and the two following lines. The first line contains three integers which define the atom type on which the multipoles are centered, and the Z\sphinxhyphen{}axis and X\sphinxhyphen{}axis defining atom types for this center. The optional fourth integer contains the Y\sphinxhyphen{}axis defining atom type, and is only required for locally chiral multipole sites. The real number on the first line gives the monopole (atomic charge) in electrons. The second line contains three real numbers which give the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}components of the atomic dipole in electron\sphinxhyphen{}Ang. The final three lines, consisting of one, two and three real numbers give the upper triangle of the traceless atomic quadrupole tensor in electron\sphinxhyphen{}Ang\textasciicircum{}2.

\sphinxstylestrong{MULTIPOLETERM {[}NONE/ONLY{]}}  Controls use of the atomic multipole electrostatics potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{MUTATE {[}3 integers{]}}  Specifies atoms to be mutated during free energy perturbation calculations. The first integer modifier gives the atom number of an atom in the current system. The final two modifier values give the atom types corresponding the the lambda=0 and lambda=1 states of the specified atom.

\sphinxstylestrong{MUTUAL\sphinxhyphen{}11\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the induced (mutual) field due to atoms within a polarization group during an induced dipole calculation, i.e., atoms that are in the same polarization group as the atom being polarized. The default value of 1.0 is used, if the MUTUAL\sphinxhyphen{}11\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MUTUAL\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the induced (mutual) field due to atoms in 1\sphinxhyphen{}2 polarization groups during an induced dipole calculation, i.e., atoms that are in polarization groups directly connected to the group containing the atom being polarized. The default value of 1.0 is used, if the MUTUAL\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MUTUAL\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the induced (mutual) field due to atoms in 1\sphinxhyphen{}3 polarization groups during an induced dipole calculation, i.e., atoms that are in polarization groups separated by one group from the group containing the atom being polarized. The default value of 1.0 is used, if the MUTUAL\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{MUTUAL\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to the induced (mutual) field due to atoms in 1\sphinxhyphen{}4 polarization groups during an induced dipole calculation, i.e., atoms that are in polarization groups separated by two groups from the group containing the atom being polarized. The default value of 1.0 is used, if the MUTUAL\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{NEIGHBOR\sphinxhyphen{}GROUPS}  Causes the attached atom to be used in determining the charge\sphinxhyphen{}charge neighbor distance for all monovalent atoms in the molecular system. Its use causes all monovalent atoms to be treated the same as their attached atoms for purposes of including or scaling 1\sphinxhyphen{}2, 1\sphinxhyphen{}3 and 1\sphinxhyphen{}4 interactions. This option works only for the simple charge\sphinxhyphen{}charge electrostatic potential; it does not affect bond dipole or atomic multipole potentials. The NEIGHBOR\sphinxhyphen{}GROUPS scheme is similar to that used by some common force fields such as ENCAD.

\sphinxstylestrong{NEIGHBOR\sphinxhyphen{}LIST}  Turns on pairwise neighbor lists for partial charge electrostatics, polarize multipole electrostatics and any of the van der Waals potentials. This method will yield identical energetic results to the standard double loop method.

\sphinxstylestrong{NEUTRAL\sphinxhyphen{}GROUPS}  Causes the attached atom to be used in determining the charge\sphinxhyphen{}charge interaction cutoff distance for all monovalent atoms in the molecular system. Its use reduces cutoff discontinuities by avoiding splitting many of the largest charge separations found in typical molecules. Note that this keyword does not rigorously implement the usual concept of a “neutral group” as used in the literature with Amber/OPLS and other force fields. This option works only for the simple charge\sphinxhyphen{}charge electrostatic potential; it does not affect bond dipole or atomic multipole potentials.

\sphinxstylestrong{NEWHESS {[}integer{]}}  Sets the number of algorithmic iterations between recomputation of the Hessian matrix. At present this keyword applies exclusively to optimizations using the Truncated Newton method. The default value in the absence of this keyword is 1, i.e., the Hessian is computed on every iteration.

\sphinxstylestrong{NEXTITER {[}integer{]}}  Sets the iteration number to be used for the first iteration of the current computation. At present this keyword applies to optimization procedures where its use can effect convergence criteria, timing of restarts, and so forth. The default in the absence of this keyword is to take the initial iteration as iteration 1.

\sphinxstylestrong{NOARCHIVE}  Causes Tinker molecular dynamics\sphinxhyphen{}based programs to write trajectories directly to “cycle” files with a sequentially numbered file extension. The default, in the absence of this keyword, is to write a single plain\sphinxhyphen{}text archive file with the .arc format. If an archive file already exists at the start of the calculation, then the newly generated trajectory is appended to the end of the existing file. The default in the absence of this keyword is to write the trajectory snapshots to consecutively numbered cycle files.

\sphinxstylestrong{NOSYMMETRY}

\sphinxstylestrong{NOVERSION}  Turns off the use of version numbers appended to the end of filenames as the method for generating filenames for updated copies of an existing file. The presence of this keyword results in direct use of input file names without a search for the highest available version, and requires the entry of specific output file names in many additional cases. By default, in the absence of this keyword, Tinker generates and attaches version numbers in a manner similar to the Digital OpenVMS operating system. For example, subsequent new versions of the file molecule.xyz would be written first to the file molecule.xyz\_2, then to molecule.xyz\_3, etc.

\sphinxstylestrong{OCTAHEDRON}  Specifies that the periodic “box” is a truncated octahedron with maximal distance across the truncated octahedron as given by the A\sphinxhyphen{}AXIS keyword. All other unit cell and periodic box size\sphinxhyphen{}defining keywords are ignored if the OCTAHEDRON keyword is present.

\sphinxstylestrong{OPBEND {[}4 integers \& 1 real{]}}  Provides the values for a single out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential parameter. The first integer modifier is the atom class of the out\sphinxhyphen{}of\sphinxhyphen{}plane atom and the second integer is the atom class of the central trigonal atom. The third and fourth integers give the atom classes of the two remaining atoms attached to the trigonal atom. Values of zero for the third and fourth integers are treated as wildcards, and can represent any atom type. The real number modifier gives the force constant value for the out\sphinxhyphen{}of\sphinxhyphen{}plane angle. The default units for the force constant are kcal/mole/radian\textasciicircum{}2, but this can be controlled via the OPBENDUNIT keyword.

\sphinxstylestrong{OPBEND\sphinxhyphen{}CUBIC {[}real{]}}  Sets the value of the cubic term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy unit conversion factor, the force constant, and the cube of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane angle from zero gives the cubic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy. The default value in the absence of the OPBEND\sphinxhyphen{}CUBIC keyword is zero; i.e., the cubic out\sphinxhyphen{}of\sphinxhyphen{}plane bending term is omitted.

\sphinxstylestrong{OPBEND\sphinxhyphen{}PENTIC {[}real{]}}  Sets the value of the fifth power term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy unit conversion factor, the force constant, and the fifth power of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane angle from zero gives the pentic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy. The default value in the absence of the OPBEND\sphinxhyphen{}PENTIC keyword is zero; i.e., the pentic out\sphinxhyphen{}of\sphinxhyphen{}plane bending term is omitted.

\sphinxstylestrong{OPBEND\sphinxhyphen{}QUARTIC {[}real{]}}  Sets the value of the quartic term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy unit conversion factor, the force constant, and the forth power of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane angle from zero gives the quartic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy. The default value in the absence of the OPBEND\sphinxhyphen{}QUARTIC keyword is zero; i.e., the quartic out\sphinxhyphen{}of\sphinxhyphen{}plane bending term is omitted.

\sphinxstylestrong{OPBEND\sphinxhyphen{}SEXTIC {[}real{]}}  Sets the value of the sixth power term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy unit conversion factor, the force constant, and the sixth power of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane angle from zero gives the sextic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane bending energy. The default value in the absence of the OPBEND\sphinxhyphen{}SEXTIC keyword is zero; i.e., the sextic out\sphinxhyphen{}of\sphinxhyphen{}plane bending term is omitted.

\sphinxstylestrong{OPBENDTERM {[}NONE/ONLY{]}}  Controls use of the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{OPBENDTYPE {[}W\sphinxhyphen{}D\sphinxhyphen{}C/Allinger{]}}  Sets the type of angle to be used in the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential energy term. The choices are to use the Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross (W\sphinxhyphen{}D\sphinxhyphen{}C) formulation from vibrational spectroscopy, or the Allinger angle from the MM2/MM3 force fields. The default value in the absence of the OPBENDTYPE keyword is to use the W\sphinxhyphen{}D\sphinxhyphen{}C angle.

\sphinxstylestrong{OPBENDUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the out\sphinxhyphen{}of\sphinxhyphen{}plane bending potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default of (Pi/180)\textasciicircum{}2 = 0.0003046 is used, if the OPBENDUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{OPDIST {[}4 integers \& 1 real{]}}  Provides the values for a single out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential parameter. The first integer modifier is the atom class of the central trigonal atom and the three following integer modifiers are the atom classes of the three attached atoms. The real number modifier is the force constant for the harmonic function of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance of the central atom. The default units for the force constant are kcal/mole/Ang\textasciicircum{}2, but this can be controlled via the OPDISTUNIT keyword.

\sphinxstylestrong{OPDIST\sphinxhyphen{}CUBIC {[}real{]}}  Sets the value of the cubic term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy unit conversion factor, the force constant, and the cube of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance from zero gives the cubic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy. The default value in the absence of the OPDIST\sphinxhyphen{}CUBIC keyword is zero; i.e., the cubic out\sphinxhyphen{}of\sphinxhyphen{}plane distance term is omitted.

\sphinxstylestrong{OPDIST\sphinxhyphen{}PENTIC {[}real{]}}  Sets the value of the fifth power term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy unit conversion factor, the force constant, and the fifth power of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance from zero gives the pentic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy. The default value in the absence of the OPDIST\sphinxhyphen{}PENTIC keyword is zero; i.e., the pentic out\sphinxhyphen{}of\sphinxhyphen{}plane distance term is omitted.

\sphinxstylestrong{OPDIST\sphinxhyphen{}QUARTIC {[}real{]}}  Sets the value of the quartic term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy unit conversion factor, the force constant, and the forth power of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance from zero gives the quartic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy. The default value in the absence of the OPDIST\sphinxhyphen{}QUARTIC keyword is zero; i.e., the quartic out\sphinxhyphen{}of\sphinxhyphen{}plane distance term is omitted.

\sphinxstylestrong{OPDIST\sphinxhyphen{}SEXTIC {[}real{]}}  Sets the value of the sixth power term in the Taylor series expansion form of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. This term multiplied by the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy unit conversion factor, the force constant, and the sixth power of the deviation of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance from zero gives the sextic contribution to the out\sphinxhyphen{}of\sphinxhyphen{}plane distance energy. The default value in the absence of the OPDIST\sphinxhyphen{}SEXTIC keyword is zero; i.e., the sextic out\sphinxhyphen{}of\sphinxhyphen{}plane distance term is omitted.

\sphinxstylestrong{OPDISTTERM {[}NONE/ONLY{]}}  Controls use of the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{OPDISTUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the OPDISTUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{OPENMP\sphinxhyphen{}THREADS {[}integer{]}}  Sets the number of threads to be used in OpenMP parallelization of certain Tinker calculations. The default in the absence of the OPENMP\sphinxhyphen{}THREADS keyword is to set the number of threads equal to the total number of CPU cores found for the computer being used.

\sphinxstylestrong{OPT\sphinxhyphen{}COEFF}

\sphinxstylestrong{OVERWRITE}  Causes Tinker programs, such as minimizations, that output intermediate coordinate sets to create a single disk file for the intermediate results which is successively overwritten with the new intermediate coordinates as they become available. This keyword is essentially the opposite of the SAVECYCLE keyword.

\sphinxstylestrong{PARAMETERS {[}file name{]}}  Provides the name of the force field parameter file to be used for the current Tinker calculation. The standard file name extension for parameter files, .prm, is an optional part of the file name modifier. The default in the absence of the PARAMETERS keyword is to look for a parameter file with the same base name as the molecular system and ending in the .prm extension. If a valid parameter file is not found, the user will asked to provide a file name interactively.

\sphinxstylestrong{PB\sphinxhyphen{}RADIUS}

\sphinxstylestrong{PCG\sphinxhyphen{}GUESS}

\sphinxstylestrong{PCG\sphinxhyphen{}NOGUESS}

\sphinxstylestrong{PCG\sphinxhyphen{}NOPRECOND}

\sphinxstylestrong{PCG\sphinxhyphen{}PEEK}

\sphinxstylestrong{PCG\sphinxhyphen{}PRECOND}

\sphinxstylestrong{PDIE}

\sphinxstylestrong{PENETRATION}

\sphinxstylestrong{PEWALD\sphinxhyphen{}ALPHA}

\sphinxstylestrong{PIATOM {[}1 integer \& 3 reals{]}}  Provides the values for the pisystem MO potential parameters for a single atom class belonging to a pisystem.

\sphinxstylestrong{PIBOND {[}2 integers \& 2 reals{]}}  Provides the values for the pisystem MO potential parameters for a single type of pisystem bond.

\sphinxstylestrong{PIBOND4 {[}2 integers \& 2 reals{]}}  Provides the values for the pisystem MO potential parameters for a single type of pisystem bond contained in a 4\sphinxhyphen{}membered ring.

\sphinxstylestrong{PIBOND5 {[}2 integers \& 2 reals{]}}  Provides the values for the pisystem MO potential parameters for a single type of pisystem bond contained in a 5\sphinxhyphen{}membered ring.

\sphinxstylestrong{PISYSTEM {[}integer list{]}}  Sets the atoms within a molecule that are part of a conjugated pi\sphinxhyphen{}orbital system. The keyword is followed on the same line by a list of atom numbers and/or atom ranges that constitute the pi\sphinxhyphen{}system. The Allinger MM force fields use this information to set up an MO calculation used to scale bond and torsion parameters involving pi\sphinxhyphen{}system atoms.

\sphinxstylestrong{PITORS {[}2 integers \& 1 real{]}}  Provides the values for a single pi\sphinxhyphen{}orbital torsional angle potential parameter. The two integer modifiers give the atom class numbers for the atoms involved in the central bond of the torsional angle to be parameterized. The real modifier gives the value of the 2\sphinxhyphen{}fold Fourier amplitude for the torsional angle between p\sphinxhyphen{}orbitals centered on the defined bond atom classes. The default units for the stretch\sphinxhyphen{}torsion force constant can be controlled via the PITORSUNIT keyword.

\sphinxstylestrong{PITORSTERM {[}NONE/ONLY{]}}  Controls use of the pi\sphinxhyphen{}orbital torsional angle potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{PITORSUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the pi\sphinxhyphen{}orbital torsional angle potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the PITORSUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{PME\sphinxhyphen{}GRID {[}3 integers{]}}  Sets the dimensions of the reciprocal space grid used during particle mesh Ewald summation for electrostatics. The three modifiers give the size along the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}axes, respectively. If either the Y\sphinxhyphen{} or Z\sphinxhyphen{}axis dimensions are omitted, then they are set equal to the X\sphinxhyphen{}axis dimension. The default in the absence of the PME\sphinxhyphen{}GRID keyword is to set the grid size along each axis to the smallest power of 2, 3 and/or 5 which is at least as large as 1.2 times the axis length in Angstoms.

\sphinxstylestrong{PME\sphinxhyphen{}ORDER {[}integer{]}}  Sets the order of the B\sphinxhyphen{}spline interpolation used during particle mesh Ewald summation for partial charge or atomic multipole electrostatics. A default value of 5 is used in the absence of the PME\sphinxhyphen{}ORDER keyword.

\sphinxstylestrong{POLAR\sphinxhyphen{}12\sphinxhyphen{}INTRA {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}2 connected atoms located in the same polarization group. The default value of 0.0 is used, if the POLAR\sphinxhyphen{}12\sphinxhyphen{}INTRA keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}2 connected atoms located in different polarization groups. The default value of 0.0 is used, if the POLAR\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}13\sphinxhyphen{}INTRA {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}3 connected atoms located in the same polarization group. The default value of 0.0 is used, if the POLAR\sphinxhyphen{}13\sphinxhyphen{}INTRA keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}3 connected atoms located in different polarization groups. The default value of 0.0 is used, if the POLAR\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}14\sphinxhyphen{}INTRA {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}4 connected atoms located in the same polarization group. The default value of 0.5 is used, if the POLAR\sphinxhyphen{}14\sphinxhyphen{}INTRA keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}4 connected atoms located in different polarization groups. The default value of 1.0 is used, if the POLAR\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}15\sphinxhyphen{}INTRA {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}5 connected atoms located in the same polarization group. The default value of 1.0 is used, if the POLAR\sphinxhyphen{}15\sphinxhyphen{}INTRA keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}15\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to polarization interactions between 1\sphinxhyphen{}5 connected atoms located in different polarization groups. The default value of 1.0 is used, if the POLAR\sphinxhyphen{}15\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{POLAR\sphinxhyphen{}EPS {[}real{]}}  Sets the convergence criterion applied during computation of self\sphinxhyphen{}consistent induced dipoles. The calculation is deemed to have converged when the rms change in Debyes in the induced dipole at all polarizable sites is less than the value specified with this keyword. The default value in the absence of the keyword is 0.000001 Debyes.

\sphinxstylestrong{POLAR\sphinxhyphen{}ITER}  Sets the maximum number of conjugate gradient iterations to be used in the solution of the self\sphinxhyphen{}consistent mutual induced dipoles. The default values in the absence of the keyword is 100 iterations.

\sphinxstylestrong{POLARIZATION {[}DIRECT/MUTUAL{]}}  Selects between the use of direct and mutual dipole polarization for force fields that incorporate the polarization term. The DIRECT modifier avoids an iterative calculation by using only the permanent electric field in computation of induced dipoles. The MUTUAL option, which is the default in the absence of the POLARIZATION keyword, iterates the induced dipoles to self\sphinxhyphen{}consistency.

\sphinxstylestrong{POLAR\sphinxhyphen{}PREDICT {[}ASPC/GEAR/LSQR{]}}  Turns on use of an induced dipole prediction method to accelerate convergence of self\sphinxhyphen{}consistent induced dipoles. The Always Stable Predictor\sphinxhyphen{}Corrector (ASPC) method, a standard Gear extrapolation method (GEAR), and extrapolation based on a least squared prediction (LSQR) are available as modifiers to the keyword. The default value if the keyword is used without a modifier is ASPC. Use of POLAR\sphinxhyphen{}PREDICT biases the early stages of induced dipole convergence, and should only be used when requesting tight convergence of 0.00001 or less via POLAR\sphinxhyphen{}EPS.

\sphinxstylestrong{POLARIZABLE}

\sphinxstylestrong{POLARIZATION}

\sphinxstylestrong{POLARIZE {[}1 integer, 1 real \& up to 4 integers{]}}  Provides the values for a single atomic dipole polarizability parameter. The integer modifier, if positive, gives the atom type number for which a polarizability parameter is to be defined. If the first integer modifier is negative, then the parameter value to follow applies only to the individual atom whose atom number is the negative of the modifier. The real number modifier gives the value of the dipole polarizability in Ang\textasciicircum{}3. The final integer modifiers list the atom type numbers of atoms directly bonded to the current atom and which will be considered to be part of the current atom’s polarization group.

\sphinxstylestrong{POLARIZETERM {[}NONE/ONLY{]}}  Controls use of the atomic dipole polarization potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{POLYMER\sphinxhyphen{}CUTOFF {[}real{]}}  Sets the value of an additional cutoff parameter needed for infinite polymer systems. This value must be set to less than half the minimal periodic box dimension and should be greater than the largest possible interatomic distance that can be subject to scaling or exclusion as a local electrostatic or van der Waals interaction. The default in the absence of the POLYMER\sphinxhyphen{}CUTOFF keyword is 5.5 Angstroms.

\sphinxstylestrong{POTENTIAL\sphinxhyphen{}ATOMS}

\sphinxstylestrong{POTENTIAL\sphinxhyphen{}FACTOR}

\sphinxstylestrong{POTENTIAL\sphinxhyphen{}FIT}

\sphinxstylestrong{POTENTIAL\sphinxhyphen{}OFFSET}

\sphinxstylestrong{POTENTIAL\sphinxhyphen{}SHELLS}

\sphinxstylestrong{POTENTIAL\sphinxhyphen{}SPACING}

\sphinxstylestrong{PPME\sphinxhyphen{}ORDER {[}integer{]}}  Sets the order of the B\sphinxhyphen{}spline interpolation used during particle mesh Ewald summation for polarization interactions. A default value of 5 is used in the absence of the PPME\sphinxhyphen{}ORDER keyword.

\sphinxstylestrong{PRINTOUT {[}integer{]}}  Sets the number of iterations between writes of status information to the standard output for iterative procedures such as minimizations. The default value in the absence of the keyword is 1, i.e., the calculation status is given every iteration.

\sphinxstylestrong{RADIUSRULE {[}ARITHMETIC/GEOMETRIC/CUBIC\sphinxhyphen{}MEAN{]}}  Sets the functional form of the radius combining rule for heteroatomic van der Waals potential energy interactions. The default in the absence of the RADIUSRULE keyword is to use the arithmetic mean combining rule to get radii for heteroatomic interactions.

\sphinxstylestrong{RADIUSSIZE {[}RADIUS/DIAMETER{]}}  Determines whether the atom size values given in van der Waals parameters read from VDW keyword statements are interpreted as atomic radius or diameter values. The default in the absence of the RADIUSSIZE keyword is to assume that vdw size parameters are given as radius values.

\sphinxstylestrong{RADIUSTYPE {[}R\sphinxhyphen{}MIN/SIGMA{]}}  Determines whether atom size values given in van der Waals parameters read from VDW keyword statements are interpreted as potential minimum (Rmin) or LJ\sphinxhyphen{}style sigma values. The default in the absence of the RADIUSTYPE keyword is to assume that vdw size parameters are given as Rmin values.

\sphinxstylestrong{RANDOMSEED {[}integer{]}}  Followed by an integer value, sets the initial seed value for the random number generator used by Tinker. Setting RANDOMSEED to the same value as an earlier run will allow exact reproduction of the earlier calculation. (Note that this will not hold across different machine types.) RANDOMSEED should be set to a positive integer less than about 2 billion. In the absence of the RANDOMSEED keyword the seed is chosen “randomly” based upon the number of seconds that have elapsed in the current decade.

\sphinxstylestrong{RATTLE {[}BONDS/ANGLES/DIATOMIC/TRIATOMIC/WATER{]}}  Invokes the rattle algorithm, a velocity version of shake, on portions of a molecular system during a molecular dynamic calculation. The RATTLE keyword can be followed by any of the modifiers shown, in which case all occurrences of the modifier species are constrained at ideal values taken from the bond and angle parameters of the force field in use. In the absence of any modifier, RATTLE constrains all bonds to hydrogen atoms at ideal bond lengths.

\sphinxstylestrong{RATTLE\sphinxhyphen{}DISTANCE {[}2 integers{]}}  Allows the use of a holonomic constraint between the two atoms whose numbers are specified on the keyword line. If the two atoms are involved in a covalent bond, then their distance is constrained to the ideal bond length from the force field. For nonbonded atoms, the rattle constraint is fixed at their distance in the input coordinate file.

\sphinxstylestrong{RATTLE\sphinxhyphen{}EPS}

\sphinxstylestrong{RATTLE\sphinxhyphen{}LINE {[}integer{]}}

\sphinxstylestrong{RATTLE\sphinxhyphen{}ORIGIN {[}integer{]}}

\sphinxstylestrong{RATTLE\sphinxhyphen{}PLANE {[}integer{]}}

\sphinxstylestrong{REACTIONFIELD {[}2 reals \& 1 integer{]}}  Provides parameters needed for the reaction field potential energy calculation. The two real modifiers give the radius of the dielectric cavity and the ratio of the bulk dielectric outside the cavity to that inside the cavity. The integer modifier gives the number of terms in the reaction field summation to be used. In the absence of the REACTIONFIELD keyword, the default values are a cavity of radius 1000000 Ang, a dielectric ratio of 80 and use of only the first term of the reaction field summation.

\sphinxstylestrong{REDUCE {[}real{]}}  Specifies the fraction between zero and one by which the path between starting and final conformational state will be shortened at each major cycle of the transition state location algorithm implemented by the SADDLE program. This causes the path endpoints to move up and out of the terminal structures toward the transition state region. In favorable cases, a nonzero value of the REDUCE modifier can speed convergence to the transition state. The default value in the absence of the REDUCE keyword is zero.

\sphinxstylestrong{REMOVE\sphinxhyphen{}INERTIA}

\sphinxstylestrong{REP\sphinxhyphen{}12\sphinxhyphen{}SCALE}

\sphinxstylestrong{REP\sphinxhyphen{}13\sphinxhyphen{}SCALE}

\sphinxstylestrong{REP\sphinxhyphen{}14\sphinxhyphen{}SCALE}

\sphinxstylestrong{REP\sphinxhyphen{}15\sphinxhyphen{}SCALE}

\sphinxstylestrong{REPULS\sphinxhyphen{}CUTOFF}

\sphinxstylestrong{REPULS\sphinxhyphen{}TAPER}

\sphinxstylestrong{REPULSION}

\sphinxstylestrong{REPULSIONTERM}

\sphinxstylestrong{RESP\sphinxhyphen{}WEIGHT}

\sphinxstylestrong{RESPA\sphinxhyphen{}INNER}

\sphinxstylestrong{RESPTYPE}

\sphinxstylestrong{RESTRAIN\sphinxhyphen{}ANGLE {[}3 integers \& 3 reals{]}}  Implements a flat\sphinxhyphen{}welled harmonic potential that can be used to restrain the angle between three atoms to lie within a specified angle range. The integer modifiers contain the atom numbers of the three atoms whose angle is to be restrained.  The first real modifier is the force constant in kcal/degree\textasciicircum{}2 for the restraint. The last two real modifiers give the lower and upper bounds in degrees on the allowed angle values. If the angle lies between the lower and upper bounds, the restraint potential is zero. Outside the bounds, the harmonic restraint is applied. If the angle range modifiers are omitted, then the atoms are restrained to the angle found in the input structure. If the force constant is also omitted, a default value of 10.0 is used.

\sphinxstylestrong{RESTRAIN\sphinxhyphen{}DISTANCE {[}2 integers \& 3 reals{]}}  Implements a flat\sphinxhyphen{}welled harmonic potential that can be used to restrain two atoms to lie within a specified distance range. The integer modifiers contain the atom numbers of the two atoms to be restrained. The first real modifier specifies the force constant in kcal/Ang\textasciicircum{}2 for the restraint. The next two real modifiers give the lower and upper bounds in Angstroms on the allowed distance range. If the interatomic distance lies between these lower and upper bounds, the restraint potential is zero. Outside the bounds, the harmonic restraint is applied. If the distance range modifiers are omitted, then the atoms are restrained to the interatomic distance found in the input structure. If the force constant is also omitted, a default value of 100.0 is used.

\sphinxstylestrong{RESTRAIN\sphinxhyphen{}GROUPS {[}2 integers \& 3 reals{]}}  Implements a flat\sphinxhyphen{}welled harmonic distance restraint between the centers\sphinxhyphen{}of\sphinxhyphen{}mass of two groups of atoms. The integer modifiers are the numbers of the two groups which must be defined separately via the GROUP keyword. The first real modifier is the force constant in kcal/Ang\textasciicircum{}2 for the restraint. The last two real modifiers give the lower and upper bounds in Angstroms on the allowed intergroup center\sphinxhyphen{}of\sphinxhyphen{}mass distance values. If the distance range modifiers are omitted, then the groups are restrained to the distance found in the input structure. If the force constant is also omitted, a default value of 100.0 is used.

\sphinxstylestrong{RESTRAIN\sphinxhyphen{}POSITION {[}1 integer \& 5 reals{]}}  Provides the ability to restrain an individual atom to a specified coordinate position. The initial integer modifier contains the atom number of the atom to be restrained. The first real modifier sets the force constant in kcal/Ang\textasciicircum{}2 for the harmonic restraint potential. The next three real number modifiers give the X\sphinxhyphen{}, Y\sphinxhyphen{} and Z\sphinxhyphen{}coordinates to which the atom is tethered. The final real modifier defines a sphere around the specified coordinates within which the restraint value is zero. If the exclusion sphere radius is omitted, it is taken to be zero. If  the coordinates are omitted, then the atom is restrained to the origin. If the force constant is also omitted, a default value of 100.0 is used.

\sphinxstylestrong{RESTRAIN\sphinxhyphen{}TORSION {[}4 integers \& 3 reals{]}}  Implements a flat\sphinxhyphen{}welled harmonic potential that can be used to restrain the torsional angle between four atoms to lie within a specified angle range. The initial integer modifiers contains the atom numbers of the four atoms whose torsional angle, computed in the atom order listed, is to be restrained. The first real modifier gives a force constant in kcal/degree\textasciicircum{}2 for the restraint. The last two real modifiers give the lower and upper bounds in degrees on the allowed torsional angle values. The angle values given can wrap around across \sphinxhyphen{}180 and +180 degrees. Outside the allowed angle range, the harmonic restraint is applied. If the angle range modifiers are omitted, then the atoms are restrained to the torsional angle found in the input structure. If the force constant is also omitted, a default value of 1.0 is used.

\sphinxstylestrong{RESTRAINTERM {[}NONE/ONLY{]}}  Controls use of the restraint potential energy terms. In the absence of a modifying option, this keyword turns on use of these potentials. The NONE option turns off use of these potential energy terms. The ONLY option turns off all potential energy terms except for these terms.

\sphinxstylestrong{ROTATABLE\sphinxhyphen{}BOND}

\sphinxstylestrong{RXNFIELDTERM {[}NONE/ONLY{]}}  Controls use of the reaction field continuum solvation potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{SADDLEPOINT}  Allows Newton\sphinxhyphen{}style second derivative\sphinxhyphen{}based optimization routine used by NEWTON, NEWTROT and other programs to converge to saddlepoints as well as minima on the potential surface. By default, in the absence of the SADDLEPOINT keyword, checks are applied that prevent convergence to stationary points having directions of negative curvature.

\sphinxstylestrong{SAVE\sphinxhyphen{}CYCLE}  Causes Tinker programs, such as minimizations, that output intermediate coordinate sets to save each successive set to the next consecutively numbered cycle file. The SAVE\sphinxhyphen{}CYCLE keyword is the opposite of the OVERWRITE keyword.

\sphinxstylestrong{SAVE\sphinxhyphen{}FORCE}  Causes Tinker molecular dynamics calculations to save the values of the force components on each atom to a separate cycle file. These files are written whenever the atomic coordinate snapshots are written during the dynamics run. Each atomic force file name contains as a suffix the cycle number followed by the letter f.

\sphinxstylestrong{SAVE\sphinxhyphen{}INDUCED}  Causes Tinker molecular dynamics calculations that involve polarizable atomic multipoles to save the values of the induced dipole components on each polarizable atom to a separate cycle file. These files are written whenever the atomic coordinate snapshots are written during the dynamics run. Each induced dipole file name contains as a suffix the cycle number followed by the letter u.

\sphinxstylestrong{SAVE\sphinxhyphen{}VECTS}

\sphinxstylestrong{SAVE\sphinxhyphen{}VELOCITY}  Causes Tinker molecular dynamics calculations to save the values of the velocity components on each atom to a separate cycle file. These files are written whenever the atomic coordinate snapshots are written during the dynamics run. Each velocity file name contains as a suffix the cycle number followed by the letter v.

\sphinxstylestrong{SDENS}

\sphinxstylestrong{SDIE}

\sphinxstylestrong{SLOPEMAX {[}real{]}}  Sets via its modifying value the maximum allowed size of the ratio between the current and initial projected gradients during the line search phase of conjugate gradient or truncated Newton optimizations. If this ratio exceeds SLOPEMAX, then the initial step size is reduced by a factor of 10. The default value is usually set to 10000.0 when not specified via the SLOPEMAX keyword.

\sphinxstylestrong{SMIN}

\sphinxstylestrong{SMOOTHING {[}DEM/GDA/TOPHAT/STOPHAT{]}}  Sctivates the potential energy smoothing methods. Several variations are available depending on the value of the modifier used: DEM= Diffusion Equation Method with a standard Gaussian kernel; GDA= Gaussian Density Annealing as proposed by the Straub group; TOPHAT= a local DEM\sphinxhyphen{}like method using a finite range “tophat” kernel; STOPHAT= shifted tophat smoothing.

\sphinxstylestrong{SOLVATE {[}ASP/SASA/ONION/STILL/HCT/ACE/GBSA{]}}  Turns on a continuum solvation free energy term during energy calculations when used with any of the standard force fields. Several algorithms are available based on the modifier used: ASP= Eisenberg\sphinxhyphen{}McLachlan ASP method using the Wesson\sphinxhyphen{}Eisenberg vacuum\sphinxhyphen{}to\sphinxhyphen{}water parameters; SASA= the Ooi\sphinxhyphen{}Scheraga SASA method; ONION= the original 1990 Still “Onion\sphinxhyphen{}shell” GB/SA method; STILL= the 1997 analytical GB/SA method from Still’s group; HCT= the pairwise descreening method of Hawkins, Cramer and Truhlar; ACE= the Analytical Continuum Electrostatics solvation method from the Karplus group; GBSA= equivalent to the STILL modifier. At present, GB/SA\sphinxhyphen{}style methods are only valid for force fields that use simple partial charge electrostatics.

\sphinxstylestrong{SOLVATETERM {[}NONE/ONLY{]}}  Controls use of the macroscopic solvation potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{SOLVENT\sphinxhyphen{}PRESSURE}

\sphinxstylestrong{SPACEGROUP {[}name{]}}  Selects the space group to be used in manipulation of crystal unit cells and asymmetric units. The name option must be chosen from one of the following currently implemented space groups: P1, P1(\sphinxhyphen{}), P21, Cc, P21/a, P21/n, P21/c, C2/c, P212121, Pna21, Pn21a, Cmc21, Pccn, Pbcn, Pbca, P41, I41/a, P4(\sphinxhyphen{})21c, P4(\sphinxhyphen{})m2, R3c, P6(3)/mcm, Fm3(\sphinxhyphen{})m, Im3(\sphinxhyphen{})m.

\sphinxstylestrong{SRAD}

\sphinxstylestrong{SRFM}

\sphinxstylestrong{STEEPEST\sphinxhyphen{}DESCENT}  Forces the L\sphinxhyphen{}BFGS optimization routine used by the MINIMIZE program and other programs to perform steepest descent minimization. This option can be useful in conjunction with small step sizes for following minimum energy paths, but is generally inferior to the L\sphinxhyphen{}BFGS default for most optimization purposes.

\sphinxstylestrong{STEPMAX {[}real{]}}  Sets via its modifying value the maximum size of an individual step during the line search phase of conjugate gradient or truncated Newton optimizations. The step size is computed as the norm of the vector of changes in parameters being optimized. The default value depends on the particular Tinker program, but is usually in the range from 1.0 to 5.0 when not specified via the STEPMAX keyword.

\sphinxstylestrong{STEPMIN {[}real{]}}  Sets via its modifying value the minimum size of an individual step during the line search phase of conjugate gradient or truncated Newton optimizations. The step size is computed as the norm of the vector of changes in parameters being optimized. The default value is usually set to about 10\sphinxhyphen{}16 when not specified via the STEPMIN keyword.

\sphinxstylestrong{STRBND {[}3 integers \& 2 reals{]}}  Provides the values for a single stretch\sphinxhyphen{}bend cross term potential parameter. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle which is to be defined. The real number modifiers give the force constant values for the first bond (first two atom classes) with the angle, and the second bond with the angle, respectively. The default units for the stretch\sphinxhyphen{}bend force constant are kcal/mole/Ang\sphinxhyphen{}degree, but this can be controlled via the STRBNDUNIT keyword.

\sphinxstylestrong{STRBNDTERM {[}NONE/ONLY{]}}  Controls use of the bond stretching\sphinxhyphen{}angle bending cross term potential energy. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{STRBNDUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the bond stretching\sphinxhyphen{}angle bending cross term potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the STRBNDUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{STRTORS {[}2 integers \& 1 real{]}}  Provides the values for a single stretch\sphinxhyphen{}torsion cross term potential parameter. The two integer modifiers give the atom class numbers for the atoms involved in the central bond of the torsional angles to be parameterized. The real modifier gives the value of the stretch\sphinxhyphen{}torsion force constant for all torsional angles with the defined central bond atom classes. The default units for the stretch\sphinxhyphen{}torsion force constant can be controlled via the STRTORUNIT keyword.

\sphinxstylestrong{STRTORTERM {[}NONE/ONLY{]}}  Controls use of the bond stretching\sphinxhyphen{}torsional angle cross term potential energy. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{STRTORUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the bond stretching\sphinxhyphen{}torsional angle cross term potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the STRTORUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{SURFACE\sphinxhyphen{}TENSION}

\sphinxstylestrong{SWIN}

\sphinxstylestrong{TAPER {[}real{]}}  Allows modification of the cutoff windows for nonbonded potential energy interactions. The nonbonded terms are smoothly reduced from their standard value at the beginning of the cutoff window to zero at the far end of the window. The far end of the window is specified via the CUTOFF keyword or its potential function specific variants. The modifier value supplied with the TAPER keyword sets the beginning of the cutoff window. The modifier can be given either as an absolute distance value in Angstroms, or as a fraction between zero and one of the CUTOFF distance. The default value in the absence of the TAPER keyword ranges from 0.65 to 0.9 of the CUTOFF distance depending on the type of potential function. The windows are implemented via polynomial\sphinxhyphen{}based switching functions, in some cases combined with energy shifting.

\sphinxstylestrong{TARGET\sphinxhyphen{}DIPOLE}

\sphinxstylestrong{TARGET\sphinxhyphen{}QUADRUPOLE}

\sphinxstylestrong{TAU\sphinxhyphen{}PRESSURE {[}real{]}}  Sets the coupling time in picoseconds for the Groningen\sphinxhyphen{}style pressure bath coupling used to control the system pressure during molecular dynamics calculations. A default value of 2.0 is used for TAU\sphinxhyphen{}PRESSURE in the absence of the keyword.

\sphinxstylestrong{TAU\sphinxhyphen{}TEMPERATURE {[}real{]}}  Sets the coupling time in picoseconds for the Groningen\sphinxhyphen{}style temperature bath coupling used to control the system temperature during molecular dynamics calculations. A default value of 0.1 is used for TAU\sphinxhyphen{}TEMPERATURE in the absence of the keyword.

\sphinxstylestrong{TCG\sphinxhyphen{}GUESS}

\sphinxstylestrong{TCG\sphinxhyphen{}NOGUESS}

\sphinxstylestrong{TCG\sphinxhyphen{}PEEK}

\sphinxstylestrong{THERMOSTAT {[}BERENDSEN/ANDERSEN{]}}  Selects a thermostat algorithm for use during molecular dynamics. Two modifiers are available, a Berendsen bath coupling method, and an Andersen stochastic collision method. The default in the absence of the THERMOSTAT keyword is to use the BERENDSEN algorithm.

\sphinxstylestrong{TORS\sphinxhyphen{}LAMBDA}

\sphinxstylestrong{TORSION {[}4 integers \& up to 6 real/real/integer triples{]}}  Provides the values for a single torsional angle parameter. The first four integer modifiers give the atom class numbers for the atoms involved in the torsional angle to be defined. Each of the remaining triples of real/real/integer modifiers give the amplitude, phase offset in degrees and periodicity of a particular torsional function term, respectively. Periodicities through 6\sphinxhyphen{}fold are allowed for torsional parameters.

\sphinxstylestrong{TORSION4 {[}4 integers \& up to 6 real/real/integer triples{]}}  Provides the values for a single torsional angle parameter specific to atoms in 4\sphinxhyphen{}membered rings. The first four integer modifiers give the atom class numbers for the atoms involved in the torsional angle to be defined. The remaining triples of real number and integer modifiers operate as described above for the TORSION keyword.

\sphinxstylestrong{TORSION5 {[}4 integers \& up to 6 real/real/integer triples{]}}  Provides the values for a single torsional angle parameter specific to atoms in 5\sphinxhyphen{}membered rings. The first four integer modifiers give the atom class numbers for the atoms involved in the torsional angle to be defined. The remaining triples of real number and integer modifiers operate as described above for the TORSION keyword.

\sphinxstylestrong{TORSIONTERM {[}NONE/ONLY{]}}  Controls use of the torsional angle potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{TORSIONUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the torsional angle potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the TORSIONUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{TORTORS {[}7 integers, then multiple lines of 2 integers and 1 real{]}}  Provides the values for a single torsion\sphinxhyphen{}torsion parameter. The first five integer modifiers give the atom class numbers for the atoms involved in the two adjacent torsional angles to be defined. The last two integer modifiers contain the number of data grid points that lie along each axis of the torsion\sphinxhyphen{}torsion map. For example, this value will be 13 for a 30 degree torsional angle spacing, i.e., 360/30 = 12, but 13 values are required since data values for \sphinxhyphen{}180 and +180 degrees must both be supplied. The subsequent lines contain the torsion\sphinxhyphen{}torsion map data as the integer values in degrees of each torsional angle and the target energy value in kcal/mole.

\sphinxstylestrong{TORTORTERM {[}NONE/ONLY{]}}  Controls use of the torsion\sphinxhyphen{}torsion potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{TORTORUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the torsion\sphinxhyphen{}torsion potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the TORTORUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{TRIAL\sphinxhyphen{}DISTANCE {[}CLASSIC/RANDOM/TRICOR/HAVEL integer/PAIRWISE integer{]}}  Sets the method for selection of a trial distance matrix during distance geometry computations. The keyword takes a modifier that selects the method to be used. The HAVEL and PAIRWISE modifiers also require an additional integer value that specifies the number of atoms used in metrization and the percentage of metrization, respectively. The default in the absence of this keyword is to use the PAIRWISE method with 100 percent metrization. Further information on the various methods is given with the description of the Tinker distance geometry program.

\sphinxstylestrong{TRIAL\sphinxhyphen{}DISTRIBUTION {[}real{]}}  Sets the initial value for the mean of the Gaussian distribution used to select trial distances between the lower and upper bounds during distance geometry computations. The value given must be between 0 and 1 which represent the lower and upper bounds respectively. This keyword is rarely needed since Tinker will usually be able to choose a reasonable value by default.

\sphinxstylestrong{TRUNCATE}  Causes all distance\sphinxhyphen{}based nonbond energy cutoffs to be sharply truncated to an energy of zero at distances greater than the value set by the cutoff keyword(s) without use of any shifting, switching or smoothing schemes. At all distances within the cutoff sphere, the full interaction energy is computed.

\sphinxstylestrong{UREY\sphinxhyphen{}CUBIC {[}real{]}}  Sets the value of the cubic term in the Taylor series expansion form of the Urey\sphinxhyphen{}Bradley potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. The default value in the absence of the UREY\sphinxhyphen{}CUBIC keyword is zero; i.e., the cubic Urey\sphinxhyphen{}Bradley term is omitted.

\sphinxstylestrong{UREY\sphinxhyphen{}QUARTIC {[}real{]}}  Sets the value of the quartic term in the Taylor series expansion form of the Urey\sphinxhyphen{}Bradley potential energy. The real number modifier gives the value of the coefficient as a multiple of the quadratic coefficient. The default value in the absence of the UREY\sphinxhyphen{}QUARTIC keyword is zero; i.e., the quartic Urey\sphinxhyphen{}Bradley term is omitted.

\sphinxstylestrong{UREYBRAD {[}3 integers \& 2 reals{]}}  Provides the values for a single Urey\sphinxhyphen{}Bradley cross term potential parameter. The integer modifiers give the atom class numbers for the three kinds of atoms involved in the angle for which a Urey\sphinxhyphen{}Bradley term is to be defined. The real number modifiers give the force constant value for the term and the target value for the 1\sphinxhyphen{}3 distance in Angstroms. The default units for the force constant are kcal/mole/Ang\textasciicircum{}2, but this can be controlled via the UREYUNIT keyword.

\sphinxstylestrong{UREYTERM {[}NONE/ONLY{]}}  Controls use of the Urey\sphinxhyphen{}Bradley potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{UREYUNIT {[}real{]}}  Sets the scale factor needed to convert the energy value computed by the Urey\sphinxhyphen{}Bradley potential into units of kcal/mole. The correct value is force field dependent and typically provided in the header of the master force field parameter file. The default value of 1.0 is used, if the UREYUNIT keyword is not given in the force field parameter file or the keyfile.

\sphinxstylestrong{USOLVE\sphinxhyphen{}BUFFER}

\sphinxstylestrong{USOLVE\sphinxhyphen{}CUTOFF}

\sphinxstylestrong{USOLVE\sphinxhyphen{}DIAG}

\sphinxstylestrong{VDW {[}1 integer \& 3 reals{]}}  Provides values for a single van der Waals parameter. The integer modifier, if positive, gives the atom class number for which vdw parameters are to be defined. Note that vdw parameters are given for atom classes, not atom types. The three real number modifiers give the values of the atom size in Angstroms, homoatomic well depth in kcal/mole, and an optional reduction factor for univalent atoms.

\sphinxstylestrong{VDW\sphinxhyphen{}12\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to van der Waals potential interactions between 1\sphinxhyphen{}2 connected atoms, i.e., atoms that are directly bonded. The default value of 0.0 is used, if the VDW\sphinxhyphen{}12\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{VDW\sphinxhyphen{}13\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to van der Waals potential interactions between 1\sphinxhyphen{}3 connected atoms, i.e., atoms separated by two covalent bonds. The default value of 0.0 is used, if the VDW\sphinxhyphen{}13\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{VDW\sphinxhyphen{}14\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to van der Waals potential interactions between 1\sphinxhyphen{}4 connected atoms, i.e., atoms separated by three covalent bonds. The default value of 1.0 is used, if the VDW\sphinxhyphen{}14\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{VDW\sphinxhyphen{}15\sphinxhyphen{}SCALE {[}real{]}}  Provides a multiplicative scale factor that is applied to van der Waals potential interactions between 1\sphinxhyphen{}5 connected atoms, i.e., atoms separated by four covalent bonds. The default value of 1.0 is used, if the VDW\sphinxhyphen{}15\sphinxhyphen{}SCALE keyword is not given in either the parameter file or the keyfile.

\sphinxstylestrong{VDW\sphinxhyphen{}ANNIHILATE}

\sphinxstylestrong{VDW\sphinxhyphen{}CORRECTION}

\sphinxstylestrong{VDW\sphinxhyphen{}CUTOFF {[}real{]}}  Sets the cutoff distance value in Angstroms for van der Waals potential energy interactions. The energy for any pair of van der Waals sites beyond the cutoff distance will be set to zero. Other keywords can be used to select a smoothing scheme near the cutoff distance. The default cutoff distance in the absence of the VDW\sphinxhyphen{}CUTOFF keyword is infinite for nonperiodic systems and 9.0 for periodic systems.

\sphinxstylestrong{VDW\sphinxhyphen{}LAMBDA}

\sphinxstylestrong{VDW\sphinxhyphen{}LIST}

\sphinxstylestrong{VDW\sphinxhyphen{}TAPER {[}real{]}}  Allows modification of the cutoff windows for van der Waals potential energy interactions. It is similar in form and action to the TAPER keyword, except that its value applies only to the vdw potential. The default value in the absence of the VDW\sphinxhyphen{}TAPER keyword is to begin the cutoff window at 0.9 of the vdw cutoff distance.

\sphinxstylestrong{VDW14 {[}1 integer \& 2 reals{]}}  Provides values for a single van der Waals parameter for use in 1\sphinxhyphen{}4 nonbonded interactions. The integer modifier, if positive, gives the atom class number for which vdw parameters are to be defined. Note that vdw parameters are given for atom classes, not atom types. The two real number modifiers give the values of the atom size in Angstroms and the homoatomic well depth in kcal/mole. Reduction factors, if used, are carried over from the VDW keyword for the same atom class.

\sphinxstylestrong{VDWINDEX}

\sphinxstylestrong{VDWPR {[}2 integers \& 2 reals{]}}  Provides the values for the vdw parameters for a single special heteroatomic pair of atoms. The integer modifiers give the pair of atom class numbers for which special vdw parameters are to be defined. The two real number modifiers give the values of the minimum energy contact distance in Angstroms and the well depth at the minimum distance in kcal/mole.

\sphinxstylestrong{VDWTERM {[}NONE/ONLY{]}}  Controls use of the van der Waals repulsion\sphinxhyphen{}dispersion potential energy term. In the absence of a modifying option, this keyword turns on use of the potential. The NONE option turns off use of this potential energy term. The ONLY option turns off all potential energy terms except for this one.

\sphinxstylestrong{VDWTYPE {[}LENNARD\sphinxhyphen{}JONES / BUCKINGHAM / BUFFERED\sphinxhyphen{}14\sphinxhyphen{}7 / MM3\sphinxhyphen{}HBOND / GAUSSIAN{]}}  Sets the functional form for the van der Waals potential energy term. The text modifier gives the name of the functional form to be used. The GAUSSIAN modifier value implements a two or four Gaussian fit to the corresponding Lennard\sphinxhyphen{}Jones function for use with potential energy smoothing schemes. The default in the absence of the VDWTYPE keyword is to use the standard two parameter Lennard\sphinxhyphen{}Jones function.

\sphinxstylestrong{VERBOSE}  Turns on printing of secondary and informational output during a variety of Tinker computations; a subset of the more extensive output provided by the DEBUG keyword.

\sphinxstylestrong{VIB\sphinxhyphen{}ROOTS}

\sphinxstylestrong{VIB\sphinxhyphen{}TOLERANCE}

\sphinxstylestrong{VOLUME\sphinxhyphen{}MOVE}

\sphinxstylestrong{VOLUME\sphinxhyphen{}SCALE}

\sphinxstylestrong{VOLUME\sphinxhyphen{}TRIAL}

\sphinxstylestrong{WALL {[}real{]}}  Sets the radius of a spherical boundary used to maintain droplet boundary conditions. The real modifier specifies the desired approximate radius of the droplet. In practice, an artificial van der Waals wall is constructed at a fixed buffer distance of 2.5 Angstroms outside the specified radius. The effect is that atoms which attempt to move outside the region defined by the droplet radius will be forced toward the center.

\sphinxstylestrong{WRITEOUT {[}integer{]}}  Sets the number of iterations between writes of intermediate results (such as the current coordinates) to disk file(s) for iterative procedures such as minimizations. The default value in the absence of the keyword is 1, i.e., the intermediate results are written to file on every iteration. Whether successive intermediate results are saved to new files or replace previously written intermediate results is controlled by the OVERWRITE and SAVE\sphinxhyphen{}CYCLE keywords.

\sphinxstylestrong{X\sphinxhyphen{}AXIS {[}real{]}}  Sets the value of the a\sphinxhyphen{}axis length for a crystal unit cell, or, equivalently, the X\sphinxhyphen{}axis length for a periodic box. The length value in Angstroms is listed after the keyword. Equivalent to the A\sphinxhyphen{}AXIS keyword.

\sphinxstylestrong{Y\sphinxhyphen{}AXIS {[}real{]}}  Sets the value of the b\sphinxhyphen{}axis length for a crystal unit cell, or, equivalently, the Y\sphinxhyphen{}axis length for a periodic box. The length value in Angstroms is listed after the keyword. If the keyword is absent, the Y\sphinxhyphen{}axis length is set equal to the X\sphinxhyphen{}axis length. Equivalent to the B\sphinxhyphen{}AXIS keyword.

\sphinxstylestrong{Z\sphinxhyphen{}AXIS {[}real{]}}  Sets the value of the c\sphinxhyphen{}axis length for a crystal unit cell, or, equivalently, the Z\sphinxhyphen{}axis length for a periodic box. The length value in Angstroms is listed after the keyword. If the keyword is absent, the Z\sphinxhyphen{}axis length is set equal to the X\sphinxhyphen{}axis length. Equivalent to the C\sphinxhyphen{}AXIS keyword.


\chapter{Routines \& Functions}
\label{\detokenize{text/routines:routines-functions}}\label{\detokenize{text/routines::doc}}
The distribution version of the Tinker package contains over 1000 separate programs, subroutines and functions. This section contains a brief description of the purpose of most of these code units. Further information can be found in the comments located at the top of each source code file.

\sphinxstylestrong{ACTIVE Subroutine}

“active” sets the list of atoms that are used during
each potential energy function calculation

\sphinxstylestrong{ADDBASE Subroutine}

“addbase” builds the Cartesian coordinates for a single nucleic
acid base; coordinates are read from the Protein Data Bank file
or found from internal coordinates, then atom types are assigned
and connectivity data generated

\sphinxstylestrong{ADDBOND Subroutine}

“addbond” adds entries to the attached atoms list in
order to generate a direct connection between two atoms

\sphinxstylestrong{ADDIONS Subroutine}

“addions” takes a currently defined solvated system and
places ions, with removal of solvent molecules

\sphinxstylestrong{ADDSIDE Subroutine}

“addside” builds the Cartesian coordinates for a single amino
acid side chain; coordinates are read from the Protein Data
Bank file or found from internal coordinates, then atom types
are assigned and connectivity data generated

\sphinxstylestrong{ADJACENT Function}

“adjacent” finds an atom connected to atom “i1” other than
atom “i2”; if no such atom exists, then the closest atom
in space is returned

\sphinxstylestrong{ADJUST Subroutine}

“adjust” modifies site bounds on the PME grid and returns
an offset into the B\sphinxhyphen{}spline coefficient arrays

\sphinxstylestrong{ALCHEMY Program}

“alchemy” computes the free energy difference corresponding
to a small perturbation by Boltzmann weighting the potential
energy difference over a number of sample states; current
version (incorrectly) considers the charge energy to be
intermolecular in finding the perturbation energies

\sphinxstylestrong{ALTELEC Subroutine}

“altelec” constructs mutated electrostatic parameters based
on the lambda mutation parameter “elambda”

\sphinxstylestrong{ALTERCHG Subroutine}

“alterchg” calculates the change in atomic partial charge or
monopole values due to bond and angle charge flux coupling

\sphinxstylestrong{ALTERPOL Subroutine}

“alterpol” finds an output set of atomic multipole parameters
which when used with an intergroup polarization model will
give the same electrostatic potential around the molecule as
the input set of multipole parameters with all atoms in one
polarization group

\sphinxstylestrong{ALTTORS Subroutine}

“alttors” constructs mutated torsional parameters based
on the lambda mutation parameter “tlambda”

\sphinxstylestrong{AMBERYZE Subroutine}

“amberyze” prints the force field parameters in a format needed
by the Amber setup protocol for using AMOEBA within Amber

\sphinxstylestrong{ANALYSIS Subroutine}

“analysis” calls the series of routines needed to calculate
the potential energy and perform energy partitioning analysis
in terms of type of interaction or atom number

\sphinxstylestrong{ANALYZE Program}

“analyze” computes and displays the total potential energy;
options are provided to display system and force field info,
partition the energy by atom or by potential function type,
show force field parameters by atom; output the large energy
interactions and find electrostatic and inertial properties

\sphinxstylestrong{ANGCHG Subroutine}

“angchg” computes modifications to atomic partial charges or
monopoles due to angle bending using a charge flux formulation

\sphinxstylestrong{ANGGUESS Function}

“angguess” sets approximate angle bend force constants based
on atom type and connected atoms

\sphinxstylestrong{ANGLES Subroutine}

“angles” finds the total number of bond angles and stores
the atom numbers of the atoms defining each angle; for
each angle to a trivalent central atom, the third bonded
atom is stored for use in out\sphinxhyphen{}of\sphinxhyphen{}plane bending

\sphinxstylestrong{ANNEAL Program}

“anneal” performs a simulated annealing protocol by means of
variable temperature molecular dynamics using either linear,
exponential or sigmoidal cooling schedules

\sphinxstylestrong{ANORM Function}

“anorm” finds the norm (length) of a vector; used as a
service routine by the Connolly surface area and volume
computation

\sphinxstylestrong{APBSEMPOLE Subroutine}

\sphinxstylestrong{APBSFINAL Subroutine}

\sphinxstylestrong{APBSINDUCE Subroutine}

\sphinxstylestrong{APBSINITIAL Subroutine}

\sphinxstylestrong{APBSNLINDUCE Subroutine}

\sphinxstylestrong{ARCHIVE Program}

“archive” is a utility program for coordinate files which
concatenates multiple coordinate sets into a new archive or
performs any of several manipulations on an existing archive

\sphinxstylestrong{ASET Subroutine}

“aset” computes by recursion the A functions used in the
evaluation of Slater\sphinxhyphen{}type (STO) overlap integrals

\sphinxstylestrong{ATOMYZE Subroutine}

“atomyze” prints the potential energy components broken
down by atom and to a choice of precision

\sphinxstylestrong{ATTACH Subroutine}

“attach” generates lists of 1\sphinxhyphen{}3, 1\sphinxhyphen{}4 and 1\sphinxhyphen{}5 connectivities
starting from the previously determined list of attached
atoms (ie, 1\sphinxhyphen{}2 connectivity)

\sphinxstylestrong{AUXINIT Subroutine}

“auxinit” initializes auxiliary variables and settings for
inertial extended Lagrangian induced dipole prediction

\sphinxstylestrong{AVGPOLE Subroutine}

“avgpole” condenses the number of multipole atom types based
upon atoms with equivalent attachments and additional user
specified sets of equivalent atoms

\sphinxstylestrong{BAOAB Subroutine}

“baoab” implements a constrained stochastic dynamics time
step using the geodesic BAOAB scheme

\sphinxstylestrong{BAR Program}

“bar” computes the free energy, enthalpy and entropy difference
between two states via Zwanzig free energy perturbation (FEP)
and Bennett acceptance ratio (BAR) methods

\sphinxstylestrong{BARCALC Subroutine}

\sphinxstylestrong{BASEFILE Subroutine}

“basefile” extracts from an input filename the portion
consisting of any directory name and the base filename;
also reads any keyfile and sets information level values

\sphinxstylestrong{BCUCOF Subroutine}

“bcucof” determines the coefficient matrix needed for bicubic
interpolation of a function, gradients and cross derivatives

\sphinxstylestrong{BCUINT Subroutine}

“bcuint” performs a bicubic interpolation of the function
value on a 2D spline grid

\sphinxstylestrong{BCUINT1 Subroutine}

“bcuint1” performs a bicubic interpolation of the function
value and gradient along the directions of a 2D spline grid

\sphinxstylestrong{BCUINT2 Subroutine}

“bcuint2” performs a bicubic interpolation of the function value,
gradient and Hessian along the directions of a 2D spline grid

\sphinxstylestrong{BEEMAN Subroutine}

“beeman” performs a single molecular dynamics time step
via the Beeman multistep recursion formula; uses original
coefficients or Bernie Brooks’ “Better Beeman” values

\sphinxstylestrong{BETACF Function}

“betacf” computes a rapidly convergent continued fraction needed
by routine “betai” to evaluate the cumulative Beta distribution

\sphinxstylestrong{BETAI Function}

“betai” evaluates the cumulative Beta distribution function
as the probability that a random variable from a distribution
with Beta parameters “a” and “b” will be less than “x”

\sphinxstylestrong{BIGBLOCK Subroutine}

“bigblock” replicates the coordinates of a single unit cell
to give a larger unit cell as a block of repeated units

\sphinxstylestrong{BIOSORT Subroutine}

“biosort” renumbers and formats biotype parameters used to
convert biomolecular structure into force field atom types

\sphinxstylestrong{BITORS Subroutine}

“bitors” finds the total number of bitorsions as pairs
of adjacent torsional angles, and the numbers of the five
atoms defining each bitorsion

\sphinxstylestrong{BMAX Function}

“bmax” computes the maximum order of the B functions needed
for evaluation of Slater\sphinxhyphen{}type (STO) overlap integrals

\sphinxstylestrong{BNDCHG Subroutine}

“bndchg” computes modifications to atomic partial charges or
monopoles due to bond stretch using a charge flux formulation

\sphinxstylestrong{BNDERR Function}

“bnderr” is the distance bound error function and derivatives;
this version implements the original and Havel’s normalized
lower bound penalty, the normalized version is preferred when
lower bounds are small (as with NMR NOE restraints), the
original penalty is needed if large lower bounds are present

\sphinxstylestrong{BNDGUESS Function}

“bndguess” sets approximate bond stretch force constants based
on atom type and connected atoms

\sphinxstylestrong{BONDS Subroutine}

“bonds” finds the total number of covalent bonds and
stores the atom numbers of the atoms defining each bond

\sphinxstylestrong{BORN Subroutine}

“born” computes the Born radius of each atom for use with
the various implicit solvation models

\sphinxstylestrong{BORN1 Subroutine}

“born1” computes derivatives of the Born radii with respect
to atomic coordinates and increments total energy derivatives
and virial components for potentials involving Born radii

\sphinxstylestrong{BOUNDS Subroutine}

“bounds” finds the center of mass of each molecule and
translates any stray molecules back into the periodic box

\sphinxstylestrong{BOXMIN Subroutine}

“boxmin” uses minimization of valence and vdw potential energy
to expand and refine a collection of solvent molecules in a
periodic box

\sphinxstylestrong{BOXMIN1 Function}

“boxmin1” is a service routine that computes the energy and
gradient during refinement of a periodic box

\sphinxstylestrong{BSET Subroutine}

“bset” computes by downward recursion the B functions used
in the evaluation of Slater\sphinxhyphen{}type (STO) overlap integrals

\sphinxstylestrong{BSPLGEN Subroutine}

“bsplgen” gets B\sphinxhyphen{}spline coefficients and derivatives for
a single PME atomic site along a particular direction

\sphinxstylestrong{BSPLINE Subroutine}

“bspline” calculates the coefficients for an n\sphinxhyphen{}th order
B\sphinxhyphen{}spline approximation

\sphinxstylestrong{BSPLINE\_FILL Subroutine}

“bspline\_fill” finds B\sphinxhyphen{}spline coefficients and derivatives
for PME atomic sites along the fractional coordinate axes

\sphinxstylestrong{BSSTEP Subroutine}

“bsstep” takes a single Bulirsch\sphinxhyphen{}Stoer step with monitoring
of local truncation error to ensure accuracy

\sphinxstylestrong{BUSSI Subroutine}

“bussi” performs a single molecular dynamics time step via
the Bussi\sphinxhyphen{}Parrinello isothermal\sphinxhyphen{}isobaric algorithm

\sphinxstylestrong{CALENDAR Subroutine}

“calendar” returns the current time as a set of integer values
representing the year, month, day, hour, minute and second

\sphinxstylestrong{CART\_TO\_FRAC Subroutine}

“cart\_to\_frac” computes a transformation matrix to convert
a multipole object in Cartesian coordinates to fractional

\sphinxstylestrong{CBUILD Subroutine}

“cbuild” performs a complete rebuild of the partial charge
electrostatic neighbor list for all sites

\sphinxstylestrong{CELLANG Subroutine}

“cellang” computes atomic coordinates and unit cell parameters
from fractional coordinates and lattice vectors

\sphinxstylestrong{CELLATOM Subroutine}

“cellatom” completes the addition of a symmetry related atom
to a unit cell by updating the atom type and attachment arrays

\sphinxstylestrong{CENTER Subroutine}

“center” moves the weighted centroid of each coordinate
set to the origin during least squares superposition

\sphinxstylestrong{CERROR Subroutine}

“cerror” is the error handling routine for the Connolly
surface area and volume computation

\sphinxstylestrong{CFFTB Subroutine}

“cfftb” computes the backward complex discrete Fourier
transform, the Fourier synthesis

\sphinxstylestrong{CFFTB1 Subroutine}

\sphinxstylestrong{CFFTF Subroutine}

“cfftf” computes the forward complex discrete Fourier
transform, the Fourier analysis

\sphinxstylestrong{CFFTF1 Subroutine}

\sphinxstylestrong{CFFTI Subroutine}

“cffti” initializes arrays used in both forward and backward
transforms; “ifac” is the prime factorization of “n”, and
“wsave” contains a tabulation of trigonometric functions

\sphinxstylestrong{CFFTI1 Subroutine}

\sphinxstylestrong{CHIRER Function}

“chirer” computes the chirality error and its derivatives
with respect to atomic Cartesian coordinates as a sum the
squares of deviations of chiral volumes from target values

\sphinxstylestrong{CHKANGLE Subroutine}

“chkangle” tests angles to be constrained for their presence
in small rings and removes constraints that are redundant

\sphinxstylestrong{CHKAROM Function}

“chkatom” tests for the presence of a specified atom as a
member of an aromatic ring

\sphinxstylestrong{CHKPOLE Subroutine}

“chkpole” inverts atomic multipole moments as necessary
at sites with chiral local reference frame definitions

\sphinxstylestrong{CHKRING Subroutine}

“chkring” tests an atom or a set of connected atoms for
their presence within a single 3\sphinxhyphen{} to 6\sphinxhyphen{}membered ring

\sphinxstylestrong{CHKSIZE Subroutine}

“chksize” computes a measure of overall global structural
expansion or compaction from the number of excess upper
or lower bounds matrix violations

\sphinxstylestrong{CHKSOCKET Subroutine}

\sphinxstylestrong{CHKTREE Subroutine}

“chktree” tests a minimum energy structure to see if it
belongs to the correct progenitor in the existing map

\sphinxstylestrong{CHKTTOR Subroutine}

“chkttor” tests the attached atoms at a torsion\sphinxhyphen{}torsion central
site and inverts the angle values if the site is chiral

\sphinxstylestrong{CHKXYZ Subroutine}

“chkxyz” finds any pairs of atoms with identical Cartesian
coordinates, and prints a warning message

\sphinxstylestrong{CHOLESKY Subroutine}

“cholesky” uses a modified Cholesky method to solve the linear
system Ax = b, returning “x” in “b”; “A” is a real symmetric
positive definite matrix with its upper triangle (including the
diagonal) stored by rows

\sphinxstylestrong{CIRPLN Subroutine}

“cirpln” determines the points of intersection between a
specified circle and plane

\sphinxstylestrong{CJKM Function}

“cjkm” computes the coefficients of spherical harmonics
expressed in prolate spheroidal coordinates

\sphinxstylestrong{CLIGHT Subroutine}

“clight” performs a complete rebuild of the partial charge
pair neighbor list for all sites using the method of lights

\sphinxstylestrong{CLIMBER Subroutine}

\sphinxstylestrong{CLIMBRGD Subroutine}

\sphinxstylestrong{CLIMBROT Subroutine}

\sphinxstylestrong{CLIMBTOR Subroutine}

\sphinxstylestrong{CLIMBXYZ Subroutine}

\sphinxstylestrong{CLIST Subroutine}

“clist” performs an update or a complete rebuild of the
nonbonded neighbor lists for partial charges

\sphinxstylestrong{CLUSTER Subroutine}

“cluster” gets the partitioning of the system into groups
and stores a list of the group to which each atom belongs

\sphinxstylestrong{CMP\_TO\_FMP Subroutine}

“cmp\_to\_fmp” transforms the atomic multipoles from Cartesian
to fractional coordinates

\sphinxstylestrong{COLUMN Subroutine}

“column” takes the off\sphinxhyphen{}diagonal Hessian elements stored
as sparse rows and sets up indices to allow column access

\sphinxstylestrong{COMMAND Subroutine}

“command” uses the standard Unix\sphinxhyphen{}like iargc/getarg routines
to get the number and values of arguments specified on the
command line at program runtime

\sphinxstylestrong{COMPRESS Subroutine}

“compress” transfers only the non\sphinxhyphen{}buried tori from
the temporary tori arrays to the final tori arrays

\sphinxstylestrong{CONNECT Subroutine}

“connect” sets up the attached atom arrays
starting from a set of internal coordinates

\sphinxstylestrong{CONNOLLY Subroutine}

“connolly” uses the algorithms from the AMS/VAM programs of
Michael Connolly to compute the analytical molecular surface
area and volume of a collection of spherical atoms; thus
it implements Fred Richards’ molecular surface definition as
a set of analytically defined spherical and toroidal polygons

\sphinxstylestrong{CONNYZE Subroutine}

“connyze” prints information onconnected atoms as lists
of all atom pairs that are 1\sphinxhyphen{}2 through 1\sphinxhyphen{}5 interactions

\sphinxstylestrong{CONTACT Subroutine}

“contact” constructs the contact surface, cycles and convex faces

\sphinxstylestrong{CONTROL Subroutine}

“control” gets initial values for parameters that determine
the output style and information level provided by Tinker

\sphinxstylestrong{COORDS Subroutine}

“coords” converts the three principal eigenvalues/vectors from
the metric matrix into atomic coordinates, and calls a routine
to compute the rms deviation from the bounds

\sphinxstylestrong{CORRELATE Program}

“correlate” computes the time correlation function of some
user\sphinxhyphen{}supplied property from individual snapshot frames taken
from a molecular dynamics or other trajectory

\sphinxstylestrong{CREATEJVM Subroutine}

\sphinxstylestrong{CREATESERVER Subroutine}

\sphinxstylestrong{CREATESYSTEM Subroutine}

\sphinxstylestrong{CREATEUPDATE Subroutine}

\sphinxstylestrong{CRYSTAL Program}

“crystal” is a utility which converts between fractional and
Cartesian coordinates, and can generate full unit cells from
asymmetric units

\sphinxstylestrong{CSPLINE Subroutine}

“cspline” computes the coefficients for a periodic interpolating
cubic spline

\sphinxstylestrong{CUTOFFS Subroutine}

“cutoffs” initializes and stores spherical energy cutoff
distance windows, Hessian element and Ewald sum cutoffs,
and allocates pairwise neighbor lists

\sphinxstylestrong{CYTSY Subroutine}

“cytsy” solves a system of linear equations for a cyclically
tridiagonal, symmetric, positive definite matrix

\sphinxstylestrong{CYTSYP Subroutine}

“cytsyp” finds the Cholesky factors of a cyclically tridiagonal
symmetric, positive definite matrix given by two vectors

\sphinxstylestrong{CYTSYS Subroutine}

“cytsys” solves a cyclically tridiagonal linear system
given the Cholesky factors

\sphinxstylestrong{D1D2 Function}

“d1d2” is a utility function used in computation of the
reaction field recursive summation elements

\sphinxstylestrong{DAMPDIR Subroutine}

“dampdir” generates coefficients for the direct field damping
function for powers of the interatomic distance

\sphinxstylestrong{DAMPEWALD Subroutine}

“dampewald” generates coefficients for Ewald error function
damping for powers of the interatomic distance

\sphinxstylestrong{DAMPMUT Subroutine}

“dampmut” generates coefficients for the mutual field damping
function for powers of the interatomic distance

\sphinxstylestrong{DAMPPOLAR Subroutine}

“damppolar” generates coefficients for the charge penetration
damping function used for polarization interactions

\sphinxstylestrong{DAMPPOLE Subroutine}

“damppole” generates coefficients for the charge penetration
damping function for powers of the interatomic distance

\sphinxstylestrong{DAMPPOT Subroutine}

“damppot” generates coefficients for the charge penetration
damping function used for the electrostatic potential

\sphinxstylestrong{DAMPREP Subroutine}

“damprep” generates coefficients for the Pauli repulsion
damping function for powers of the interatomic distance

\sphinxstylestrong{DAMPTHOLE Subroutine}

“dampthole” generates coefficients for the Thole damping
function for powers of the interatomic distance

\sphinxstylestrong{DBUILD Subroutine}

“dbuild” performs a complete rebuild of the damped dispersion
neighbor list for all sites

\sphinxstylestrong{DCFLUX Subroutine}

“dcflux” takes as input the electrostatic potential at each
atomic site and calculates gradient chain rule corrections due
to charge flux coupled with bond stretching and angle bending

\sphinxstylestrong{DEFLATE Subroutine}

“deflate” uses the power method with deflation to compute the
few largest eigenvalues and eigenvectors of a symmetric matrix

\sphinxstylestrong{DELETE Subroutine}

“delete” removes a specified atom from the Cartesian
coordinates list and shifts the remaining atoms

\sphinxstylestrong{DEPTH Function}

\sphinxstylestrong{DESTROYJVM Subroutine}

\sphinxstylestrong{DESTROYSERVER Subroutine}

\sphinxstylestrong{DFIELD0A Subroutine}

“dfield0a” computes the direct electrostatic field due to
permanent multipole moments via a double loop

\sphinxstylestrong{DFIELD0B Subroutine}

“dfield0b” computes the direct electrostatic field due to
permanent multipole moments via a pair list

\sphinxstylestrong{DFIELD0C Subroutine}

“dfield0c” computes the mutual electrostatic field due to
permanent multipole moments via Ewald summation

\sphinxstylestrong{DFIELD0D Subroutine}

“dfield0d” computes the direct electrostatic field due to
permanent multipole moments for use with with generalized
Kirkwood implicit solvation

\sphinxstylestrong{DFIELD0E Subroutine}

“dfield0e” computes the direct electrostatic field due to
permanent multipole moments for use with in Poisson\sphinxhyphen{}Boltzmann

\sphinxstylestrong{DFIELDI Subroutine}

“dfieldi” computes the electrostatic field due to permanent
multipole moments

\sphinxstylestrong{DFTMOD Subroutine}

“dftmod” computes the modulus of the discrete Fourier transform
of “bsarray” and stores it in “bsmod”

\sphinxstylestrong{DIAGBLK Subroutine}

“diagblk” performs diagonalization of the Hessian for a
block of atoms within a larger system

\sphinxstylestrong{DIAGQ Subroutine}

“diagq” is a matrix diagonalization routine which is derived
from the classical given, housec, and eigen algorithms with
several modifications to increase efficiency and accuracy

\sphinxstylestrong{DIFFEQ Subroutine}

“diffeq” performs the numerical integration of an ordinary
differential equation using an adaptive stepsize method to
solve the corresponding coupled first\sphinxhyphen{}order equations of the
general form dyi/dx = f(x,y1,…,yn) for yi = y1,…,yn

\sphinxstylestrong{DIFFUSE Program}

“diffuse” finds the self\sphinxhyphen{}diffusion constant for a homogeneous
liquid via the Einstein relation from a set of stored molecular
dynamics frames; molecular centers of mass are unfolded and mean
squared displacements are computed versus time separation

\sphinxstylestrong{DIST2 Function}

“dist2” finds the distance squared between two points; used
as a service routine by the Connolly surface area and volume
computation

\sphinxstylestrong{DISTGEOM Program}

“distgeom” uses a metric matrix distance geometry procedure to
generate structures with interpoint distances that lie within
specified bounds, with chiral centers that maintain chirality,
and with torsional angles restrained to desired values; the
user also has the ability to interactively inspect and alter
the triangle smoothed bounds matrix prior to embedding

\sphinxstylestrong{DLIGHT Subroutine}

“dlight” performs a complete rebuild of the damped dispersion
pair neighbor list for all sites using the method of lights

\sphinxstylestrong{DLIST Subroutine}

“dlist” performs an update or a complete rebuild of the
nonbonded neighbor lists for damped dispersion sites

\sphinxstylestrong{DMDUMP Subroutine}

“dmdump” puts the distance matrix of the final structure
into the upper half of a matrix, the distance of each atom
to the centroid on the diagonal, and the individual terms
of the bounds errors into the lower half of the matrix

\sphinxstylestrong{DOCUMENT Program}

“document” generates a formatted description of all the routines
and modules, an index of routines called by each source file, a
list of all valid keywords, a list of include file dependencies
as needed by a Unix\sphinxhyphen{}style Makefile, or a formatted force field
parameter summary

\sphinxstylestrong{DOT Function}

“dot” finds the dot product of two vectors

\sphinxstylestrong{DSTMAT Subroutine}

“dstmat” selects a distance matrix containing values between
the previously smoothed upper and lower bounds; the distance
values are chosen from uniform distributions, in a triangle
correlated fashion, or using random partial metrization

\sphinxstylestrong{DYNAMIC Program}

“dynamic” computes a molecular or stochastic dynamics trajectory
in one of the standard statistical mechanical ensembles and using
any of several possible integration methods

\sphinxstylestrong{EANGANG Subroutine}

“eangang” calculates the angle\sphinxhyphen{}angle potential energy

\sphinxstylestrong{EANGANG1 Subroutine}

“eangang1” calculates the angle\sphinxhyphen{}angle potential energy and
first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EANGANG2 Subroutine}

“eangang2” calculates the angle\sphinxhyphen{}angle potential energy
second derivatives with respect to Cartesian coordinates
using finite difference methods

\sphinxstylestrong{EANGANG2A Subroutine}

“eangang2a” calculates the angle\sphinxhyphen{}angle first derivatives for
a single interaction with respect to Cartesian coordinates;
used in computation of finite difference second derivatives

\sphinxstylestrong{EANGANG3 Subroutine}

“eangang3” calculates the angle\sphinxhyphen{}angle potential energy;
also partitions the energy among the atoms

\sphinxstylestrong{EANGLE Subroutine}

“eangle” calculates the angle bending potential energy;
projected in\sphinxhyphen{}plane angles at trigonal centers, special
linear or Fourier angle bending terms are optionally used

\sphinxstylestrong{EANGLE1 Subroutine}

“eangle1” calculates the angle bending potential energy and
the first derivatives with respect to Cartesian coordinates;
projected in\sphinxhyphen{}plane angles at trigonal centers, special linear
or Fourier angle bending terms are optionally used

\sphinxstylestrong{EANGLE2 Subroutine}

“eangle2” calculates second derivatives of the angle bending
energy for a single atom using a mixture of analytical and
finite difference methods; projected in\sphinxhyphen{}plane angles at trigonal
centers, special linear or Fourier angle bending terms are
optionally used

\sphinxstylestrong{EANGLE2A Subroutine}

“eangle2a” calculates bond angle bending potential energy
second derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EANGLE2B Subroutine}

“eangle2b” computes projected in\sphinxhyphen{}plane bending first derivatives
for a single angle with respect to Cartesian coordinates;
used in computation of finite difference second derivatives

\sphinxstylestrong{EANGLE3 Subroutine}

“eangle3” calculates the angle bending potential energy, also
partitions the energy among the atoms; projected in\sphinxhyphen{}plane
angles at trigonal centers, spceial linear or Fourier angle
bending terms are optionally used

\sphinxstylestrong{EANGTOR Subroutine}

“eangtor” calculates the angle\sphinxhyphen{}torsion potential energy

\sphinxstylestrong{EANGTOR1 Subroutine}

“eangtor1” calculates the angle\sphinxhyphen{}torsion energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EANGTOR2 Subroutine}

“eangtor2” calculates the angle\sphinxhyphen{}torsion potential energy
second derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EANGTOR3 Subroutine}

“eangtor3” calculates the angle\sphinxhyphen{}torsion potential energy;
also partitions the energy terms among the atoms

\sphinxstylestrong{EBOND Subroutine}

“ebond” calculates the bond stretching energy

\sphinxstylestrong{EBOND1 Subroutine}

“ebond1” calculates the bond stretching energy and
first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EBOND2 Subroutine}

“ebond2” calculates second derivatives of the bond
stretching energy for a single atom at a time

\sphinxstylestrong{EBOND3 Subroutine}

“ebond3” calculates the bond stretching energy; also
partitions the energy among the atoms

\sphinxstylestrong{EBUCK Subroutine}

“ebuck” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy

\sphinxstylestrong{EBUCK0A Subroutine}

“ebuck0a” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
using a pairwise double loop

\sphinxstylestrong{EBUCK0B Subroutine}

“ebuck0b” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
using the method of lights

\sphinxstylestrong{EBUCK0C Subroutine}

“ebuck0c” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
using a pairwise neighbor list

\sphinxstylestrong{EBUCK0D Subroutine}

“ebuck0d” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
via a Gaussian approximation for potential energy smoothing

\sphinxstylestrong{EBUCK1 Subroutine}

“ebuck1” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and its first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EBUCK1A Subroutine}

“ebuck1a” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and its first derivatives using a pairwise double loop

\sphinxstylestrong{EBUCK1B Subroutine}

“ebuck1b” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and its first derivatives using the method of lights

\sphinxstylestrong{EBUCK1C Subroutine}

“ebuck1c” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and its first derivatives using a pairwise neighbor list

\sphinxstylestrong{EBUCK1D Subroutine}

“ebuck1d” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and its first derivatives via a Gaussian approximation for
potential energy smoothing

\sphinxstylestrong{EBUCK2 Subroutine}

“ebuck2” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals
second derivatives for a single atom at a time

\sphinxstylestrong{EBUCK2A Subroutine}

“ebuck2a” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals second
derivatives using a double loop over relevant atom pairs

\sphinxstylestrong{EBUCK2B Subroutine}

“ebuck2b” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals second
derivatives via a Gaussian approximation for use with potential
energy smoothing

\sphinxstylestrong{EBUCK3 Subroutine}

“ebuck3” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and partitions the energy among the atoms

\sphinxstylestrong{EBUCK3A Subroutine}

“ebuck3a” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals
energy and partitions the energy among the atoms using
a pairwise double loop

\sphinxstylestrong{EBUCK3B Subroutine}

“ebuck3b” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals
energy and also partitions the energy among the atoms using
the method of lights

\sphinxstylestrong{EBUCK3C Subroutine}

“ebuck3c” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
and also partitions the energy among the atoms using a pairwise
neighbor list

\sphinxstylestrong{EBUCK3D Subroutine}

“ebuck3d” calculates the Buckingham exp\sphinxhyphen{}6 van der Waals energy
via a Gaussian approximation for potential energy smoothing

\sphinxstylestrong{ECHARGE Subroutine}

“echarge” calculates the charge\sphinxhyphen{}charge interaction energy

\sphinxstylestrong{ECHARGE0A Subroutine}

“echarge0a” calculates the charge\sphinxhyphen{}charge interaction energy
using a pairwise double loop

\sphinxstylestrong{ECHARGE0B Subroutine}

“echarge0b” calculates the charge\sphinxhyphen{}charge interaction energy
using the method of lights

\sphinxstylestrong{ECHARGE0C Subroutine}

“echarge0c” calculates the charge\sphinxhyphen{}charge interaction energy
using a pairwise neighbor list

\sphinxstylestrong{ECHARGE0D Subroutine}

“echarge0d” calculates the charge\sphinxhyphen{}charge interaction energy
using a particle mesh Ewald summation

\sphinxstylestrong{ECHARGE0E Subroutine}

“echarge0e” calculates the charge\sphinxhyphen{}charge interaction energy
using a particle mesh Ewald summation and the method of lights

\sphinxstylestrong{ECHARGE0F Subroutine}

“echarge0f” calculates the charge\sphinxhyphen{}charge interaction energy
using a particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{ECHARGE0G Subroutine}

“echarge0g” calculates the charge\sphinxhyphen{}charge interaction energy
for use with potential smoothing methods

\sphinxstylestrong{ECHARGE1 Subroutine}

“echarge1” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ECHARGE1A Subroutine}

“echarge1a” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
using a pairwise double loop

\sphinxstylestrong{ECHARGE1B Subroutine}

“echarge1b” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
using the method of lights

\sphinxstylestrong{ECHARGE1C Subroutine}

“echarge1c” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
using a pairwise neighbor list

\sphinxstylestrong{ECHARGE1D Subroutine}

“echarge1d” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
using a particle mesh Ewald summation

\sphinxstylestrong{ECHARGE1E Subroutine}

“echarge1e” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
using a particle mesh Ewald summation and the method of lights

\sphinxstylestrong{ECHARGE1F Subroutine}

“echarge1f” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
using a particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{ECHARGE1G Subroutine}

“echarge1g” calculates the charge\sphinxhyphen{}charge interaction energy
and first derivatives with respect to Cartesian coordinates
for use with potential smoothing methods

\sphinxstylestrong{ECHARGE2 Subroutine}

“echarge2” calculates second derivatives of the
charge\sphinxhyphen{}charge interaction energy for a single atom

\sphinxstylestrong{ECHARGE2A Subroutine}

“echarge2a” calculates second derivatives of the charge\sphinxhyphen{}charge
interaction energy for a single atom using a pairwise loop

\sphinxstylestrong{ECHARGE2B Subroutine}

“echarge2b” calculates second derivatives of the charge\sphinxhyphen{}charge
interaction energy for a single atom using a neighbor list

\sphinxstylestrong{ECHARGE2C Subroutine}

“echarge2c” calculates second derivatives of the reciprocal
space charge\sphinxhyphen{}charge interaction energy for a single atom using
a particle mesh Ewald summation via numerical differentiation

\sphinxstylestrong{ECHARGE2D Subroutine}

“echarge2d” calculates second derivatives of the real space
charge\sphinxhyphen{}charge interaction energy for a single atom using a
pairwise loop

\sphinxstylestrong{ECHARGE2E Subroutine}

“echarge2e” calculates second derivatives of the real space
charge\sphinxhyphen{}charge interaction energy for a single atom using a
pairwise neighbor list

\sphinxstylestrong{ECHARGE2F Subroutine}

“echarge2f” calculates second derivatives of the charge\sphinxhyphen{}charge
interaction energy for a single atom for use with potential
smoothing methods

\sphinxstylestrong{ECHARGE2R Subroutine}

“echarge2r” computes reciprocal space charge\sphinxhyphen{}charge first
derivatives; used to get finite difference second derivatives

\sphinxstylestrong{ECHARGE3 Subroutine}

“echarge3” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms

\sphinxstylestrong{ECHARGE3A Subroutine}

“echarge3a” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms using a pairwise
double loop

\sphinxstylestrong{ECHARGE3B Subroutine}

“echarge3b” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms using the method
of lights

\sphinxstylestrong{ECHARGE3C Subroutine}

“echarge3c” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms using a pairwise
neighbor list

\sphinxstylestrong{ECHARGE3D Subroutine}

“echarge3d” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms using a particle
mesh Ewald summation

\sphinxstylestrong{ECHARGE3E Subroutine}

“echarge3e” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms using a particle
mesh Ewald summation and the method of lights

\sphinxstylestrong{ECHARGE3F Subroutine}

“echarge3f” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms using a particle
mesh Ewald summation and a pairwise neighbor list

\sphinxstylestrong{ECHARGE3G Subroutine}

“echarge3g” calculates the charge\sphinxhyphen{}charge interaction energy
and partitions the energy among the atoms for use with
potential smoothing methods

\sphinxstylestrong{ECHGDPL Subroutine}

“echgdpl” calculates the charge\sphinxhyphen{}dipole interaction energy

\sphinxstylestrong{ECHGDPL1 Subroutine}

“echgdpl1” calculates the charge\sphinxhyphen{}dipole interaction energy
and first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ECHGDPL2 Subroutine}

“echgdpl2” calculates second derivatives of the
charge\sphinxhyphen{}dipole interaction energy for a single atom

\sphinxstylestrong{ECHGDPL3 Subroutine}

“echgdpl3” calculates the charge\sphinxhyphen{}dipole interaction energy;
also partitions the energy among the atoms

\sphinxstylestrong{ECHGTRN Subroutine}

“echgtrn” calculates the charge transfer potential energy

\sphinxstylestrong{ECHGTRN0A Subroutine}

“echgtrn0a” calculates the charge transfer interaction energy
using a double loop

\sphinxstylestrong{ECHGTRN0B Subroutine}

“echgtrn0b” calculates the charge transfer interaction energy
using the method of lights

\sphinxstylestrong{ECHGTRN0C Subroutine}

“echgtrn0c” calculates the charge transfer interaction energy
using a neighbor list

\sphinxstylestrong{ECHGTRN1 Subroutine}

“echgtrn1” calculates the charge transfer energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ECHGTRN1A Subroutine}

“echgtrn1a” calculates the charge transfer interaction energy
and first derivatives using a double loop

\sphinxstylestrong{ECHGTRN1B Subroutine}

“echgtrn1b” calculates the charge transfer energy and first
derivatives using a pairwise neighbor list

\sphinxstylestrong{ECHGTRN2 Subroutine}

“echgtrn2” calculates the second derivatives of the charge
transfer energy using a double loop over relevant atom pairs

\sphinxstylestrong{ECHGTRN3 Subroutine}

“echgtrn3” calculates the charge transfer energy; also partitions
the energy among the atoms

\sphinxstylestrong{ECHGTRN3A Subroutine}

“echgtrn3a” calculates the charge transfer interaction energy
and also partitions the energy among the atoms using a pairwise
double loop

\sphinxstylestrong{ECHGTRN3B Subroutine}

“echgtrn3b” calculates the charge transfer interaction energy
and also partitions the energy among the atoms using the method
of lights

\sphinxstylestrong{ECHGTRN3C Subroutine}

“echgtrn3c” calculates the charge transfer interaction energy
and also partitions the energy among the atoms using a pairwise
neighbor list

\sphinxstylestrong{ECRECIP Subroutine}

“ecrecip” evaluates the reciprocal space portion of the particle
mesh Ewald energy due to partial charges

\sphinxstylestrong{ECRECIP1 Subroutine}

“ecrecip1” evaluates the reciprocal space portion of the particle
mesh Ewald summation energy and gradient due to partial charges

\sphinxstylestrong{EDIFF Subroutine}

“ediff” calculates the energy of polarizing the vacuum induced
dipoles to their SCRF polarized values

\sphinxstylestrong{EDIFF1A Subroutine}

“ediff1a” calculates the energy and derivatives of polarizing
the vacuum induced dipoles to their SCRF polarized values using
a double loop

\sphinxstylestrong{EDIFF1B Subroutine}

“ediff1b” calculates the energy and derivatives of polarizing
the vacuum induced dipoles to their SCRF polarized values using
a neighbor list

\sphinxstylestrong{EDIFF3 Subroutine}

“ediff3” calculates the energy of polarizing the vacuum induced
dipoles to their generalized Kirkwood values with energy analysis

\sphinxstylestrong{EDIPOLE Subroutine}

“edipole” calculates the dipole\sphinxhyphen{}dipole interaction energy

\sphinxstylestrong{EDIPOLE1 Subroutine}

“edipole1” calculates the dipole\sphinxhyphen{}dipole interaction energy
and first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EDIPOLE2 Subroutine}

“edipole2” calculates second derivatives of the
dipole\sphinxhyphen{}dipole interaction energy for a single atom

\sphinxstylestrong{EDIPOLE3 Subroutine}

“edipole3” calculates the dipole\sphinxhyphen{}dipole interaction energy;
also partitions the energy among the atoms

\sphinxstylestrong{EDISP Subroutine}

“edisp” calculates the damped dispersion potential energy

\sphinxstylestrong{EDISP0A Subroutine}

“edisp0a” calculates the damped dispersion potential energy
using a pairwise double loop

\sphinxstylestrong{EDISP0B Subroutine}

“edisp0b” calculates the damped dispersion potential energy
using a pairwise neighbor list

\sphinxstylestrong{EDISP0C Subroutine}

“edisp0c” calculates the dispersion interaction energy using
particle mesh Ewald summation and a double loop

\sphinxstylestrong{EDISP0D Subroutine}

“edisp0d” calculates the dispersion interaction energy using
particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{EDISP1 Subroutine}

“edisp1” calculates the damped dispersion energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EDISP1A Subroutine}

“edisp1a” calculates the damped dispersion energy and
derivatives with respect to Cartesian coordinates using
a pairwise double loop

\sphinxstylestrong{EDISP1B Subroutine}

“edisp1b” calculates the damped dispersion energy and
derivatives with respect to Cartesian coordinates using
a pairwise neighbor list

\sphinxstylestrong{EDISP1C Subroutine}

“edisp1c” calculates the damped dispersion energy and
derivatives with respect to Cartesian coordinates using
particle mesh Ewald summation and a double loop

\sphinxstylestrong{EDISP1D Subroutine}

“edisp1d” calculates the damped dispersion energy and
derivatives with respect to Cartesian coordinates using
particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{EDISP2 Subroutine}

“edisp2” calculates the damped dispersion second derivatives
for a single atom at a time

\sphinxstylestrong{EDISP3 Subroutine}

“edisp3” calculates the dispersion energy; also partitions
the energy among the atoms

\sphinxstylestrong{EDISP3A Subroutine}

“edisp3a” calculates the dispersion potential energy and
also partitions the energy among the atoms using a pairwise
double loop

\sphinxstylestrong{EDISP3B Subroutine}

“edisp3b” calculates the damped dispersion potential energy
and also partitions the energy among the atomsusing a pairwise
neighbor list

\sphinxstylestrong{EDISP3C Subroutine}

“edisp3c” calculates the dispersion interaction energy using
particle mesh Ewald summation and a double loop

\sphinxstylestrong{EDISP3D Subroutine}

“edisp3d” calculates the damped dispersion energy and analysis
using particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{EDREAL0C Subroutine}

“edreal0c” calculates the damped dispersion potential energy
using a particle mesh Ewald sum and pairwise double loop

\sphinxstylestrong{EDREAL0D Subroutine}

“edreal0d” evaluated the real space portion of the damped
dispersion energy using a neighbor list

\sphinxstylestrong{EDREAL1C Subroutine}

“edreal1c” evaluates the real space portion of the Ewald
summation energy and gradient due to damped dispersion
interactions via a double loop

\sphinxstylestrong{EDREAL1D Subroutine}

“edreal1d” evaluates the real space portion of the Ewald
summation energy and gradient due to damped dispersion
interactions via a neighbor list

\sphinxstylestrong{EDREAL3C Subroutine}

“edreal3c” calculates the real space portion of the damped
dispersion energy and analysis using Ewald and a double loop

\sphinxstylestrong{EDREAL3D Subroutine}

“edreal3d” evaluated the real space portion of the damped
dispersion energy and analysis using Ewald and a neighbor list

\sphinxstylestrong{EDRECIP Subroutine}

“edrecip” evaluates the reciprocal space portion of the particle
mesh Ewald energy due to damped dispersion

\sphinxstylestrong{EDRECIP1 Subroutine}

“edrecip1” evaluates the reciprocal space portion of particle
mesh Ewald energy and gradient due to damped dispersion

\sphinxstylestrong{EGAUSS Subroutine}

“egauss” calculates the Gaussian expansion van der Waals energy

\sphinxstylestrong{EGAUSS0A Subroutine}

“egauss0a” calculates the Gaussian expansion van der Waals
energy using a pairwise double loop

\sphinxstylestrong{EGAUSS0B Subroutine}

“egauss0b” calculates the Gaussian expansion van der Waals energy
using the method of lights

\sphinxstylestrong{EGAUSS0C Subroutine}

“egauss0c” calculates the Gaussian expansion van der Waals
energy using a pairwise neighbor list

\sphinxstylestrong{EGAUSS0D Subroutine}

“egauss0d” calculates the Gaussian expansion van der Waals
energy for use with potential energy smoothing

\sphinxstylestrong{EGAUSS1 Subroutine}

“egauss1” calculates the Gaussian expansion van der Waals
interaction energy and its first derivatives with respect
to Cartesian coordinates

\sphinxstylestrong{EGAUSS1A Subroutine}

“egauss1a” calculates the Gaussian expansion van der Waals
interaction energy and its first derivatives using a pairwise
double loop

\sphinxstylestrong{EGAUSS1B Subroutine}

“egauss1b” calculates the Gaussian expansion van der Waals
energy and its first derivatives with respect to Cartesian
coordinates using the method of lights

\sphinxstylestrong{EGAUSS1C Subroutine}

“egauss1c” calculates the Gaussian expansion van der Waals
energy and its first derivatives with respect to Cartesian
coordinates using a pairwise neighbor list

\sphinxstylestrong{EGAUSS1D Subroutine}

“egauss1d” calculates the Gaussian expansion van der Waals
interaction energy and its first derivatives for use with
potential energy smoothing

\sphinxstylestrong{EGAUSS2 Subroutine}

“egauss2” calculates the Gaussian expansion van der Waals
second derivatives for a single atom at a time

\sphinxstylestrong{EGAUSS2A Subroutine}

“egauss2a” calculates the Gaussian expansion van der Waals
second derivatives using a pairwise double loop

\sphinxstylestrong{EGAUSS2B Subroutine}

“egauss2b” calculates the Gaussian expansion van der Waals
second derivatives for use with potential energy smoothing

\sphinxstylestrong{EGAUSS3 Subroutine}

“egauss3” calculates the Gaussian expansion van der Waals
interaction energy and partitions the energy among the atoms

\sphinxstylestrong{EGAUSS3A Subroutine}

“egauss3a” calculates the Gaussian expansion van der Waals
energy and partitions the energy among the atoms using a
pairwise double loop

\sphinxstylestrong{EGAUSS3B Subroutine}

“egauss3b” calculates the Gaussian expansion van der Waals
energy and partitions the energy among the atoms using the
method of lights

\sphinxstylestrong{EGAUSS3C Subroutine}

“egauss3c” calculates the Gaussian expansion van der Waals
energy and partitions the energy among the atoms using a
pairwise neighbor list

\sphinxstylestrong{EGAUSS3D Subroutine}

“egauss3d” calculates the Gaussian expansion van der Waals
interaction energy and partitions the energy among the atoms
for use with potential energy smoothing

\sphinxstylestrong{EGB0A Subroutine}

“egb0a” calculates the generalized Born polarization energy
for the GB/SA solvation models using a pairwise double loop

\sphinxstylestrong{EGB0B Subroutine}

“egb0b” calculates the generalized Born polarization energy
for the GB/SA solvation models using a pairwise neighbor list

\sphinxstylestrong{EGB0C Subroutine}

“egb0c” calculates the generalized Born polarization energy
for the GB/SA solvation models for use with potential smoothing
methods via analogy to the smoothing of Coulomb’s law

\sphinxstylestrong{EGB1A Subroutine}

“egb1a” calculates the generalized Born electrostatic energy
and first derivatives of the GB/SA solvation models using a
double loop

\sphinxstylestrong{EGB1B Subroutine}

“egb1b” calculates the generalized Born electrostatic energy
and first derivatives of the GB/SA solvation models using a
neighbor list

\sphinxstylestrong{EGB1C Subroutine}

“egb1c” calculates the generalized Born energy and first
derivatives of the GB/SA solvation models for use with
potential smoothing methods

\sphinxstylestrong{EGB2A Subroutine}

“egb2a” calculates second derivatives of the generalized
Born energy term for the GB/SA solvation models

\sphinxstylestrong{EGB2B Subroutine}

“egb2b” calculates second derivatives of the generalized
Born energy term for the GB/SA solvation models for use with
potential smoothing methods

\sphinxstylestrong{EGB3A Subroutine}

“egb3a” calculates the generalized Born electrostatic energy
for GB/SA solvation models using a pairwise double loop; also
partitions the energy among the atoms

\sphinxstylestrong{EGB3B Subroutine}

“egb3b” calculates the generalized Born electrostatic energy
for GB/SA solvation models using a pairwise neighbor list; also
partitions the energy among the atoms

\sphinxstylestrong{EGB3C Subroutine}

“egb3c” calculates the generalized Born electrostatic energy
for GB/SA solvation models for use with potential smoothing
methods via analogy to the smoothing of Coulomb’s law; also
partitions the energy among the atoms

\sphinxstylestrong{EGEOM Subroutine}

“egeom” calculates the energy due to restraints on positions,
distances, angles and torsions as well as Gaussian basin and
spherical droplet restraints

\sphinxstylestrong{EGEOM1 Subroutine}

“egeom1” calculates the energy and first derivatives
with respect to Cartesian coordinates due to restraints
on positions, distances, angles and torsions as well as
Gaussian basin and spherical droplet restraints

\sphinxstylestrong{EGEOM2 Subroutine}

“egeom2” calculates second derivatives of restraints
on positions, distances, angles and torsions as well
as Gaussian basin and spherical droplet restraints

\sphinxstylestrong{EGEOM3 Subroutine}

“egeom3” calculates the energy due to restraints on positions,
distances, angles and torsions as well as Gaussian basin and
droplet restraints; also partitions energy among the atoms

\sphinxstylestrong{EGK Subroutine}

“egk” calculates the generalized Kirkwood electrostatic
solvation free energy for the GK/NP implicit solvation model

\sphinxstylestrong{EGK0A Subroutine}

“egk0a” calculates the electrostatic portion of the implicit
solvation energy via the generalized Kirkwood model

\sphinxstylestrong{EGK1 Subroutine}

“egk1” calculates the implicit solvation energy and derivatives
via the generalized Kirkwood plus nonpolar implicit solvation

\sphinxstylestrong{EGK1A Subroutine}

“egk1a” calculates the electrostatic portion of the implicit
solvation energy and derivatives via the generalized Kirkwood
model

\sphinxstylestrong{EGK3 Subroutine}

“egk3” calculates the generalized Kirkwood electrostatic
energy for GK/NP solvation models; also partitions the
energy among the atoms

\sphinxstylestrong{EGK3A Subroutine}

“egk3a” calculates the electrostatic portion of the implicit
solvation energy via the generalized Kirkwood model; also
partitions the energy among the atoms

\sphinxstylestrong{EHAL Subroutine}

“ehal” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy

\sphinxstylestrong{EHAL0A Subroutine}

“ehal0a” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
using a pairwise double loop

\sphinxstylestrong{EHAL0B Subroutine}

“ehal0b” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
using the method of lights

\sphinxstylestrong{EHAL0C Subroutine}

“ehal0c” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
using a pairwise neighbor list

\sphinxstylestrong{EHAL1 Subroutine}

“ehal1” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy and
its first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EHAL1A Subroutine}

“ehal1a” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy and
its first derivatives with respect to Cartesian coordinates
using a pairwise double loop

\sphinxstylestrong{EHAL1B Subroutine}

“ehal1b” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy and
its first derivatives with respect to Cartesian coordinates
using the method of lights

\sphinxstylestrong{EHAL1C Subroutine}

“ehal1c” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy and
its first derivatives with respect to Cartesian coordinates
using a pairwise neighbor list

\sphinxstylestrong{EHAL2 Subroutine}

“ehal2” calculates the buffered 14\sphinxhyphen{}7 van der Waals second
derivatives for a single atom at a time

\sphinxstylestrong{EHAL3 Subroutine}

“ehal3” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
and partitions the energy among the atoms

\sphinxstylestrong{EHAL3A Subroutine}

“ehal3a” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
and partitions the energy among the atoms using a pairwise
double loop

\sphinxstylestrong{EHAL3B Subroutine}

“ehal3b” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
and also partitions the energy among the atoms using the
method of lights

\sphinxstylestrong{EHAL3C Subroutine}

“ehal3c” calculates the buffered 14\sphinxhyphen{}7 van der Waals energy
and also partitions the energy among the atoms using a
pairwise neighbor list

\sphinxstylestrong{EHPMF Subroutine}

“ehpmf” calculates the hydrophobic potential of mean force
energy using a pairwise double loop

\sphinxstylestrong{EHPMF1 Subroutine}

“ehpmf1” calculates the hydrophobic potential of mean force
energy and first derivatives using a pairwise double loop

\sphinxstylestrong{EHPMF3 Subroutine}

“ehpmf3” calculates the hydrophobic potential of mean force
nonpolar energy; also partitions the energy among the atoms

\sphinxstylestrong{EIGEN Subroutine}

“eigen” uses the power method to compute the largest eigenvalues
and eigenvectors of the metric matrix, “valid” is set true if the
first three eigenvalues are positive

\sphinxstylestrong{EIGENRGD Subroutine}

\sphinxstylestrong{EIGENROT Subroutine}

\sphinxstylestrong{EIGENROT Subroutine}

\sphinxstylestrong{EIGENTOR Subroutine}

\sphinxstylestrong{EIGENXYZ Subroutine}

\sphinxstylestrong{EIMPROP Subroutine}

“eimprop” calculates the improper dihedral potential energy

\sphinxstylestrong{EIMPROP1 Subroutine}

“eimprop1” calculates improper dihedral energy and its
first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EIMPROP2 Subroutine}

“eimprop2” calculates second derivatives of the improper
dihedral angle energy for a single atom

\sphinxstylestrong{EIMPROP3 Subroutine}

“eimprop3” calculates the improper dihedral potential
energy; also partitions the energy terms among the atoms

\sphinxstylestrong{EIMPTOR Subroutine}

“eimptor” calculates the improper torsion potential energy

\sphinxstylestrong{EIMPTOR1 Subroutine}

“eimptor1” calculates improper torsion energy and its
first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EIMPTOR2 Subroutine}

“eimptor2” calculates second derivatives of the improper
torsion energy for a single atom

\sphinxstylestrong{EIMPTOR3 Subroutine}

“eimptor3” calculates the improper torsion potential energy;
also partitions the energy terms among the atoms

\sphinxstylestrong{ELJ Subroutine}

“elj” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy

\sphinxstylestrong{ELJ0A Subroutine}

“elj0a” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
using a pairwise double loop

\sphinxstylestrong{ELJ0B Subroutine}

“elj0b” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
using the method of lights

\sphinxstylestrong{ELJ0C Subroutine}

“elj0c” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
using a pairwise neighbor list

\sphinxstylestrong{ELJ0D Subroutine}

“elj0d” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
via a Gaussian approximation for potential energy smoothing

\sphinxstylestrong{ELJ0E Subroutine}

“elj0e” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
for use with stophat potential energy smoothing

\sphinxstylestrong{ELJ1 Subroutine}

“elj1” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
and its first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ELJ1A Subroutine}

“elj1a” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
and its first derivatives using a pairwise double loop

\sphinxstylestrong{ELJ1B Subroutine}

“elj1b” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
and its first derivatives using the method of lights

\sphinxstylestrong{ELJ1C Subroutine}

“elj1c” calculates the Lennard\sphinxhyphen{}Jones 12\sphinxhyphen{}6 van der Waals energy
and its first derivatives using a pairwise neighbor list

\sphinxstylestrong{ELJ1D Subroutine}
\begin{description}
\item[{“elj1d” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy}] \leavevmode
and its first derivatives via a Gaussian approximation for
potential energy smoothing

\end{description}

\sphinxstylestrong{ELJ1E Subroutine}

“elj1e” calculates the van der Waals interaction energy and its
first derivatives for use with stophat potential energy smoothing

\sphinxstylestrong{ELJ2 Subroutine}

“elj2” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals second
derivatives for a single atom at a time

\sphinxstylestrong{ELJ2A Subroutine}

“elj2a” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals second
derivatives using a double loop over relevant atom pairs

\sphinxstylestrong{ELJ2B Subroutine}

“elj2b” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals second
derivatives via a Gaussian approximation for use with potential
energy smoothing

\sphinxstylestrong{ELJ2C Subroutine}

“elj2c” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals second
derivatives for use with stophat potential energy smoothing

\sphinxstylestrong{ELJ3 Subroutine}

“elj3” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
and also partitions the energy among the atoms

\sphinxstylestrong{ELJ3A Subroutine}

“elj3a” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals
energy and also partitions the energy among the atoms using
a pairwise double loop

\sphinxstylestrong{ELJ3B Subroutine}

“elj3b” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals
energy and also partitions the energy among the atoms using
the method of lights

\sphinxstylestrong{ELJ3C Subroutine}

“elj3c” calculates the Lennard\sphinxhyphen{}Jones van der Waals energy
and also partitions the energy among the atoms using a
pairwise neighbor list

\sphinxstylestrong{ELJ3D Subroutine}

“elj3d” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
and also partitions the energy among the atoms via a Gaussian
approximation for potential energy smoothing

\sphinxstylestrong{ELJ3E Subroutine}

“elj3e” calculates the Lennard\sphinxhyphen{}Jones 6\sphinxhyphen{}12 van der Waals energy
and also partitions the energy among the atoms for use with
stophat potential energy smoothing

\sphinxstylestrong{EMBED Subroutine}

“embed” is a distance geometry routine patterned after the
ideas of Gordon Crippen, Irwin Kuntz and Tim Havel; it takes
as input a set of upper and lower bounds on the interpoint
distances, chirality restraints and torsional restraints,
and attempts to generate a set of coordinates that satisfy
the input bounds and restraints

\sphinxstylestrong{EMETAL Subroutine}

“emetal” calculates the transition metal ligand field energy

\sphinxstylestrong{EMETAL1 Subroutine}

“emetal1” calculates the transition metal ligand field energy
and its first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EMETAL2 Subroutine}

“emetal2” calculates the transition metal ligand field second
derivatives for a single atom at a time

\sphinxstylestrong{EMETAL3 Subroutine}

“emetal3” calculates the transition metal ligand field energy
and also partitions the energy among the atoms

\sphinxstylestrong{EMM3HB Subroutine}

“emm3hb” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding energy

\sphinxstylestrong{EMM3HB0A Subroutine}

“emm3hb0a” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and
directional charge transfer hydrogen bonding energy using
a pairwise double loop

\sphinxstylestrong{EMM3HB0B Subroutine}

“emm3hb0b” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and
directional charge transfer hydrogen bonding energy using
the method of lights

\sphinxstylestrong{EMM3HB0C Subroutine}

“emm3hb0c” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and
directional charge transfer hydrogen bonding energy using
a pairwise neighbor list

\sphinxstylestrong{EMM3HB1 Subroutine}

“emm3hb1” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding energy with respect to Cartesian
coordinates

\sphinxstylestrong{EMM3HB1A Subroutine}

“emm3hb1a” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding energy with respect to Cartesian
coordinates using a pairwise double loop

\sphinxstylestrong{EMM3HB1B Subroutine}

“emm3hb1b” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding energy with respect to Cartesian
coordinates using the method of lights

\sphinxstylestrong{EMM3HB1C Subroutine}

“emm3hb1c” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding energy with respect to Cartesian
coordinates using a pairwise neighbor list

\sphinxstylestrong{EMM3HB2 Subroutine}

“emm3hb2” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding second derivatives for a single
atom at a time

\sphinxstylestrong{EMM3HB3 Subroutine}

“emm3hb3” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and directional
charge transfer hydrogen bonding energy, and partitions the energy
among the atoms

\sphinxstylestrong{EMM3HB3A Subroutine}

“emm3hb3” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and
directional charge transfer hydrogen bonding energy, and
partitions the energy among the atoms

\sphinxstylestrong{EMM3HB3B Subroutine}

“emm3hb3b” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and
directional charge transfer hydrogen bonding energy using
the method of lights

\sphinxstylestrong{EMM3HB3C Subroutine}

“emm3hb3c” calculates the MM3 exp\sphinxhyphen{}6 van der Waals and
directional charge transfer hydrogen bonding energy using
a pairwise neighbor list

\sphinxstylestrong{EMPOLE Subroutine}

“empole” calculates the electrostatic energy due to atomic
multipole interactions

\sphinxstylestrong{EMPOLE0A Subroutine}

“empole0a” calculates the atomic multipole interaction energy
using a double loop

\sphinxstylestrong{EMPOLE0B Subroutine}

“empole0b” calculates the atomic multipole interaction energy
using a neighbor list

\sphinxstylestrong{EMPOLE0C Subroutine}

“empole0c” calculates the atomic multipole interaction energy
using particle mesh Ewald summation and a double loop

\sphinxstylestrong{EMPOLE0D Subroutine}

“empole0d” calculates the atomic multipole interaction energy
using particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{EMPOLE1 Subroutine}

“empole1” calculates the atomic multipole energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EMPOLE1A Subroutine}

“empole1a” calculates the multipole energy and derivatives with
respect to Cartesian coordinates using a pairwise double loop

\sphinxstylestrong{EMPOLE1B Subroutine}

“empole1b” calculates the multipole energy and derivatives
with respect to Cartesian coordinates using a neighbor list

\sphinxstylestrong{EMPOLE1C Subroutine}

“empole1c” calculates the multipole energy and derivatives
with respect to Cartesian coordinates using particle mesh
Ewald summation and a double loop

\sphinxstylestrong{EMPOLE1D Subroutine}

“empole1d” calculates the multipole energy and derivatives
with respect to Cartesian coordinates using particle mesh Ewald
summation and a neighbor list

\sphinxstylestrong{EMPOLE2 Subroutine}

“empole2” calculates second derivatives of the multipole energy
for a single atom at a time

\sphinxstylestrong{EMPOLE2A Subroutine}

“empole2a” computes multipole first derivatives for a single
atom; used to get finite difference second derivatives

\sphinxstylestrong{EMPOLE3 Subroutine}

“empole3” calculates the electrostatic energy due to atomic
multipole interactions, and partitions the energy among atoms

\sphinxstylestrong{EMPOLE3A Subroutine}

“empole3a” calculates the atomic multipole interaction energy
using a double loop, and partitions the energy among atoms

\sphinxstylestrong{EMPOLE3B Subroutine}

“empole3b” calculates the atomic multipole interaction energy
using a neighbor list, and partitions the energy among the atoms

\sphinxstylestrong{EMPOLE3C Subroutine}

“empole3c” calculates the atomic multipole interaction energy
using a particle mesh Ewald summation and double loop, and
partitions the energy among the atoms

\sphinxstylestrong{EMPOLE3D Subroutine}

“empole3d” calculates the atomic multipole interaction energy
using particle mesh Ewald summation and a neighbor list, and
partitions the energy among the atoms

\sphinxstylestrong{EMREAL0C Subroutine}

“emreal0c” evaluates the real space portion of the Ewald sum
energy due to atomic multipoles using a double loop

\sphinxstylestrong{EMREAL0D Subroutine}

“emreal0d” evaluates the real space portion of the Ewald sum
energy due to atomic multipoles using a neighbor list

\sphinxstylestrong{EMREAL1C Subroutine}

“emreal1c” evaluates the real space portion of the Ewald
summation energy and gradient due to multipole interactions
via a double loop

\sphinxstylestrong{EMREAL1D Subroutine}

“emreal1d” evaluates the real space portion of the Ewald
summation energy and gradient due to multipole interactions
via a neighbor list

\sphinxstylestrong{EMREAL3C Subroutine}

“emreal3c” evaluates the real space portion of the Ewald sum
energy due to atomic multipole interactions and partitions
the energy among the atoms

\sphinxstylestrong{EMREAL3D Subroutine}

“emreal3d” evaluates the real space portion of the Ewald sum
energy due to atomic multipole interactions, and partitions
the energy among the atoms using a pairwise neighbor list

\sphinxstylestrong{EMRECIP Subroutine}

“emrecip” evaluates the reciprocal space portion of the particle
mesh Ewald energy due to atomic multipole interactions

\sphinxstylestrong{EMRECIP1 Subroutine}

“emrecip1” evaluates the reciprocal space portion of particle
mesh Ewald summation energy and gradient due to multipoles

\sphinxstylestrong{ENERGY Function}

“energy” calls the subroutines to calculate the potential
energy terms and sums up to form the total energy

\sphinxstylestrong{ENP Subroutine}

“enp” calculates the nonpolar implicit solvation energy
as a sum of cavity and dispersion terms

\sphinxstylestrong{ENP1 Subroutine}

“enp1” calculates the nonpolar implicit solvation energy
and derivatives as a sum of cavity and dispersion terms

\sphinxstylestrong{ENP3 Subroutine}

“enp3” calculates the nonpolar implicit solvation energy as
a sum of cavity and dispersion terms; also partitions the
energy among the atoms

\sphinxstylestrong{ENRGYZE Subroutine}

“enrgyze” is an auxiliary routine for the analyze program
that performs the energy analysis and prints the total and
intermolecular energies

\sphinxstylestrong{EOPBEND Subroutine}

“eopbend” computes the out\sphinxhyphen{}of\sphinxhyphen{}plane bend potential energy at
trigonal centers via a Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross or Allinger angle

\sphinxstylestrong{EOPBEND1 Subroutine}

“eopbend1” computes the out\sphinxhyphen{}of\sphinxhyphen{}plane bend potential energy and
first derivatives at trigonal centers via a Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross
or Allinger angle

\sphinxstylestrong{EOPBEND2 Subroutine}

“eopbend2” calculates second derivatives of the out\sphinxhyphen{}of\sphinxhyphen{}plane
bend energy via a Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross or Allinger angle for
a single atom using finite difference methods

\sphinxstylestrong{EOPBEND2A Subroutine}

“eopbend2a” calculates out\sphinxhyphen{}of\sphinxhyphen{}plane bend first derivatives at
a trigonal center via a Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross or Allinger angle;
used in computation of finite difference second derivatives

\sphinxstylestrong{EOPBEND3 Subroutine}

“eopbend3” computes the out\sphinxhyphen{}of\sphinxhyphen{}plane bend potential energy at
trigonal centers via a Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross or Allinger angle;
also partitions the energy among the atoms

\sphinxstylestrong{EOPDIST Subroutine}

“eopdist” computes the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential
energy at trigonal centers via the central atom height

\sphinxstylestrong{EOPDIST1 Subroutine}

“eopdist1” computes the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential
energy and first derivatives at trigonal centers via
the central atom height

\sphinxstylestrong{EOPDIST2 Subroutine}

“eopdist2” calculates second derivatives of the out\sphinxhyphen{}of\sphinxhyphen{}plane
distance energy for a single atom via the central atom height

\sphinxstylestrong{EOPDIST3 Subroutine}

“eopdist3” computes the out\sphinxhyphen{}of\sphinxhyphen{}plane distance potential energy
at trigonal centers via the central atom height; also partitions
the energy among the atoms

\sphinxstylestrong{EPB Subroutine}

“epb” calculates the implicit solvation energy via the
Poisson\sphinxhyphen{}Boltzmann plus nonpolar implicit solvation

\sphinxstylestrong{EPB1 Subroutine}

“epb1” calculates the implicit solvation energy and derivatives
via the Poisson\sphinxhyphen{}Boltzmann plus nonpolar implicit solvation

\sphinxstylestrong{EPB1A Subroutine}

“epb1a” calculates the solvation energy and gradients for the
PB/NP solvation model

\sphinxstylestrong{EPB3 Subroutine}

“epb3” calculates the implicit solvation energy via the
Poisson\sphinxhyphen{}Boltzmann model; also partitions the energy among
the atoms

\sphinxstylestrong{EPITORS Subroutine}

“epitors” calculates the pi\sphinxhyphen{}system torsion potential energy

\sphinxstylestrong{EPITORS1 Subroutine}

“epitors1” calculates the pi\sphinxhyphen{}system torsion potential energy
and first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EPITORS2 Subroutine}

“epitors2” calculates the second derivatives of the pi\sphinxhyphen{}system
torsion energy for a single atom using finite difference methods

\sphinxstylestrong{EPITORS2A Subroutine}

“epitors2a” calculates the pi\sphinxhyphen{}system torsion first derivatives;
used in computation of finite difference second derivatives

\sphinxstylestrong{EPITORS3 Subroutine}

“epitors3” calculates the pi\sphinxhyphen{}system torsion potential energy;
also partitions the energy terms among the atoms

\sphinxstylestrong{EPOLAR Subroutine}

“epolar” calculates the polarization energy due to induced
dipole interactions

\sphinxstylestrong{EPOLAR0A Subroutine}

“epolar0a” calculates the induced dipole polarization energy
using a double loop, and partitions the energy among atoms

\sphinxstylestrong{EPOLAR0B Subroutine}

“epolar0b” calculates the induced dipole polarization energy
using a neighbor list

\sphinxstylestrong{EPOLAR0C Subroutine}

“epolar0c” calculates the dipole polarization energy with respect
to Cartesian coordinates using particle mesh Ewald summation and
a double loop

\sphinxstylestrong{EPOLAR0D Subroutine}

“epolar0d” calculates the dipole polarization energy with respect
to Cartesian coordinates using particle mesh Ewald summation and
a neighbor list

\sphinxstylestrong{EPOLAR0E Subroutine}

“epolar0e” calculates the dipole polarizability interaction
from the induced dipoles times the electric field

\sphinxstylestrong{EPOLAR1 Subroutine}

“epolar1” calculates the induced dipole polarization energy
and first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EPOLAR1A Subroutine}

“epolar1a” calculates the dipole polarization energy and
derivatives with respect to Cartesian coordinates using a
pairwise double loop

\sphinxstylestrong{EPOLAR1B Subroutine}

“epolar1b” calculates the dipole polarization energy and
derivatives with respect to Cartesian coordinates using a
neighbor list

\sphinxstylestrong{EPOLAR1C Subroutine}

“epolar1c” calculates the dipole polarization energy and
derivatives with respect to Cartesian coordinates using
particle mesh Ewald summation and a double loop

\sphinxstylestrong{EPOLAR1D Subroutine}

“epolar1d” calculates the dipole polarization energy and
derivatives with respect to Cartesian coordinates using
particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{EPOLAR1E Subroutine}

“epolar1e” calculates the dipole polarizability interaction
from the induced dipoles times the electric field

\sphinxstylestrong{EPOLAR2 Subroutine}

“epolar2” calculates second derivatives of the dipole polarization
energy for a single atom at a time

\sphinxstylestrong{EPOLAR2A Subroutine}

“epolar2a” computes polarization first derivatives for a single
atom with respect to Cartesian coordinates; used to get finite
difference second derivatives

\sphinxstylestrong{EPOLAR3 Subroutine}

“epolar3” calculates the induced dipole polarization energy,
and partitions the energy among atoms

\sphinxstylestrong{EPOLAR3A Subroutine}

“epolar3a” calculates the induced dipole polarization energy
using a double loop, and partitions the energy among atoms

\sphinxstylestrong{EPOLAR3B Subroutine}

“epolar3b” calculates the induced dipole polarization energy
using a neighbor list, and partitions the energy among atoms

\sphinxstylestrong{EPOLAR3C Subroutine}

“epolar3c” calculates the polarization energy and analysis with
respect to Cartesian coordinates using particle mesh Ewald and
a double loop

\sphinxstylestrong{EPOLAR3D Subroutine}

“epolar3d” calculates the polarization energy and analysis with
respect to Cartesian coordinates using particle mesh Ewald and
a neighbor list

\sphinxstylestrong{EPOLAR3E Subroutine}

“epolar3e” calculates the dipole polarizability interaction
from the induced dipoles times the electric field

\sphinxstylestrong{EPREAL0C Subroutine}

“epreal0c” calculates the induced dipole polarization energy
using particle mesh Ewald summation and a double loop

\sphinxstylestrong{EPREAL0D Subroutine}

“epreal0d” calculates the induced dipole polarization energy
using particle mesh Ewald summation and a neighbor list

\sphinxstylestrong{EPREAL1C Subroutine}

“epreal1c” evaluates the real space portion of the Ewald
summation energy and gradient due to dipole polarization
via a double loop

\sphinxstylestrong{EPREAL1D Subroutine}

“epreal1d” evaluates the real space portion of the Ewald
summation energy and gradient due to dipole polarization
via a neighbor list

\sphinxstylestrong{EPREAL3C Subroutine}

“epreal3c” calculates the induced dipole polarization energy and
analysis using particle mesh Ewald summation and a double loop

\sphinxstylestrong{EPREAL3D Subroutine}

“epreal3d” calculates the induced dipole polarization energy
and analysis using particle mesh Ewald and a neighbor list

\sphinxstylestrong{EPRECIP Subroutine}

“eprecip” evaluates the reciprocal space portion of particle
mesh Ewald summation energy due to dipole polarization

\sphinxstylestrong{EPRECIP1 Subroutine}

“eprecip1” evaluates the reciprocal space portion of the particle
mesh Ewald summation energy and gradient due to dipole polarization

\sphinxstylestrong{EQUCLC Subroutine}

\sphinxstylestrong{EREPEL Subroutine}

“erepel” calculates the Pauli exchange repulsion energy

\sphinxstylestrong{EREPEL0A Subroutine}

“erepel0a” calculates the Pauli repulsion interaction energy
using a double loop

\sphinxstylestrong{EREPEL0B Subroutine}

“erepel0b” calculates the Pauli repulsion interaction energy
using a pairwise neighbor list

\sphinxstylestrong{EREPEL1 Subroutine}

“erepel1” calculates the Pauli repulsion energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EREPEL1A Subroutine}

“erepel1a” calculates the Pauli repulsion energy and first
derivatives with respect to Cartesian coordinates using a
pairwise double loop

\sphinxstylestrong{EREPEL1B Subroutine}

“erepel1b” calculates the Pauli repulsion energy and first
derivatives with respect to Cartesian coordinates using a
pariwise neighbor list

\sphinxstylestrong{EREPEL2 Subroutine}

“erepel2” calculates the second derivatives of the Pauli
repulsion energy

\sphinxstylestrong{EREPEL2A Subroutine}

“erepel2a” computes Pauli repulsion first derivatives for a
single atom via a double loop; used to get finite difference
second derivatives

\sphinxstylestrong{EREPEL3 Subroutine}

“erepel3” calculates the Pauli repulsion energy and partitions
the energy among the atoms

\sphinxstylestrong{EREPEL3A Subroutine}

“erepel3a” calculates the Pauli repulsion energy and also
partitions the energy among the atoms using a double loop

\sphinxstylestrong{EREPEL3B Subroutine}

“erepel3b” calculates the Pauli repulsion energy and also
partitions the energy among the atoms using a neighbor list

\sphinxstylestrong{ERF Function}

“erf” computes a numerical approximation to the value of
the error function via a Chebyshev approximation

\sphinxstylestrong{ERFC Function}

“erfc” computes a numerical approximation to the value of the
complementary error function via a Chebyshev approximation

\sphinxstylestrong{ERFCORE Subroutine}

“erfcore” evaluates erf(x) or erfc(x) for a real argument x;
when called with mode set to 0 it returns erf, a mode of 1
returns erfc; uses rational functions that approximate erf(x)
and erfc(x) to at least 18 significant decimal digits

\sphinxstylestrong{ERFIK Subroutine}

“erfik” compute the reaction field energy due to a single pair
of atomic multipoles

\sphinxstylestrong{ERFINV Function}

“erfinv” evaluates the inverse of the error function for
an argument in the range (\sphinxhyphen{}1,1) using a rational function
approximation followed by cycles of Newton\sphinxhyphen{}Raphson correction

\sphinxstylestrong{ERXNFLD Subroutine}

“erxnfld” calculates the macroscopic reaction field energy
arising from a set of atomic multipoles

\sphinxstylestrong{ERXNFLD1 Subroutine}

“erxnfld1” calculates the macroscopic reaction field energy
and derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ERXNFLD2 Subroutine}

“erxnfld2” calculates second derivatives of the macroscopic
reaction field energy for a single atom at a time

\sphinxstylestrong{ERXNFLD3 Subroutine}

“erxnfld3” calculates the macroscopic reaction field energy,
and also partitions the energy among the atoms

\sphinxstylestrong{ESOLV Subroutine}

“esolv” calculates the implicit solvation energy for surface area,
generalized Born, generalized Kirkwood and Poisson\sphinxhyphen{}Boltzmann
solvation models

\sphinxstylestrong{ESOLV1 Subroutine}

“esolv1” calculates the implicit solvation energy and
first derivatives with respect to Cartesian coordinates
for surface area, generalized Born, generalized Kirkwood
and Poisson\sphinxhyphen{}Boltzmann solvation models

\sphinxstylestrong{ESOLV2 Subroutine}

“esolv2” calculates second derivatives of the implicit
solvation energy for surface area, generalized Born,
generalized Kirkwood and Poisson\sphinxhyphen{}Boltzmann solvation models

\sphinxstylestrong{ESOLV2A Subroutine}

“esolv2a” calculates second derivatives of the implicit solvation
potential energy by finite differences

\sphinxstylestrong{ESOLV2B Subroutine}

“esolv2b” finds implicit solvation gradients needed for
calculation of the Hessian matrix by finite differences

\sphinxstylestrong{ESOLV3 Subroutine}

“esolv3” calculates the implicit solvation energy for
surface area, generalized Born, generalized Kirkwood
and Poisson\sphinxhyphen{}Boltzmann solvation models; also partitions
the energy among the atoms

\sphinxstylestrong{ESTRBND Subroutine}

“estrbnd” calculates the stretch\sphinxhyphen{}bend potential energy

\sphinxstylestrong{ESTRBND1 Subroutine}

“estrbnd1” calculates the stretch\sphinxhyphen{}bend potential energy and
first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ESTRBND2 Subroutine}

“estrbnd2” calculates the stretch\sphinxhyphen{}bend potential energy
second derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ESTRBND3 Subroutine}

“estrbnd3” calculates the stretch\sphinxhyphen{}bend potential energy;
also partitions the energy among the atoms

\sphinxstylestrong{ESTRTOR Subroutine}

“estrtor” calculates the stretch\sphinxhyphen{}torsion potential energy

\sphinxstylestrong{ESTRTOR1 Subroutine}

“estrtor1” calculates the stretch\sphinxhyphen{}torsion energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ESTRTOR2 Subroutine}

“estrtor2” calculates the stretch\sphinxhyphen{}torsion potential energy
second derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ESTRTOR3 Subroutine}

“estrtor3” calculates the stretch\sphinxhyphen{}torsion potential energy;
also partitions the energy terms among the atoms

\sphinxstylestrong{ETORS Subroutine}

“etors” calculates the torsional potential energy

\sphinxstylestrong{ETORS0A Subroutine}

“etors0a” calculates the torsional potential energy
using a standard sum of Fourier terms

\sphinxstylestrong{ETORS0B Subroutine}

“etors0b” calculates the torsional potential energy
for use with potential energy smoothing methods

\sphinxstylestrong{ETORS1 Subroutine}

“etors1” calculates the torsional potential energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ETORS1A Subroutine}

“etors1a” calculates the torsional potential energy and first
derivatives with respect to Cartesian coordinates using a
standard sum of Fourier terms

\sphinxstylestrong{ETORS1B Subroutine}

“etors1b” calculates the torsional potential energy and first
derivatives with respect to Cartesian coordinates for use with
potential energy smoothing methods

\sphinxstylestrong{ETORS2 Subroutine}

“etors2” calculates the second derivatives of the torsional
energy for a single atom

\sphinxstylestrong{ETORS2A Subroutine}

“etors2a” calculates the second derivatives of the torsional
energy for a single atom using a standard sum of Fourier terms

\sphinxstylestrong{ETORS2B Subroutine}

“etors2b” calculates the second derivatives of the torsional
energy for a single atom for use with potential energy
smoothing methods

\sphinxstylestrong{ETORS3 Subroutine}

“etors3” calculates the torsional potential energy; also
partitions the energy among the atoms

\sphinxstylestrong{ETORS3A Subroutine}

“etors3a” calculates the torsional potential energy using
a standard sum of Fourier terms and partitions the energy
among the atoms

\sphinxstylestrong{ETORS3B Subroutine}

“etors3b” calculates the torsional potential energy for use
with potential energy smoothing methods and partitions the
energy among the atoms

\sphinxstylestrong{ETORTOR Subroutine}

“etortor” calculates the torsion\sphinxhyphen{}torsion potential energy

\sphinxstylestrong{ETORTOR1 Subroutine}

“etortor1” calculates the torsion\sphinxhyphen{}torsion energy and first
derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ETORTOR2 Subroutine}

“etortor2” calculates the torsion\sphinxhyphen{}torsion potential energy
second derivatives with respect to Cartesian coordinates

\sphinxstylestrong{ETORTOR3 Subroutine}

“etortor3” calculates the torsion\sphinxhyphen{}torsion potential energy;
also partitions the energy terms among the atoms

\sphinxstylestrong{EUREY Subroutine}

“eurey” calculates the Urey\sphinxhyphen{}Bradley 1\sphinxhyphen{}3 interaction energy

\sphinxstylestrong{EUREY1 Subroutine}

“eurey1” calculates the Urey\sphinxhyphen{}Bradley interaction energy and
its first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{EUREY2 Subroutine}

“eurey2” calculates second derivatives of the Urey\sphinxhyphen{}Bradley
interaction energy for a single atom at a time

\sphinxstylestrong{EUREY3 Subroutine}

“eurey3” calculates the Urey\sphinxhyphen{}Bradley energy; also
partitions the energy among the atoms

\sphinxstylestrong{EVCORR Subroutine}

“evcorr” computes the long range van der Waals correction
to the energy via numerical integration

\sphinxstylestrong{EVCORR1 Subroutine}

“evcorr1” computes the long range van der Waals correction
to the energy and virial via numerical integration

\sphinxstylestrong{EWALDCOF Subroutine}

“ewaldcof” finds an Ewald coefficient such that all terms
beyond the specified cutoff distance will have a value less
than a specified tolerance

\sphinxstylestrong{EWCA Subroutine}

“ewca” find the Weeks\sphinxhyphen{}Chandler\sphinxhyphen{}Andersen dispersion energy
of a solute using an HCT\sphinxhyphen{}like method

\sphinxstylestrong{EWCA1 Subroutine}

“ewca1” finds the Weeks\sphinxhyphen{}Chandler\sphinxhyphen{}Anderson dispersion energy
and derivatives of a solute

\sphinxstylestrong{EWCA3 Subroutine}

“ewca3” find the Weeks\sphinxhyphen{}Chandler\sphinxhyphen{}Andersen dispersion energy
of a solute; also partitions the energy among the atoms

\sphinxstylestrong{EWCA3X Subroutine}

“ewca3x” finds the Weeks\sphinxhyphen{}Chandler\sphinxhyphen{}Anderson dispersion energy
of a solute using a numerical “onion shell” method; also
partitions the energy among the atoms

\sphinxstylestrong{EWCAX Subroutine}

“ewcax” finds the Weeks\sphinxhyphen{}Chandler\sphinxhyphen{}Anderson dispersion energy
of a solute using a numerical “onion shell” method

\sphinxstylestrong{EXPLORE Subroutine}

“explore” uses simulated annealing on an initial crude
embedded distance geoemtry structure to refine versus the
bound, chirality, planarity and torsional error functions

\sphinxstylestrong{EXTENT Subroutine}

“extent” finds the largest interatomic distance in a system

\sphinxstylestrong{EXTRA Subroutine}

“extra” calculates any additional user defined potential
energy contribution

\sphinxstylestrong{EXTRA1 Subroutine}

“extra1” calculates any additional user defined potential
energy contribution and its first derivatives

\sphinxstylestrong{EXTRA2 Subroutine}

“extra2” calculates second derivatives of any additional
user defined potential energy contribution for a single
atom at a time

\sphinxstylestrong{EXTRA3 Subroutine}

“extra3” calculates any additional user defined potential
contribution and also partitions the energy among the atoms

\sphinxstylestrong{FATAL Subroutine}

“fatal” terminates execution due to a user request, a severe
error or some other nonstandard condition

\sphinxstylestrong{FFTBACK Subroutine}

“fftback” performs a 3\sphinxhyphen{}D FFT backward transform via a single
3\sphinxhyphen{}D transform or three separate 1\sphinxhyphen{}D transforms

\sphinxstylestrong{FFTCLOSE Subroutine}

“fftclose” does cleanup after performing a 3\sphinxhyphen{}D FFT by destroying
the FFTW plans for the forward and backward transforms

\sphinxstylestrong{FFTFRONT Subroutine}

“fftfront” performs a 3\sphinxhyphen{}D FFT forward transform via a single
3\sphinxhyphen{}D transform or three separate 1\sphinxhyphen{}D transforms

\sphinxstylestrong{FFTSETUP Subroutine}

“fftsetup” does initialization for a 3\sphinxhyphen{}D FFT to be computed
via either the FFTPACK or FFTW libraries

\sphinxstylestrong{FIELD Subroutine}

“field” sets the force field potential energy functions from
a parameter file and modifications specified in a keyfile

\sphinxstylestrong{FINAL Subroutine}

“final” performs any final program actions such as deallocation
of global memory, prints a status message, and then pauses if
necessary to avoid closing the execution window

\sphinxstylestrong{FINDATM Subroutine}

“findatm” locates a specific PDB atom name type within a
range of atoms from the PDB file, returns zero if the name
type was not found

\sphinxstylestrong{FITRSD Subroutine}

“fitrsd” computes residuals for electrostatic potential fitting
including total charge restraints, dipole and quadrupole moment
targets, and restraints to initial parameter values

\sphinxstylestrong{FITTORS Subroutine}

“fittors” refines torsion parameters based on a quantum
mechanical optimized energy surface

\sphinxstylestrong{FIXFRAME Subroutine}

“fixframe” is a service routine that alters the local frame
definition for specified atoms

\sphinxstylestrong{FIXPDB Subroutine}

“fixpdb” corrects problems with PDB files by converting residue
and atom names to the standard forms used by Tinker

\sphinxstylestrong{FIXPOLE Subroutine}

“fixpole” performs unit conversion of the multipole components,
rounds moments to desired precision, and enforces integer net
charge and traceless quadrupoles

\sphinxstylestrong{FLATTEN Subroutine}

“flatten” sets the type of smoothing method and the extent of
surface deformation for use with potential energy smoothing

\sphinxstylestrong{FPHI\_MPOLE Subroutine}

“fphi\_mpole” extracts the permanent multipole potential from
the particle mesh Ewald grid

\sphinxstylestrong{FPHI\_TO\_CPHI Subroutine}

“fphi\_to\_cphi” transforms the reciprocal space potential from
fractional to Cartesian coordinates

\sphinxstylestrong{FPHI\_UIND Subroutine}

“fphi\_uind” extracts the induced dipole potential from
the particle mesh Ewald grid

\sphinxstylestrong{FRACDIST Subroutine}

“fracdist” computes a normalized distribution of the pairwise
fractional distances between the smoothed upper and lower bounds

\sphinxstylestrong{FRAC\_TO\_CART Subroutine}

“frac\_to\_cart” computes a transformation matrix to convert
a multipole object in fraction coordinates to Cartesian

\sphinxstylestrong{FRAME13 Subroutine}

“frame13” finds local coordinate frame defining atoms in cases
where the use of 1\sphinxhyphen{}3 connected atoms is required

\sphinxstylestrong{FREEUNIT Function}

“freeunit” finds an unopened Fortran I/O unit and returns
its numerical value from 1 to 99; the units already assigned
to “input” and “iout” (usually 5 and 6) are skipped since
they have special meaning as the default I/O units

\sphinxstylestrong{GAMMLN Function}

“gammln” uses a series expansion due to Lanczos to compute
the natural logarithm of the Gamma function at “x” in {[}0,1{]}

\sphinxstylestrong{GAUSSJORDAN Subroutine}

“gaussjordan” solves a system of linear equations by using
the method of Gaussian elimination with partial pivoting

\sphinxstylestrong{GDA Program}

“gda” implements Gaussian Density Annealing (GDA) algorithm
for global optimization via simulated annealing

\sphinxstylestrong{GDA1 Subroutine}

\sphinxstylestrong{GDA2 Function}

\sphinxstylestrong{GDA3 Subroutine}

\sphinxstylestrong{GDASTAT Subroutine}

for a GDA integration step; also saves the coordinates

\sphinxstylestrong{GENDOT Subroutine}

“gendot” finds the coordinates of a specified number of surface
points for a sphere with the input radius and coordinate center

\sphinxstylestrong{GEODESIC Subroutine}

“geodesic” smooths the upper and lower distance bounds via
the triangle inequality using a sparse matrix version of a
shortest path algorithm

\sphinxstylestrong{GEOMETRY Function}

“geometry” finds the value of the interatomic distance, angle
or dihedral angle defined by two to four input atoms

\sphinxstylestrong{GETARC Subroutine}

“getarc” asks for a coordinate archive or trajectory file name,
then reads in the initial set of coordinates

\sphinxstylestrong{GETBASE Subroutine}

“getbase” finds the base heavy atoms for a single nucleotide
residue and copies the names and coordinates to the Protein
Data Bank file

\sphinxstylestrong{GETCHUNK Subroutine}

“getchunk” determines the number of grid point “chunks” used
along each axis of the PME grid for parallelization

\sphinxstylestrong{GETINT Subroutine}

“getint” asks for an internal coordinate file name, then reads
the internal coordinates and computes Cartesian coordinates

\sphinxstylestrong{GETKEY Subroutine}

“getkey” finds a valid keyfile and stores its contents as
line images for subsequent keyword parameter searching

\sphinxstylestrong{GETMOL Subroutine}

“getmol” asks for a MDL MOL molecule file name,
then reads the coordinates from the file

\sphinxstylestrong{GETMOL2 Subroutine}

“getmol2” asks for a Tripos MOL2 molecule file name,
then reads the coordinates from the file

\sphinxstylestrong{GETMONITOR Subroutine}

\sphinxstylestrong{GETNUCH Subroutine}

“getnuch” finds the nucleotide hydrogen atoms for a single
residue and copies the names and coordinates to the Protein
Data Bank file

\sphinxstylestrong{GETNUMB Subroutine}

“getnumb” searches an input string from left to right for an
integer and puts the numeric value in “number”; returns zero
with “next” unchanged if no integer value is found

\sphinxstylestrong{GETPDB Subroutine}

“getpdb” asks for a Protein Data Bank file name,
then reads in the coordinates file

\sphinxstylestrong{GETPRB Subroutine}

“getprb” tests for a possible probe position at the interface
between three neighboring atoms

\sphinxstylestrong{GETPRM Subroutine}

“getprm” finds the potential energy parameter file
and then opens and reads the parameters

\sphinxstylestrong{GETPROH Subroutine}

“getproh” finds the hydrogen atoms for a single amino acid
residue and copies the names and coordinates to the Protein
Data Bank file

\sphinxstylestrong{GETREF Subroutine}

“getref” copies structure information from the reference area
into the standard variables for the current system structure

\sphinxstylestrong{GETSEQ Subroutine}

“getseq” asks the user for the amino acid sequence
and torsional angle values needed to define a peptide

\sphinxstylestrong{GETSEQN Subroutine}

“getseqn” asks the user for the nucleotide sequence and
torsional angle values needed to define a nucleic acid

\sphinxstylestrong{GETSIDE Subroutine}

“getside” finds the side chain heavy atoms for a single amino
acid residue and copies the names and coordinates to the Protein
Data Bank file

\sphinxstylestrong{GETSTRING Subroutine}

“getstring” searches for a quoted text string within an input
character string; the region between the first and second
double quote is returned as the “text”; if the actual text is
too long, only the first part is returned

\sphinxstylestrong{GETTEXT Subroutine}

“gettext” searches an input string for the first string of
non\sphinxhyphen{}blank characters; the region from a non\sphinxhyphen{}blank character
to the first space or tab is returned as “text”; if the
actual text is too long, only the first part is returned

\sphinxstylestrong{GETTIME Subroutine}

“gettime” finds the elapsed wall clock and CPU times in seconds
since the last call to “settime”

\sphinxstylestrong{GETTOR Subroutine}

“gettor” tests for a possible torus position at the interface
between two atoms, and finds the torus radius, center and axis

\sphinxstylestrong{GETWORD Subroutine}

“getword” searches an input string for the first alphabetic
character (A\sphinxhyphen{}Z or a\sphinxhyphen{}z); the region from this first character
to the first blank space or separator is returned as a “word”;
if the actual word is too long, only the first part is returned

\sphinxstylestrong{GETXYZ Subroutine}

“getxyz” asks for a Cartesian coordinate file name,
then reads in the coordinates file

\sphinxstylestrong{GHMCSTEP Subroutine}

“ghmcstep” performs a single stochastic dynamics time step via
the generalized hybrid Monte Carlo (GHMC) algorithm to ensure
exact sampling from the Boltzmann density

\sphinxstylestrong{GHMCTERM Subroutine}

“ghmcterm” finds the friction and fluctuation terms needed
to update velocities during GHMC stochastic dynamics

\sphinxstylestrong{GRADFAST Subroutine}

“gradfast” calculates the potential energy and first derivatives
for the fast\sphinxhyphen{}evolving local valence potential energy terms

\sphinxstylestrong{GRADIENT Subroutine}

“gradient” calls subroutines to calculate the potential energy
and first derivatives with respect to Cartesian coordinates

\sphinxstylestrong{GRADRGD Subroutine}

“gradrgd” calls subroutines to calculate the potential energy
and first derivatives with respect to rigid body coordinates

\sphinxstylestrong{GRADROT Subroutine}

“gradrot” calls subroutines to calculate the potential
energy and its torsional first derivatives

\sphinxstylestrong{GRADSLOW Subroutine}

“gradslow” calculates the potential energy and first derivatives
for the slow\sphinxhyphen{}evolving nonbonded potential energy terms

\sphinxstylestrong{GRAFIC Subroutine}

“grafic” outputs the upper \& lower triangles and diagonal
of a square matrix in a schematic form for visual inspection

\sphinxstylestrong{GRID\_DISP Subroutine}

“grid\_disp” places the damped dispersion coefficients onto
the particle mesh Ewald grid

\sphinxstylestrong{GRID\_MPOLE Subroutine}

“grid\_mpole” places the fractional atomic multipoles onto
the particle mesh Ewald grid

\sphinxstylestrong{GRID\_PCHG Subroutine}

“grid\_pchg” places the fractional atomic partial charges onto
the particle mesh Ewald grid

\sphinxstylestrong{GRID\_UIND Subroutine}

“grid\_uind” places the fractional induced dipoles onto the
particle mesh Ewald grid

\sphinxstylestrong{GROUPS Subroutine}

“groups” tests a set of atoms to see if all are members of a
single atom group or a pair of atom groups; if so, then the
correct intra\sphinxhyphen{} or intergroup weight is assigned

\sphinxstylestrong{GRPLINE Subroutine}

“grpline” tests each atom group for linearity of the sites
contained in the group

\sphinxstylestrong{GSORT Subroutine}

“gsort” uses the Gram\sphinxhyphen{}Schmidt algorithm to build orthogonal
vectors for sliding block interative matrix diagonalization

\sphinxstylestrong{GYRATE Subroutine}

“gyrate” computes the radius of gyration of a molecular system
from its atomic coordinates; only active atoms are included

\sphinxstylestrong{HANGLE Subroutine}

“hangle” constructs hybrid angle bending parameters given
an initial state, final state and “lambda” value

\sphinxstylestrong{HATOM Subroutine}

“hatom” assigns a new atom type to each hybrid site

\sphinxstylestrong{HBOND Subroutine}

“hbond” constructs hybrid bond stretch parameters given
an initial state, final state and “lambda” value

\sphinxstylestrong{HCHARGE Subroutine}

“hcharge” constructs hybrid charge interaction parameters
given an initial state, final state and “lambda” value

\sphinxstylestrong{HDIPOLE Subroutine}

“hdipole” constructs hybrid dipole interaction parameters
given an initial state, final state and “lambda” value

\sphinxstylestrong{HESSBLK Subroutine}

“hessblk” calls subroutines to calculate the Hessian elements
for each atom in turn with respect to Cartesian coordinates

\sphinxstylestrong{HESSIAN Subroutine}

“hessian” calls subroutines to calculate the Hessian elements
for each atom in turn with respect to Cartesian coordinates

\sphinxstylestrong{HESSRGD Subroutine}

“hessrgd” computes the numerical Hessian elements with
respect to rigid body coordinates via 6*ngroup+1 gradient
evaluations

\sphinxstylestrong{HESSROT Subroutine}

“hessrot” computes numerical Hessian elements with respect
to torsional angles; either the diagonal or the full matrix
can be calculated; the full matrix needs nomega+1 gradient
evaluations while the diagonal needs just two evaluations

\sphinxstylestrong{HETATOM Subroutine}

“hetatom” translates water molecules and ions in Protein Data
Bank format to a Cartesian coordinate file and sequence file

\sphinxstylestrong{HIMPTOR Subroutine}

“himptor” constructs hybrid improper torsional parameters
given an initial state, final state and “lambda” value

\sphinxstylestrong{HOOVER Subroutine}

“hoover” applies a combined thermostat and barostat via a
Nose\sphinxhyphen{}Hoover chain algorithm

\sphinxstylestrong{HSTRBND Subroutine}

“hstrbnd” constructs hybrid stretch\sphinxhyphen{}bend parameters given
an initial state, final state and “lambda” value

\sphinxstylestrong{HSTRTOR Subroutine}

“hstrtor” constructs hybrid stretch\sphinxhyphen{}torsion parameters
given an initial state, final state and “lambda” value

\sphinxstylestrong{HTORS Subroutine}

“htors” constructs hybrid torsional parameters for a given
initial state, final state and “lambda” value

\sphinxstylestrong{HVDW Subroutine}

“hvdw” constructs hybrid van der Waals  parameters given
an initial state, final state and “lambda” value

\sphinxstylestrong{HYBRID Subroutine}

“hybrid” constructs the hybrid hamiltonian for a specified
initial state, final state and mutation parameter “lambda”

\sphinxstylestrong{IJKPTS Subroutine}

“ijkpts” stores a set of indices used during calculation
of macroscopic reaction field energetics

\sphinxstylestrong{IMAGE Subroutine}

“image” takes the components of pairwise distance between
two points in a periodic box and converts to the components
of the minimum image distance

\sphinxstylestrong{IMAGEN Subroutine}

“imagen” takes the components of pairwise distance between
two points and converts to the components of the minimum
image distance

\sphinxstylestrong{IMAGER Subroutine}

“imager” takes the components of pairwise distance between
two points in the same or neighboring periodic boxes and
converts to the components of the minimum image distance

\sphinxstylestrong{IMPOSE Subroutine}

“impose” performs the least squares best superposition
of two atomic coordinate sets via a quaternion method;
upon return, the first coordinate set is unchanged while
the second set is translated and rotated to give best fit;
the final root mean square fit is returned in “rmsvalue”

\sphinxstylestrong{INDTCGA Subroutine}

“indtcga” computes the induced dipoles and intermediates used
in polarization force calculation for the TCG method with dp
cross terms = true, initial guess mu0 = 0 and using a diagonal
preconditioner

\sphinxstylestrong{INDTCGB Subroutine}

“indtcgb” computes the induced dipoles and intermediates used
in polarization force calculation for the TCG method with dp
cross terms = true, initial guess mu0 = direct and using diagonal
preconditioner

\sphinxstylestrong{INDUCE Subroutine}

“induce” computes the induced dipole moments at polarizable
sites due to direct or mutual polarization

\sphinxstylestrong{INDUCE0A Subroutine}

“induce0a” computes the induced dipole moments at polarizable
sites using a preconditioned conjugate gradient solver

\sphinxstylestrong{INDUCE0B Subroutine}

“induce0b” computes and stores the induced dipoles via
the truncated conjugate gradient (TCG) method

\sphinxstylestrong{INDUCE0C Subroutine}

“induce0c” computes the induced dipole moments at polarizable
sites for generalized Kirkwood SCRF and vacuum environments

\sphinxstylestrong{INDUCE0D Subroutine}

“induce0d” computes the induced dipole moments at polarizable
sites for Poisson\sphinxhyphen{}Boltzmann SCRF and vacuum environments

\sphinxstylestrong{INEDGE Subroutine}

“inedge” inserts a concave edge into the
linked list for its temporary torus

\sphinxstylestrong{INERTIA Subroutine}

“inertia” computes the principal moments of inertia for the
system, and optionally translates the center of mass to the
origin and rotates the principal axes onto the global axes

\sphinxstylestrong{INITATOM Subroutine}

“initatom” sets the atomic symbol, standard atomic weight,
van der Waals radius and covalent radius for each element in
the periodic table

\sphinxstylestrong{INITERR Function}

“initerr” is the initial error function and derivatives for
a distance geometry embedding; it includes components from
the local geometry and torsional restraint errors

\sphinxstylestrong{INITIAL Subroutine}

“initial” sets up original values for some parameters and
variables that might not otherwise get initialized

\sphinxstylestrong{INITMMFF Subroutine}

“initmmff” initializes some parameter values for the Merck
Molecular force field

\sphinxstylestrong{INITPRM Subroutine}

“initprm” completely initializes a force field by setting all
parameters to zero and using defaults for control values

\sphinxstylestrong{INITRES Subroutine}

“initres” sets biopolymer residue names and biotype codes used
in PDB file conversion and automated generation of structures

\sphinxstylestrong{INITROT Subroutine}

“initrot” sets the torsional angles which are to be rotated
in subsequent computation, by default automatically selects
all rotatable single bonds; optionally makes atoms inactive
when they are not moved by any torsional rotation

\sphinxstylestrong{INSERT Subroutine}

“insert” adds the specified atom to the Cartesian
coordinates list and shifts the remaining atoms

\sphinxstylestrong{INTEDIT Program}

“intedit” allows the user to extract information from
or alter the values within an internal coordinates file

\sphinxstylestrong{INTERPOL Subroutine}

“interpol” computes intergroup induced dipole moments for use
during removal of intergroup polarization

\sphinxstylestrong{INTXYZ Program}

“intxyz” takes as input an internal coordinates file,
converts to and then writes out Cartesian coordinates

\sphinxstylestrong{INVBETA Function}

“invbeta” computes the inverse Beta distribution function
via a combination of Newton iteration and bisection search

\sphinxstylestrong{INVERT Subroutine}

“invert” inverts a matrix using the Gauss\sphinxhyphen{}Jordan method

\sphinxstylestrong{IPEDGE Subroutine}

“ipedge” inserts convex edge into linked list for atom

\sphinxstylestrong{JACOBI Subroutine}

“jacobi” performs a matrix diagonalization of a real
symmetric matrix by the method of Jacobi rotations

\sphinxstylestrong{JUSTIFY Subroutine}

“justify” converts a text string to right justified format
with leading blank spaces

\sphinxstylestrong{KANGANG Subroutine}

“kangang” assigns the parameters for angle\sphinxhyphen{}angle cross term
interactions and processes new or changed parameter values

\sphinxstylestrong{KANGLE Subroutine}

“kangle” assigns the force constants and ideal angles for
the bond angles; also processes new or changed parameters

\sphinxstylestrong{KANGLEM Subroutine}

“kanglem” assigns the force constants and ideal angles for
bond angles according to the Merck Molecular Force Field (MMFF)

\sphinxstylestrong{KANGTOR Subroutine}

“kangtor” assigns parameters for angle\sphinxhyphen{}torsion interactions
and processes new or changed parameter values

\sphinxstylestrong{KATOM Subroutine}

“katom” assigns an atom type definitions to each atom in
the structure and processes any new or changed values

\sphinxstylestrong{KBOND Subroutine}

“kbond” assigns a force constant and ideal bond length
to each bond in the structure and processes any new or
changed parameter values

\sphinxstylestrong{KBONDM Subroutine}

“kbondm” assigns a force constant and ideal bond length to
each bond according to the Merck Molecular Force Field (MMFF)

\sphinxstylestrong{KCHARGE Subroutine}

“kcharge” assigns partial charges to the atoms within
the structure and processes any new or changed values

\sphinxstylestrong{KCHARGEM Subroutine}

“kchargem” assigns partial charges to the atoms according to
the Merck Molecular Force Field (MMFF)

\sphinxstylestrong{KCHGFLX Subroutine}

“kchgflx” assigns a force constant and ideal bond length
to each bond in the structure and processes any new or
changed parameter values

\sphinxstylestrong{KCHGTRN Subroutine}

“kchgtrn” assigns charge magnitude and damping parameters for
charge transfer interactions and processes any new or changed
values for these parameters

\sphinxstylestrong{KCHIRAL Subroutine}

“kchiral” determines the target value for each chirality
and planarity restraint as the signed volume of the
parallelpiped spanned by vectors from a common atom to
each of three other atoms

\sphinxstylestrong{KDIPOLE Subroutine}

“kdipole” assigns bond dipoles to the bonds within
the structure and processes any new or changed values

\sphinxstylestrong{KDISP Subroutine}

“kdisp” assigns C6 coefficients and damping parameters for
dispersion interactions and processes any new or changed
values for these parameters

\sphinxstylestrong{KENEG Subroutine}

“keneg” applies primary and secondary electronegativity bond
length corrections to applicable bond parameters

\sphinxstylestrong{KEWALD Subroutine}

“kewald” assigns particle mesh Ewald parameters and options
for a periodic system

\sphinxstylestrong{KEXTRA Subroutine}

“kextra” assigns parameters to any additional user defined
potential energy contribution

\sphinxstylestrong{KGB Subroutine}

“kgb” initializes parameters needed for the generalized
Born implicit solvation models

\sphinxstylestrong{KGEOM Subroutine}

“kgeom” asisgns parameters for geometric restraint terms
to be included in the potential energy calculation

\sphinxstylestrong{KGK Subroutine}

“kgk” initializes parameters needed for the generalized
Kirkwood implicit solvation model

\sphinxstylestrong{KHPMF Subroutine}

“khpmf” initializes parameters needed for the hydrophobic
potential of mean force nonpolar implicit solvation model

\sphinxstylestrong{KIMPROP Subroutine}

“kimprop” assigns potential parameters to each improper
dihedral in the structure and processes any changed values

\sphinxstylestrong{KIMPTOR Subroutine}

“kimptor” assigns torsional parameters to each improper
torsion in the structure and processes any changed values

\sphinxstylestrong{KINAUX Subroutine}

“kinaux” computes the total kinetic energy and temperature
for auxiliary dipole variables used in iEL polarization

\sphinxstylestrong{KINETIC Subroutine}

“kinetic” computes the total kinetic energy and kinetic energy
contributions to the pressure tensor by summing over velocities

\sphinxstylestrong{KMETAL Subroutine}

“kmetal” assigns ligand field parameters to transition metal
atoms and processes any new or changed parameter values

\sphinxstylestrong{KMPOLE Subroutine}

“kmpole” assigns atomic multipole moments to the atoms of
the structure and processes any new or changed values

\sphinxstylestrong{KNP Subroutine}

“knp” initializes parameters needed for the cavity\sphinxhyphen{}plus\sphinxhyphen{}
dispersion nonpolar implicit solvation model

\sphinxstylestrong{KONVEC Subroutine}

“konvec” finds a Hessian\sphinxhyphen{}vector product via finite\sphinxhyphen{}difference
evaluation of the gradient based on atomic displacements

\sphinxstylestrong{KOPBEND Subroutine}

“kopbend” assigns the force constants for out\sphinxhyphen{}of\sphinxhyphen{}plane bends
at trigonal centers via Wilson\sphinxhyphen{}Decius\sphinxhyphen{}Cross or Allinger angles;
also processes any new or changed parameter values

\sphinxstylestrong{KOPBENDM Subroutine}

“kopbendm” assigns the force constants for out\sphinxhyphen{}of\sphinxhyphen{}plane bends
according to the Merck Molecular Force Field (MMFF)

\sphinxstylestrong{KOPDIST Subroutine}

“kopdist” assigns the force constants for out\sphinxhyphen{}of\sphinxhyphen{}plane
distance at trigonal centers via the central atom height;
also processes any new or changed parameter values

\sphinxstylestrong{KORBIT Subroutine}

“korbit” assigns pi\sphinxhyphen{}orbital parameters to conjugated systems
and processes any new or changed parameters

\sphinxstylestrong{KPB Subroutine}

“kpb” assigns parameters needed for the Poisson\sphinxhyphen{}Boltzmann
implicit solvation model implemented via APBS

\sphinxstylestrong{KPITORS Subroutine}

“kpitors” assigns pi\sphinxhyphen{}system torsion parameters to torsions
needing them, and processes any new or changed values

\sphinxstylestrong{KPOLAR Subroutine}

“kpolar” assigns atomic dipole polarizabilities to the atoms
within the structure and processes any new or changed values

\sphinxstylestrong{KREPEL Subroutine}

“krepel” assigns the size values, exponential parameter and
number of valence electrons for Pauli repulsion interactions
and processes any new or changed values for these parameters

\sphinxstylestrong{KSA Subroutine}

“ksa” initializes parameters needed for surface area\sphinxhyphen{}based
implicit solvation models including ASP and SASA

\sphinxstylestrong{KSOLV Subroutine}

“ksolv” assigns implicit solvation energy parameters for
the surface area, generalized Born, generalized Kirkwood,
Poisson\sphinxhyphen{}Boltzmann, cavity\sphinxhyphen{}dispersion and HPMF models

\sphinxstylestrong{KSTRBND Subroutine}

“kstrbnd” assigns parameters for stretch\sphinxhyphen{}bend interactions
and processes new or changed parameter values

\sphinxstylestrong{KSTRBNDM Subroutine}

“kstrbndm” assigns parameters for stretch\sphinxhyphen{}bend interactions
according to the Merck Molecular Force Field (MMFF)

\sphinxstylestrong{KSTRTOR Subroutine}

“kstrtor” assigns stretch\sphinxhyphen{}torsion parameters to torsions
needing them, and processes any new or changed values

\sphinxstylestrong{KTORS Subroutine}

“ktors” assigns torsional parameters to each torsion in
the structure and processes any new or changed values

\sphinxstylestrong{KTORSM Subroutine}

“ktorsm” assigns torsional parameters to each torsion according
to the Merck Molecular Force Field (MMFF)

\sphinxstylestrong{KTORTOR Subroutine}

“ktortor” assigns torsion\sphinxhyphen{}torsion parameters to adjacent
torsion pairs and processes any new or changed values

\sphinxstylestrong{KUREY Subroutine}

“kurey” assigns the force constants and ideal distances
for the Urey\sphinxhyphen{}Bradley 1\sphinxhyphen{}3 interactions; also processes any
new or changed parameter values

\sphinxstylestrong{KVDW Subroutine}

“kvdw” assigns the parameters to be used in computing the
van der Waals interactions and processes any new or changed
values for these parameters

\sphinxstylestrong{LATTICE Subroutine}

“lattice” stores the periodic box dimensions and sets angle
values to be used in computing fractional coordinates

\sphinxstylestrong{LBFGS Subroutine}

“lbfgs” is a limited memory BFGS quasi\sphinxhyphen{}newton nonlinear
optimization routine

\sphinxstylestrong{LIGASE Subroutine}

“ligase” translates a nucleic acid structure in Protein Data
Bank format to a Cartesian coordinate file and sequence file

\sphinxstylestrong{LIGHTS Subroutine}

“lights” computes the set of nearest neighbor interactions
using the method of lights algorithm

\sphinxstylestrong{LINBODY Subroutine}

“linbody” finds the angular velocity of a linear rigid body
given the inertia tensor and angular momentum

\sphinxstylestrong{LMSTEP Subroutine}

“lmstep” computes a Levenberg\sphinxhyphen{}Marquardt step during a nonlinear
least squares calculation using ideas from the MINPACK LMPAR
routine and the internal doubling strategy of Dennis and Schnabel

\sphinxstylestrong{LOCALMIN Subroutine}

“localmin” is used during normal mode local search to
perform a Cartesian coordinate energy minimization

\sphinxstylestrong{LOCALRGD Subroutine}

“localrgd” is used during the PSS local search procedure
to perform a rigid body energy minimization

\sphinxstylestrong{LOCALROT Subroutine}

“localrot” is used during the PSS local search procedure
to perform a torsional space energy minimization

\sphinxstylestrong{LOCALXYZ Subroutine}

“localxyz” is used during the potential smoothing and search
procedure to perform a local optimization at the current
smoothing level

\sphinxstylestrong{LOCERR Function}

“locerr” is the local geometry error function and derivatives
including the 1\sphinxhyphen{}2, 1\sphinxhyphen{}3 and 1\sphinxhyphen{}4 distance bound restraints

\sphinxstylestrong{LOWCASE Subroutine}

“lowcase” converts a text string to all lower case letters

\sphinxstylestrong{MAJORIZE Subroutine}

“majorize” refines the projected coordinates by attempting to
minimize the least square residual between the trial distance
matrix and the distances computed from the coordinates

\sphinxstylestrong{MAKEBAR Subroutine}

\sphinxstylestrong{MAKEBOX Subroutine}

“makebox” builds a periodic box of a desired size by randomly
copying a specified number of monomers into a target box size,
followed by optional excluded volume refinement

\sphinxstylestrong{MAKEINT Subroutine}

“makeint” converts Cartesian to internal coordinates where
selection of internal coordinates is controlled by “mode”

\sphinxstylestrong{MAKEPDB Subroutine}

“makepdb” cconstructs a Protein Data Bank file from a set
of Cartesian coordinates with special handling for systems
consisting of biopolymer chains, ligands and water molecules

\sphinxstylestrong{MAKEREF Subroutine}

“makeref” copies the information contained in the “xyz” file
of the current structure into corresponding reference areas

\sphinxstylestrong{MAKEXYZ Subroutine}

“makexyz” generates a complete set of Cartesian coordinates
for a full structure from the internal coordinate values

\sphinxstylestrong{MAPCHECK Subroutine}

“mapcheck” checks the current minimum energy structure
for possible addition to the master list of local minima

\sphinxstylestrong{MATCH1 Subroutine}

“match1” finds and stores the first multipole component found
on a line of output from Stone’s GDMA program

\sphinxstylestrong{MATCH2 Subroutine}

“match2” finds and stores the second multipole component found
on a line of output from Stone’s GDMA program

\sphinxstylestrong{MATCH3 Subroutine}

“match3” finds and stores the third multipole component found
on a line of output from Stone’s GDMA program

\sphinxstylestrong{MAXWELL Function}

“maxwell” returns a speed in Angstroms/picosecond randomly
selected from a 3\sphinxhyphen{}D Maxwell\sphinxhyphen{}Boltzmann distribution for the
specified particle mass and system temperature

\sphinxstylestrong{MBUILD Subroutine}

“mbuild” performs a complete rebuild of the atomic multipole
electrostatic neighbor list for all sites

\sphinxstylestrong{MCM1 Function}

“mcm1” is a service routine that computes the energy and
gradient for truncated Newton optimization in Cartesian
coordinate space

\sphinxstylestrong{MCM2 Subroutine}

“mcm2” is a service routine that computes the sparse matrix
Hessian elements for truncated Newton optimization in Cartesian
coordinate space

\sphinxstylestrong{MCMSTEP Function}

“mcmstep” implements the minimization phase of an MCM step
via Cartesian minimization following a Monte Carlo step

\sphinxstylestrong{MDINIT Subroutine}

“mdinit” initializes the velocities and accelerations
for a molecular dynamics trajectory, including restarts

\sphinxstylestrong{MDREST Subroutine}

“mdrest” finds and removes any translational or rotational
kinetic energy of the overall system center of mass

\sphinxstylestrong{MDSAVE Subroutine}

“mdsave” writes molecular dynamics trajectory snapshots and
auxiliary files with velocity, force or induced dipole data;
also checks for user requested termination of a simulation

\sphinxstylestrong{MDSTAT Subroutine}

“mdstat” is called at each molecular dynamics time step to
form statistics on various average values and fluctuations,
and to periodically save the state of the trajectory

\sphinxstylestrong{MEASFN Subroutine}

\sphinxstylestrong{MEASFQ Subroutine}

\sphinxstylestrong{MEASFS Subroutine}

\sphinxstylestrong{MEASPM Subroutine}

“measpm” computes the volume of a single prism section of
the full interior polyhedron

\sphinxstylestrong{MECHANIC Subroutine}

“mechanic” sets up needed parameters for the potential energy
calculation and reads in many of the user selectable options

\sphinxstylestrong{MERGE Subroutine}

“merge” combines the reference and current structures into
a single new “current” structure containing the reference
atoms followed by the atoms of the current structure

\sphinxstylestrong{METRIC Subroutine}

“metric” takes as input the trial distance matrix and computes
the metric matrix of all possible dot products between the atomic
vectors and the center of mass using the law of cosines and the
following formula for the distances to the center of mass:

\sphinxstylestrong{MIDERR Function}

“miderr” is the secondary error function and derivatives
for a distance geometry embedding; it includes components
from the distance bounds, local geometry, chirality and
torsional restraint errors

\sphinxstylestrong{MINIMIZ1 Function}

“minimiz1” is a service routine that computes the energy and
gradient for a low storage BFGS optimization in Cartesian
coordinate space

\sphinxstylestrong{MINIMIZE Program}

“minimize” performs energy minimization in Cartesian coordinate
space using a low storage BFGS nonlinear optimization

\sphinxstylestrong{MINIROT Program}

“minirot” performs an energy minimization in torsional
angle space using a low storage BFGS nonlinear optimization

\sphinxstylestrong{MINIROT1 Function}

“minirot1” is a service routine that computes the energy
and gradient for a low storage BFGS nonlinear optimization
in torsional angle space

\sphinxstylestrong{MINPATH Subroutine}

“minpath” is a routine for finding the triangle smoothed upper
and lower bounds of each atom to a specified root atom using a
sparse variant of the Bellman\sphinxhyphen{}Ford shortest path algorithm

\sphinxstylestrong{MINRIGID Program}

“minrigid” performs an energy minimization of rigid body atom
groups using a low storage BFGS nonlinear optimization

\sphinxstylestrong{MINRIGID1 Function}

“minrigid1” is a service routine that computes the energy
and gradient for a low storage BFGS nonlinear optimization
of rigid bodies

\sphinxstylestrong{MLIGHT Subroutine}

“mlight” performs a complete rebuild of the atomic multipole
pair neighbor list for all sites using the method of lights

\sphinxstylestrong{MLIST Subroutine}

“mlist” performs an update or a complete rebuild of the
nonbonded neighbor lists for atomic multipoles

\sphinxstylestrong{MMID Subroutine}

“mmid” implements a modified midpoint method to advance the
integration of a set of first order differential equations

\sphinxstylestrong{MODECART Subroutine}

\sphinxstylestrong{MODERGD Subroutine}

\sphinxstylestrong{MODEROT Subroutine}

\sphinxstylestrong{MODESRCH Subroutine}

\sphinxstylestrong{MODETORS Subroutine}

\sphinxstylestrong{MODULI Subroutine}

“moduli” sets the moduli of the inverse discrete Fourier
transform of the B\sphinxhyphen{}splines

\sphinxstylestrong{MOL2XYZ Program}

“mol2xyz” takes as input a Tripos MOL2 coordinates file,
converts to and then writes out Cartesian coordinates

\sphinxstylestrong{MOLECULE Subroutine}

“molecule” counts the molecules, assigns each atom to
its molecule and computes the mass of each molecule

\sphinxstylestrong{MOLMERGE Subroutine}

“molmerge” connects fragments and removes duplicate atoms
during generation of a unit cell from an asymmetric unit

\sphinxstylestrong{MOLSETUP Subroutine}

“molsetup” generates trial parameters needed to perform
polarizable multipole calculations on a structure read
from distributed multipole analysis output

\sphinxstylestrong{MOLUIND Subroutine}

“moluind” computes the molecular induced dipole components
in the presence of an external electric field

\sphinxstylestrong{MOLXYZ Program}

“molxyz” takes as input a MDL MOL coordinates file,
converts to and then writes out Cartesian coordinates

\sphinxstylestrong{MOMENTS Subroutine}

“moments” computes the total electric charge, dipole and
quadrupole moments for the active atoms as a sum over the
partial charges, bond dipoles and atomic multipole moments

\sphinxstylestrong{MOMFULL Subroutine}

“momfull” computes the electric moments for the full system
as a sum over the partial charges, bond dipoles and atomic
multipole moments

\sphinxstylestrong{MOMYZE Subroutine}

“momyze” finds and prints the total charge, dipole moment
components, radius of gyration and moments of inertia

\sphinxstylestrong{MONTE Program}

“monte” performs a Monte Carlo\sphinxhyphen{}Minimization conformational
search using Cartesian single atom or torsional move sets

\sphinxstylestrong{MUTATE Subroutine}

“mutate” constructs the hybrid hamiltonian for a specified
initial state, final state and mutation parameter “lambda”

\sphinxstylestrong{NBLIST Subroutine}

“nblist” builds and maintains nonbonded pair neighbor lists
for vdw, dispersion, electrostatic and polarization terms

\sphinxstylestrong{NEARBY Subroutine}

“nearby” finds all of the through\sphinxhyphen{}space neighbors of each
atom for use in surface area and volume calculations

\sphinxstylestrong{NEEDUPDATE Subroutine}

\sphinxstylestrong{NEWATM Subroutine}

“newatm” creates and defines an atom needed for the
Cartesian coordinates file, but which may not present
in the original Protein Data Bank file

\sphinxstylestrong{NEWTON Program}

“newton” performs an energy minimization in Cartesian
coordinate space using a truncated Newton method

\sphinxstylestrong{NEWTON1 Function}

“newton1” is a service routine that computes the energy
and gradient for truncated Newton optimization in Cartesian
coordinate space

\sphinxstylestrong{NEWTON2 Subroutine}

“newton2” is a service routine that computes the sparse
matrix Hessian elements for truncated Newton optimization
in Cartesian coordinate space

\sphinxstylestrong{NEWTROT Program}

“newtrot” performs an energy minimization in torsional angle
space using a truncated Newton conjugate gradient method

\sphinxstylestrong{NEWTROT1 Function}

“newtrot1” is a service routine that computes the energy
and gradient for truncated Newton conjugate gradient
optimization in torsional angle space

\sphinxstylestrong{NEWTROT2 Subroutine}

“newtrot2” is a service routine that computes the sparse
matrix Hessian elements for truncated Newton optimization
in torsional angle space

\sphinxstylestrong{NEXTARG Subroutine}

“nextarg” finds the next unused command line argument
and returns it in the input character string

\sphinxstylestrong{NEXTTEXT Function}

“nexttext” finds and returns the location of the first
non\sphinxhyphen{}blank character within an input text string; zero
is returned if no such character is found

\sphinxstylestrong{NORMAL Function}

“normal” generates a random number from a normal Gaussian
distribution with a mean of zero and a variance of one

\sphinxstylestrong{NOSE Subroutine}

“nose” performs a single molecular dynamics time step via
a Nose\sphinxhyphen{}Hoover extended system isothermal\sphinxhyphen{}isobaric algorithm

\sphinxstylestrong{NSPLINE Subroutine}

“nspline” computes coefficients for an nonperiodic cubic spline
with natural boundary conditions where the first and last second
derivatives are already known

\sphinxstylestrong{NUCBASE Subroutine}

“nucbase” builds the side chain for a single nucleotide base
in terms of internal coordinates

\sphinxstylestrong{NUCCHAIN Subroutine}

“nucchain” builds up the internal coordinates for a nucleic
acid sequence from the sugar type, backbone and glycosidic
torsional values

\sphinxstylestrong{NUCLEIC Program}

“nucleic” builds the internal and Cartesian coordinates
of a polynucleotide from nucleic acid sequence and torsional
angle values for the nucleic acid backbone and side chains

\sphinxstylestrong{NUMBER Function}

“number” converts a text numeral into an integer value;
the input string must contain only numeric characters

\sphinxstylestrong{NUMERAL Subroutine}

“numeral” converts an input integer number into the
corresponding right\sphinxhyphen{} or left\sphinxhyphen{}justified text numeral

\sphinxstylestrong{NUMGRAD Subroutine}

“numgrad” computes the gradient of the objective function
“fvalue” with respect to Cartesian coordinates of the atoms
via a one\sphinxhyphen{}sided or two\sphinxhyphen{}sided numerical differentiation

\sphinxstylestrong{OCVM Subroutine}

“ocvm” is an optimally conditioned variable metric nonlinear
optimization routine without line searches

\sphinxstylestrong{OLDATM Subroutine}

“oldatm” get the Cartesian coordinates for an atom from
the Protein Data Bank file, then assigns the atom type
and atomic connectivities

\sphinxstylestrong{OPBGUESS Function}

“opbguess” sets approximate out\sphinxhyphen{}of\sphinxhyphen{}plane bend force constants
based on atom type and connected atoms

\sphinxstylestrong{OPENEND Subroutine}

“openend” opens a file on a Fortran unit such that the position
is set to the bottom for appending to the end of the file

\sphinxstylestrong{OPREP Subroutine}

“oprep” sets up the frictional and random terms needed to
update positions and velocities for the BAOAB integrator

\sphinxstylestrong{OPTFIT Function}

\sphinxstylestrong{OPTIMIZ1 Function}

“optimiz1” is a service routine that computes the energy and
gradient for optimally conditioned variable metric optimization
in Cartesian coordinate space

\sphinxstylestrong{OPTIMIZE Program}

“optimize” performs energy minimization in Cartesian coordinate
space using an optimally conditioned variable metric method

\sphinxstylestrong{OPTINIT Subroutine}

“optinit” initializes values and keywords used by multiple
structure optimization methods

\sphinxstylestrong{OPTIROT Program}

“optirot” performs an energy minimization in torsional angle
space using an optimally conditioned variable metric method

\sphinxstylestrong{OPTIROT1 Function}

“optirot1” is a service routine that computes the energy and
gradient for optimally conditioned variable metric optimization
in torsional angle space

\sphinxstylestrong{OPTRIGID Program}

“optrigid” performs an energy minimization of rigid body atom
groups using an optimally conditioned variable metric method

\sphinxstylestrong{OPTRIGID1 Function}

“optrigid1” is a service routine that computes the energy
and gradient for optimally conditioned variable metric
optimization of rigid bodies

\sphinxstylestrong{OPTSAVE Subroutine}

“optsave” is used by the optimizers to write imtermediate
coordinates and other relevant information; also checks for
user requested termination of an optimization

\sphinxstylestrong{ORBITAL Subroutine}

“orbital” finds and organizes lists of atoms in a pisystem,
bonds connecting pisystem atoms and torsions whose central
atoms are both pisystem atoms

\sphinxstylestrong{ORIENT Subroutine}

“orient” computes a set of reference Cartesian coordinates
in standard orientation for each rigid body atom group

\sphinxstylestrong{ORTHOG Subroutine}

“orthog” performs an orthogonalization of an input matrix
via the modified Gram\sphinxhyphen{}Schmidt algorithm

\sphinxstylestrong{OVERLAP Subroutine}

“overlap” computes the overlap for two parallel p\sphinxhyphen{}orbitals
given the atomic numbers and distance of separation

\sphinxstylestrong{PARAMYZE Subroutine}

“paramyze” prints the force field parameters used in the
computation of each of the potential energy terms

\sphinxstylestrong{PARTYZE Subroutine}

“partyze” prints the energy component and number of
interactions for each of the potential energy terms

\sphinxstylestrong{PASSB Subroutine}

\sphinxstylestrong{PASSB2 Subroutine}

\sphinxstylestrong{PASSB3 Subroutine}

\sphinxstylestrong{PASSB4 Subroutine}

\sphinxstylestrong{PASSB5 Subroutine}

\sphinxstylestrong{PASSF Subroutine}

\sphinxstylestrong{PASSF2 Subroutine}

\sphinxstylestrong{PASSF3 Subroutine}

\sphinxstylestrong{PASSF4 Subroutine}

\sphinxstylestrong{PASSF5 Subroutine}

\sphinxstylestrong{PATH Program}

“path” locates a series of structures equally spaced along
a conformational pathway connecting the input reactant and
product structures; a series of constrained optimizations
orthogonal to the path is done via Lagrangian multipliers

\sphinxstylestrong{PATH1 Function}

\sphinxstylestrong{PATHPNT Subroutine}

“pathpnt” finds a structure on the synchronous transit path
with the specified path value “tpath”

\sphinxstylestrong{PATHSCAN Subroutine}

“pathscan” makes a scan of a synchronous transit pathway by
computing structures and energies for specific path values

\sphinxstylestrong{PATHVAL Subroutine}

“pathval” computes the synchronous transit path value for
the specified structure

\sphinxstylestrong{PAULING Subroutine}

“pauling” uses a rigid body optimization to approximately
pack multiple polypeptide chains

\sphinxstylestrong{PAULING1 Function}

“pauling1” is a service routine that computes the energy
and gradient for optimally conditioned variable metric
optimization of rigid bodies

\sphinxstylestrong{PBDIRECTPOLFORCE Subroutine}

\sphinxstylestrong{PBEMPOLE Subroutine}

“pbempole” calculates the permanent multipole PB energy,
field, forces and torques

\sphinxstylestrong{PBMUTUALPOLFORCE Subroutine}

\sphinxstylestrong{PDBATOM Subroutine}

“pdbatom” adds an atom to the Protein Data Bank file

\sphinxstylestrong{PDBXYZ Program}

“pdbxyz” takes as input a Protein Data Bank file and then
converts to and writes out a Cartesian coordinates file and,
for biopolymers, a sequence file

\sphinxstylestrong{PIALTER Subroutine}

“pialter” modifies bond lengths and force constants according
to the “planar” P\sphinxhyphen{}P\sphinxhyphen{}P bond order values; also alters 2\sphinxhyphen{}fold
torsional parameters based on the “nonplanar” bond orders

\sphinxstylestrong{PICALC Subroutine}

“picalc” performs a modified Pariser\sphinxhyphen{}Parr\sphinxhyphen{}Pople molecular
orbital calculation for each conjugated pisystem

\sphinxstylestrong{PIMOVE Subroutine}

“pimove” rotates the vector between atoms “list(1)” and
“list(2)” so that atom 1 is at the origin and atom 2 along
the x\sphinxhyphen{}axis; the atoms defining the respective planes are
also moved and their bond lengths normalized

\sphinxstylestrong{PIPLANE Subroutine}

“piplane” selects the three atoms which specify the plane
perpendicular to each p\sphinxhyphen{}orbital; the current version will
fail in certain situations, including ketenes, allenes,
and isolated or adjacent triple bonds

\sphinxstylestrong{PISCF Subroutine}

“piscf” performs an SCF molecular orbital calculation for a
pisystem to determine bond orders used in parameter scaling

\sphinxstylestrong{PITILT Subroutine}

“pitilt” calculates for each pibond the ratio of the
actual p\sphinxhyphen{}orbital overlap integral to the ideal overlap
if the same orbitals were perfectly parallel

\sphinxstylestrong{PLACE Subroutine}

“place” finds the probe sites by putting the probe sphere
tangent to each triple of neighboring atoms

\sphinxstylestrong{PMONTE Subroutine}

“pmonte” implements a Monte Carlo barostat via random trial
changes in the periodic box volume and shape

\sphinxstylestrong{POLARGRP Subroutine}

“polargrp” generates members of the polarization group of
each atom and separate lists of the 1\sphinxhyphen{}2, 1\sphinxhyphen{}3 and 1\sphinxhyphen{}4 group
connectivities

\sphinxstylestrong{POLARIZE Program}

“polarize” computes the molecular polarizability by applying
an external field along each axis followed by diagonalization
of the resulting polarizability tensor

\sphinxstylestrong{POLEDIT Program}

“poledit” provides for the modification and manipulation
of polarizable atomic multipole electrostatic models

\sphinxstylestrong{POLESORT Subroutine}

“polesort” sorts a set of atomic multipole parameters based
on the atom types of centers involved

\sphinxstylestrong{POLYMER Subroutine}

“polymer” tests for the presence of an infinite polymer
extending across periodic boundaries

\sphinxstylestrong{POLYP Subroutine}

“polyp” is a polynomial product routine that multiplies two
algebraic forms

\sphinxstylestrong{POTENTIAL Program}

“potential” calculates the electrostatic potential for a
molecule at a set of grid points; optionally compares to a
target potential or optimizes electrostatic parameters

\sphinxstylestrong{POTGRID Subroutine}

“potgrid” generates electrostatic potential grid points in
radially distributed shells based on the molecular surface

\sphinxstylestrong{POTNRG Function}

\sphinxstylestrong{POTOFF Subroutine}

“potoff” clears the forcefield definition by turning off
the use of each of the potential energy functions

\sphinxstylestrong{POTPOINT Subroutine}

“potpoint” calculates the electrostatic potential at a grid
point “i” as the total electrostatic interaction energy of
the system with a positive charge located at the grid point

\sphinxstylestrong{POTSTAT Subroutine}

“potstat” computes and prints statistics for the electrostatic
potential over a set of grid points

\sphinxstylestrong{POTWRT Subroutine}

\sphinxstylestrong{PRECONBLK Subroutine}

“preconblk” applies a preconditioner to an atom block section
of the Hessian matrix

\sphinxstylestrong{PRECOND Subroutine}

“precond” solves a simplified version of the Newton equations
Ms = r, and uses the result to precondition linear conjugate
gradient iterations on the full Newton equations in “tnsolve”

\sphinxstylestrong{PRESSURE Subroutine}

“pressure” uses the internal virial to find the pressure
in a periodic box and maintains a constant desired pressure
via a barostat method

\sphinxstylestrong{PRESSURE2 Subroutine}

“pressure2” applies a box size and velocity correction at
the half time step as needed for the Monte Carlo barostat

\sphinxstylestrong{PRIORITY Function}

“priority” decides which of a set of connected atoms should
have highest priority in construction of a local coordinate
frame and returns its atom number; if all atoms are of equal
priority then zero is returned

\sphinxstylestrong{PRMEDIT Program}

“prmedit” reformats an existing parameter file, and revises
type and class numbers based on the “atom” parameter ordering

\sphinxstylestrong{PRMFORM Subroutine}

“prmform” formats each individual parameter record to conform
to a consistent text layout

\sphinxstylestrong{PRMKEY Subroutine}

“prmkey” parses a text string to extract keywords related to
force field potential energy functional forms and constants

\sphinxstylestrong{PRMORDER Subroutine}

“prmorder” places a list of atom type or class numbers into
canonical order for potential energy parameter definitions

\sphinxstylestrong{PRMSORT Subroutine}

“prmsort” places a list of atom type or class numbers into
canonical order for potential energy parameter definitions

\sphinxstylestrong{PRMVAR Subroutine}

“prmvar” determines the optimization values from the
corresponding electrostatic potential energy parameters

\sphinxstylestrong{PRMVAR Subroutine}

“prmvar” determines the optimization values from the
corresponding valence potential energy parameters

\sphinxstylestrong{PROCHAIN Subroutine}

“prochain” builds up the internal coordinates for an amino
acid sequence from the phi, psi, omega and chi values

\sphinxstylestrong{PROJCT Subroutine}

\sphinxstylestrong{PROJECT Subroutine}

“project” reads locked vectors from a binary file and projects
them out of the components of the set of trial eigenvectors
using the relation Y = X \sphinxhyphen{} U * U\textasciicircum{}T * X

\sphinxstylestrong{PROJECTK Subroutine}

“projectk” reads locked vectors from a binary file and projects
them out of the components of the set of trial eigenvectors
using the relation Y = X \sphinxhyphen{} U * U\textasciicircum{}T * X

\sphinxstylestrong{PROMO Subroutine}

“promo” writes a banner message containing information
about the Tinker version, release date and copyright notice

\sphinxstylestrong{PROPERTY Function}

“property” takes two input snapshot frames and computes the
value of the property for which the correlation function is
being accumulated

\sphinxstylestrong{PROSIDE Subroutine}

“proside” builds the side chain for a single amino acid
residue in terms of internal coordinates

\sphinxstylestrong{PROTEIN Program}

“protein” builds the internal and Cartesian coordinates
of a polypeptide from amino acid sequence and torsional
angle values for the peptide backbone and side chains

\sphinxstylestrong{PRTARC Subroutine}

“prtarc” writes out a set of Cartesian coordinates for
all active atoms in the Tinker XYZ archive format

\sphinxstylestrong{PRTDYN Subroutine}

“prtdyn” writes out the information needed to restart a
molecular dynamics trajectory to an external disk file

\sphinxstylestrong{PRTERR Subroutine}

“prterr” writes out a set of coordinates to a disk
file prior to aborting on a serious error

\sphinxstylestrong{PRTFIT Subroutine}

“prtfit” makes a key file containing results from fitting a
charge or multipole model to an electrostatic potential grid

\sphinxstylestrong{PRTINT Subroutine}

“prtint” writes out a set of Z\sphinxhyphen{}matrix internal
coordinates to an external disk file

\sphinxstylestrong{PRTMOD Subroutine}

“prtmod” writes out a set of modified Cartesian coordinates
with an optional atom number offset to an external disk file

\sphinxstylestrong{PRTMOL2 Program}

“prtmol2” writes out a set of coordinates in Tripos MOL2
format to an external disk file

\sphinxstylestrong{PRTPDB Subroutine}

“prtpdb” writes out a set of Protein Data Bank coordinates
to an external disk file

\sphinxstylestrong{PRTPOLE Subroutine}

“prtpole” creates a coordinates file, and a key file with
atomic multipoles corrected for intergroup polarization

\sphinxstylestrong{PRTPRM Subroutine}

“prtprm” writes out a formatted listing of the default
set of potential energy parameters for a force field

\sphinxstylestrong{PRTSEQ Subroutine}

“prtseq” writes out a biopolymer sequence to an external
disk file with 15 residues per line and distinct chains
separated by blank lines

\sphinxstylestrong{PRTVAL Subroutine}

“prtval” writes the final valence parameter results to the
standard output and appends the values to a key file

\sphinxstylestrong{PRTVIB Subroutine}

“prtvib” writes to an external disk file a series of
coordinate sets representing motion along a vibrational
normal mode

\sphinxstylestrong{PRTXYZ Subroutine}

“prtxyz” writes out a set of Cartesian coordinates
to an external disk file

\sphinxstylestrong{PSCALE Subroutine}

“pscale” implements a Berendsen barostat by scaling the
coordinates and box dimensions via coupling to an external
constant pressure bath

\sphinxstylestrong{PSS Program}

“pss” implements the potential smoothing plus search method
for global optimization in Cartesian coordinate space with
local searches performed in Cartesian or torsional space

\sphinxstylestrong{PSS1 Function}

“pss1” is a service routine that computes the energy
and gradient during PSS global optimization in Cartesian
coordinate space

\sphinxstylestrong{PSS2 Subroutine}

“pss2” is a service routine that computes the sparse
matrix Hessian elements during PSS global optimization
in Cartesian coordinate space

\sphinxstylestrong{PSSRGD1 Function}

“pssrgd1” is a service routine that computes the energy and
gradient during PSS global optimization over rigid bodies

\sphinxstylestrong{PSSRIGID Program}

“pssrigid” implements the potential smoothing plus search method
for global optimization for a set of rigid bodies

\sphinxstylestrong{PSSROT Program}

“pssrot” implements the potential smoothing plus search method
for global optimization in torsional space

\sphinxstylestrong{PSSROT1 Function}

“pssrot1” is a service routine that computes the energy and
gradient during PSS global optimization in torsional space

\sphinxstylestrong{PSSWRITE Subroutine}

\sphinxstylestrong{PTEST Subroutine}

“ptest” determines the numerical virial tensor, and compares
analytical to numerical values for dE/dV and isotropic pressure

\sphinxstylestrong{PTINCY Function}

\sphinxstylestrong{PZEXTR Subroutine}

“pzextr” is a polynomial extrapolation routine used during
Bulirsch\sphinxhyphen{}Stoer integration of ordinary differential equations

\sphinxstylestrong{QIROTMAT Subroutine}

“qirotmat” finds a rotation matrix that describes the
interatomic vector

\sphinxstylestrong{QONVEC Subroutine}

“qonvec” is a vector utility routine used during sliding
block iterative matrix diagonalization

\sphinxstylestrong{QRFACT Subroutine}

“qrfact” computes the QR factorization of an m by n matrix a
via Householder transformations with optional column pivoting;
the routine determines an orthogonal matrix q, a permutation
matrix p, and an upper trapezoidal matrix r with diagonal
elements of nonincreasing magnitude, such that a*p = q*r; the
Householder transformation for column k, k = 1,2,…,min(m,n),
is of the form:

\sphinxstylestrong{QRSOLVE Subroutine}

“qrsolve” solves a*x = b and d*x = 0 in the least squares sense;
used with routine “qrfact” to solve least squares problems

\sphinxstylestrong{QUATFIT Subroutine}

“quatfit” uses a quaternion\sphinxhyphen{}based method to achieve the best
fit superposition of two sets of coordinates

\sphinxstylestrong{RADIAL Program}

“radial” finds the radial distribution function for a specified
pair of atom types via analysis of a set of coordinate frames

\sphinxstylestrong{RANDOM Function}

“random” generates a random number on {[}0,1{]} via a long
period generator due to L’Ecuyer with Bays\sphinxhyphen{}Durham shuffle

\sphinxstylestrong{RANVEC Subroutine}

“ranvec” generates a unit vector in 3\sphinxhyphen{}dimensional
space with uniformly distributed random orientation

\sphinxstylestrong{RATTLE Subroutine}

“rattle” implements the first portion of the RATTLE algorithm
by correcting atomic positions and half\sphinxhyphen{}step velocities to
maintain interatomic distance and absolute spatial constraints

\sphinxstylestrong{RATTLE2 Subroutine}

“rattle2” implements the second portion of the RATTLE algorithm
by correcting the full\sphinxhyphen{}step velocities in order to maintain
interatomic distance constraints

\sphinxstylestrong{READBLK Subroutine}

“readblk” reads in a set of snapshot frames and transfers
the values to internal arrays for use in the computation
of time correlation functions

\sphinxstylestrong{READDYN Subroutine}

“readdyn” get the positions, velocities and accelerations
for a molecular dynamics restart from an external disk file

\sphinxstylestrong{READGARC Subroutine}

“readgarc” reads data from Gaussian archive section; each
entry is terminated with a backslash symbol

\sphinxstylestrong{READGAU Subroutine}

“readgau” reads an ab initio optimized structure, forces,
Hessian and frequencies from a Gaussian 09 output file

\sphinxstylestrong{READGDMA Subroutine}

“readgdma” takes the DMA output in spherical harmonics from
the GDMA program and converts to Cartesian multipoles in
the global coordinate frame

\sphinxstylestrong{READINT Subroutine}

“readint” gets a set of Z\sphinxhyphen{}matrix internal coordinates
from an external file

\sphinxstylestrong{READMOL Subroutine}

“readmol” gets a set of MDL MOL coordinates from
an external disk file

\sphinxstylestrong{READMOL2 Subroutine}

“readmol2” gets a set of Tripos MOL2 coordinates from an
external disk file

\sphinxstylestrong{READPDB Subroutine}

“readpdb” gets a set of Protein Data Bank coordinates
from an external disk file

\sphinxstylestrong{READPOT Subroutine}

“readpot” gets a set of grid points and target electrostatic
potential values from an external disk file

\sphinxstylestrong{READPRM Subroutine}

“readprm” processes the potential energy parameter file
in order to define the default force field parameters

\sphinxstylestrong{READSEQ Subroutine}

“readseq” gets a biopolymer sequence containing one or more
separate chains from an external file; all lines containing
sequence must begin with the starting sequence number, the
actual sequence is read from subsequent nonblank characters

\sphinxstylestrong{READXYZ Subroutine}

“readxyz” gets a set of Cartesian coordinates from
an external disk file

\sphinxstylestrong{REFINE Subroutine}

“refine” performs minimization of the atomic coordinates
of an initial crude embedded distance geometry structure versus
the bound, chirality, planarity and torsional error functions

\sphinxstylestrong{RELEASEMONITOR Subroutine}

\sphinxstylestrong{REPLICA Subroutine}

“replica” decides between images and replicates for generation
of periodic boundary conditions, and sets the cell replicate
list if the replicates method is to be used

\sphinxstylestrong{RESPA Subroutine}

“respa” performs a single multiple time step molecular dynamics
step using the reversible reference system propagation algorithm
(r\sphinxhyphen{}RESPA) via a Verlet core with the potential split into fast\sphinxhyphen{}
and slow\sphinxhyphen{}evolving portions

\sphinxstylestrong{RFINDEX Subroutine}

“rfindex” finds indices for each multipole site for use
in computing reaction field energetics

\sphinxstylestrong{RGDSTEP Subroutine}

“rgdstep” performs a single molecular dynamics time step
via a rigid body integration algorithm

\sphinxstylestrong{RIBOSOME Subroutine}

“ribosome” translates a polypeptide structure in Protein Data
Bank format to a Cartesian coordinate file and sequence file

\sphinxstylestrong{RIGIDXYZ Subroutine}

“rigidxyz” computes Cartesian coordinates for a rigid body
group via rotation and translation of reference coordinates

\sphinxstylestrong{RINGS Subroutine}

“rings” searches the structure for small rings and stores
their constituent atoms, and optionally reduces large rings
into their component smaller rings

\sphinxstylestrong{RMSERROR Subroutine}

“rmserror” computes the maximum absolute deviation and the
rms deviation from the distance bounds, and the number and
rms value of the distance restraint violations

\sphinxstylestrong{RMSFIT Function}

“rmsfit” computes the rms fit of two coordinate sets

\sphinxstylestrong{ROTANG Function}

\sphinxstylestrong{ROTCHECK Function}

“rotcheck” tests a specified candidate rotatable bond for
the disallowed case where inactive atoms are found on both
sides of the candidate bond

\sphinxstylestrong{ROTEULER Subroutine}

“roteuler” computes a set of Euler angle values consistent
with an input rotation matrix

\sphinxstylestrong{ROTFRAME Subroutine}

“rotframe” takes the global multipole moments and rotates them
into the local coordinate frame defined at each atomic site

\sphinxstylestrong{ROTLIST Subroutine}

“rotlist” generates the minimum list of all the atoms lying
to one side of a pair of directly bonded atoms; optionally
finds the minimal list by choosing the side with fewer atoms

\sphinxstylestrong{ROTMAT Subroutine}

“rotmat” finds the rotation matrix that rotates the local
coordinate system into the global frame at a multipole site

\sphinxstylestrong{ROTPOLE Subroutine}

“rotpole” constructs the set of atomic multipoles in the global
frame by applying the correct rotation matrix for each site

\sphinxstylestrong{ROTRGD Subroutine}

“rotrgd” finds the rotation matrix for a rigid body due
to a single step of dynamics

\sphinxstylestrong{ROTSITE Subroutine}

“rotsite” rotates the local frame atomic multipoles at a
specified site into the global coordinate frame by applying
a rotation matrix

\sphinxstylestrong{SADDLE Program}

“saddle” finds a transition state between two conformational
minima using a combination of ideas from the synchronous transit
(Halgren\sphinxhyphen{}Lipscomb) and quadratic path (Bell\sphinxhyphen{}Crighton) methods

\sphinxstylestrong{SADDLE1 Function}

“saddle1” is a service routine that computes the energy and
gradient for transition state optimization

\sphinxstylestrong{SADDLES Subroutine}

“saddles” constructs circles, convex edges and saddle faces

\sphinxstylestrong{SAVEYZE Subroutine}

“saveyze” prints the atomic forces and/or the induced dipoles
to separate external disk files

\sphinxstylestrong{SBGUESS Subroutine}

“sbguess” sets approximate stretch\sphinxhyphen{}bend force constants based
on atom type and connected atoms

\sphinxstylestrong{SCAN Program}

“scan” attempts to find all the local minima on a potential
energy surface via an iterative series of local searches along
normal mode directions

\sphinxstylestrong{SCAN1 Function}

“scan1” is a service routine that computes the energy and
gradient during exploration of a potential energy surface
via iterative local search

\sphinxstylestrong{SCAN2 Subroutine}

“scan2” is a service routine that computes the sparse matrix
Hessian elements during exploration of a potential energy
surface via iterative local search

\sphinxstylestrong{SCANPDB Subroutine}

“scanpdb” reads the first model in a Protein Data Bank file and
sets chains, alternate sites and insertion records to be used

\sphinxstylestrong{SDAREA Subroutine}

“sdarea” optionally scales the atomic friction coefficient
of each atom based on its accessible surface area

\sphinxstylestrong{SDSTEP Subroutine}

“sdstep” performs a single stochastic dynamics time step
via the velocity Verlet integration algorithm

\sphinxstylestrong{SDTERM Subroutine}

“sdterm” finds the frictional and random terms needed to
update positions and velocities during stochastic dynamics

\sphinxstylestrong{SEARCH Subroutine}

“search” is a unidimensional line search based upon parabolic
extrapolation and cubic interpolation using both function and
gradient values

\sphinxstylestrong{SETACCELERATION Subroutine}

\sphinxstylestrong{SETATOMIC Subroutine}

\sphinxstylestrong{SETATOMTYPES Subroutine}

\sphinxstylestrong{SETCHARGE Subroutine}

\sphinxstylestrong{SETCHUNK Subroutine}

“setchunk” marks a chunk in the PME spatial table which is
overlapped by the B\sphinxhyphen{}splines for a site

\sphinxstylestrong{SETCONNECTIVITY Subroutine}

\sphinxstylestrong{SETCOORDINATES Subroutine}

\sphinxstylestrong{SETELECT Subroutine}

“setelect” assigns partial charge, bond dipole and atomic
multipole parameters for the current structure, as needed
for computation of the electrostatic potential

\sphinxstylestrong{SETENERGY Subroutine}

\sphinxstylestrong{SETFILE Subroutine}

\sphinxstylestrong{SETFORCEFIELD Subroutine}

\sphinxstylestrong{SETFRAME Subroutine}

“setframe” assigns a local coordinate frame at each atomic
multipole site using high priority connected atoms along axes

\sphinxstylestrong{SETGRADIENTS Subroutine}

\sphinxstylestrong{SETINDUCED Subroutine}

\sphinxstylestrong{SETKEYWORD Subroutine}

\sphinxstylestrong{SETMASS Subroutine}

\sphinxstylestrong{SETMDTIME Subroutine}

\sphinxstylestrong{SETMOL2 Program}

“setmol2” assigns MOL2 atom names/types/charges and bond types
based upon atomic numbers and connectivity

\sphinxstylestrong{SETNAME Subroutine}

\sphinxstylestrong{SETPAIR Program}

“setpair” is a service routine that assigns flags, sets cutoffs
and allocates arrays used by different pairwise neighbor methods

\sphinxstylestrong{SETPOLAR Subroutine}

“setpolar” assigns atomic polarizabilities, Thole damping or
charge penetration parameters, and polarization groups with
user modification of these values

\sphinxstylestrong{SETSTEP Subroutine}

\sphinxstylestrong{SETSTORY Subroutine}

\sphinxstylestrong{SETTIME Subroutine}

“settime” initializes the wall clock and elapsed CPU times

\sphinxstylestrong{SETUPDATED Subroutine}

\sphinxstylestrong{SETVELOCITY Subroutine}

\sphinxstylestrong{SHAKE Subroutine}

“shake” implements the SHAKE algorithm by correcting atomic
positions to maintain interatomic distance and absolute spatial
constraints

\sphinxstylestrong{SHAKE2 Subroutine}

“shake2” modifies the gradient to remove components along any
holonomic distance contraints using a variant of SHAKE

\sphinxstylestrong{SHAKEUP Subroutine}

“shakeup” initializes any holonomic constraints for use with
the SHAKE and RATTLE algorithms

\sphinxstylestrong{SHROTMAT Subroutine}

“shrotmat” finds the rotation matrix that converts spherical
harmonic quadrupoles from the local to the global frame given
the required dipole rotation matrix

\sphinxstylestrong{SHROTSITE Subroutine}

“shrotsite” converts spherical harmonic multipoles from the
local to the global frame given required rotation matrices

\sphinxstylestrong{SIGMOID Function}

“sigmoid” implements a normalized sigmoidal function on the
interval {[}0,1{]}; the curves connect (0,0) to (1,1) and have
a cooperativity controlled by beta, they approach a straight
line as beta \sphinxhyphen{}\textgreater{} 0 and get more nonlinear as beta increases

\sphinxstylestrong{SIMPLEX Subroutine}

“simplex” is a general multidimensional Nelder\sphinxhyphen{}Mead simplex
optimization routine requiring only repeated evaluations of
the objective function

\sphinxstylestrong{SIMPLEX1 Function}

“simplex1” is a service routine used only by the Nelder\sphinxhyphen{}Mead
simplex optimization method

\sphinxstylestrong{SKTDYN Subroutine}

“sktdyn” sends the current dynamics info via a socket

\sphinxstylestrong{SKTINIT Subroutine}

“sktinit” sets up socket communication with the graphical
user interface by starting a Java virtual machine, initiating
a server, and loading an object with system information

\sphinxstylestrong{SKTKILL Subroutine}

“sktkill” closes the server and Java virtual machine

\sphinxstylestrong{SKTOPT Subroutine}

“sktopt” sends the current optimization info via a socket

\sphinxstylestrong{SLATER Subroutine}

“slater” is a general routine for computing the overlap
integrals between two Slater\sphinxhyphen{}type orbitals

\sphinxstylestrong{SNIFFER Program}

“sniffer” performs a global energy minimization using a
discrete version of Griewank’s global search trajectory

\sphinxstylestrong{SNIFFER1 Function}

“sniffer1” is a service routine that computes the energy
and gradient for the Sniffer global optimization method

\sphinxstylestrong{SOAK Subroutine}

“soak” takes a currently defined solute system and places
it into a solvent box, with removal of any solvent molecules
that overlap the solute

\sphinxstylestrong{SORT Subroutine}

“sort” takes an input list of integers and sorts it
into ascending order using the Heapsort algorithm

\sphinxstylestrong{SORT10 Subroutine}

“sort10” takes an input list of character strings and sorts
it into alphabetical order using the Heapsort algorithm,
duplicate values are removed from the final sorted list

\sphinxstylestrong{SORT2 Subroutine}

“sort2” takes an input list of reals and sorts it
into ascending order using the Heapsort algorithm;
it also returns a key into the original ordering

\sphinxstylestrong{SORT3 Subroutine}

“sort3” takes an input list of integers and sorts it
into ascending order using the Heapsort algorithm;
it also returns a key into the original ordering

\sphinxstylestrong{SORT4 Subroutine}

“sort4” takes an input list of integers and sorts it into
ascending absolute value using the Heapsort algorithm

\sphinxstylestrong{SORT5 Subroutine}

“sort5” takes an input list of integers and sorts it
into ascending order based on each value modulo “m”

\sphinxstylestrong{SORT6 Subroutine}

“sort6” takes an input list of character strings and sorts
it into alphabetical order using the Heapsort algorithm

\sphinxstylestrong{SORT7 Subroutine}

“sort7” takes an input list of character strings and sorts it
into alphabetical order using the Heapsort algorithm; it also
returns a key into the original ordering

\sphinxstylestrong{SORT8 Subroutine}

“sort8” takes an input list of integers and sorts it into
ascending order using the Heapsort algorithm, duplicate
values are removed from the final sorted list

\sphinxstylestrong{SORT9 Subroutine}

“sort9” takes an input list of reals and sorts it into
ascending order using the Heapsort algorithm, duplicate
values are removed from the final sorted list

\sphinxstylestrong{SPACEFILL Program}

“spacefill” computes the surface area and volume of
a structure; the van der Waals, accessible\sphinxhyphen{}excluded,
and contact\sphinxhyphen{}reentrant definitions are available

\sphinxstylestrong{SPECTRUM Program}

“spectrum” computes a power spectrum over a wavelength range
from the velocity autocorrelation as a function of time

\sphinxstylestrong{SPHERE Subroutine}

“sphere” finds a specified number of uniformly distributed
points on a sphere of unit radius centered at the origin

\sphinxstylestrong{SQUARE Subroutine}

“square” is a nonlinear least squares routine derived from the
IMSL BCLSF routine and the MINPACK LMDER routine; the Jacobian
is estimated by finite differences and bounds can be specified
for the variables to be refined

\sphinxstylestrong{SUFFIX Subroutine}

“suffix” checks a filename for the presence of an extension,
and appends an extension and version if none is found

\sphinxstylestrong{SUPERPOSE Program}

“superpose” takes pairs of structures and superimposes them
in the optimal least squares sense; it will attempt to match
all atom pairs or only those specified by the user

\sphinxstylestrong{SURFACE Subroutine}

“surface” performs an analytical computation of the weighted
solvent accessible surface area of each atom and the first
derivatives of the area with respect to Cartesian coordinates

\sphinxstylestrong{SURFACE1 Subroutine}

“surface1” performs an analytical computation of the weighted
solvent accessible surface area of each atom and the first
derivatives of the area with respect to Cartesian coordinates

\sphinxstylestrong{SURFATOM Subroutine}

“surfatom” performs an analytical computation of the surface
area of a specified atom; a simplified version of “surface”

\sphinxstylestrong{SURFATOM1 Subroutine}

“surfatom1” performs an analytical computation of the surface
area and first derivatives with respect to Cartesian coordinates
of a specified atom

\sphinxstylestrong{SWITCH Subroutine}

“switch” sets the coeffcients used by the fifth and seventh
order polynomial switching functions for spherical cutoffs

\sphinxstylestrong{SYMMETRY Subroutine}

“symmetry” applies symmetry operators to the fractional
coordinates of the asymmetric unit in order to generate
the symmetry related atoms of the full unit cell

\sphinxstylestrong{SYSTYZE Subroutine}

“systyze” is an auxiliary routine for the analyze program
that prints general information about the molecular system
and the force field model

\sphinxstylestrong{TABLE\_FILL Subroutine}

“table\_fill” constructs an array which stores the spatial
regions of the particle mesh Ewald grid with contributions
from each site

\sphinxstylestrong{TANGENT Subroutine}

“tangent” finds the projected gradient on the synchronous
transit path for a point along the transit pathway

\sphinxstylestrong{TCGSWAP Subroutine}

“tcgswap” switches two sets of induced dipole quantities for
use with the TCG induced dipole solver

\sphinxstylestrong{TCG\_ALPHA12 Subroutine}

“tcg\_alpha12” computes source1 = alpha*source1 and
source2 = alpha*source2

\sphinxstylestrong{TCG\_ALPHA22 Subroutine}

“tcg\_alpha22” computes result1 = alpha*source1 and
result2 = alpha*source2

\sphinxstylestrong{TCG\_ALPHAQUAD Subroutine}

“tcg\_alphaquad” computes the quadratic form, \textless{}a*alpha*b\textgreater{},
where alpha is the diagonal atomic polarizability matrix

\sphinxstylestrong{TCG\_DOTPROD Subroutine}

“tcg\_dotprod” computes the dot product of two vectors
of length n elements

\sphinxstylestrong{TCG\_RESOURCE Subroutine}

“tcg\_resource” sets the number of mutual induced dipole
pairs based on the passed argument

\sphinxstylestrong{TCG\_T0 Subroutine}

“tcg\_t0” applies T matrix to ind/p, and returns v3d/p
T = 1/alpha + Tu

\sphinxstylestrong{TCG\_UFIELD Subroutine}

“tcg\_ufield” applies \sphinxhyphen{}Tu to ind/p and returns v3d/p

\sphinxstylestrong{TCG\_UPDATE Subroutine}

“tcg\_update” computes pvec = alpha*rvec + beta*pvec;
if the preconditioner is not used, then alpha = identity

\sphinxstylestrong{TEMPER Subroutine}

“temper” computes the instantaneous temperature and applies a
thermostat via Berendsen or Bussi\sphinxhyphen{}Parrinello velocity scaling,
Andersen stochastic collisions or Nose\sphinxhyphen{}Hoover chains; also uses
Berendsen scaling for any iEL induced dipole variables

\sphinxstylestrong{TEMPER2 Subroutine}

“temper2” applies a velocity correction at the half time step
as needed for the Nose\sphinxhyphen{}Hoover thermostat

\sphinxstylestrong{TESTGRAD Program}

“testgrad” computes and compares the analytical and numerical
gradient vectors of the potential energy function with respect
to Cartesian coordinates

\sphinxstylestrong{TESTHESS Program}

“testhess” computes and compares the analytical and numerical
Hessian matrices of the potential energy function with respect
to Cartesian coordinates

\sphinxstylestrong{TESTPAIR Program}

“testpair” performs a set of timing tests to compare the
evaluation of potential energy and energy/gradient using
different methods for finding pairwise neighbors

\sphinxstylestrong{TESTPOL Program}

“testpol” compares the induced dipoles from direct polarization,
mutual SCF iterations, perturbation theory extrapolation (OPT),
and truncated conjugate gradient (TCG) solvers

\sphinxstylestrong{TESTROT Program}

“testrot” computes and compares the analytical and numerical
gradient vectors of the potential energy function with respect
to rotatable torsional angles

\sphinxstylestrong{TESTVIR Program}

“testvir” computes the analytical internal virial and compares
it to a numerical virial derived from the finite difference
derivative of the energy with respect to lattice vectors

\sphinxstylestrong{TIMER Program}

“timer” measures the CPU time required for file reading and
parameter assignment, potential energy computation, energy
and gradient computation, and Hessian matrix evaluation

\sphinxstylestrong{TIMEROT Program}

“timerot” measures the CPU time required for file reading
and parameter assignment, potential energy computation,
energy and gradient over torsions, and torsional angle
Hessian matrix evaluation

\sphinxstylestrong{TNCG Subroutine}

“tncg” implements a truncated Newton optimization algorithm
in which a preconditioned linear conjugate gradient method is
used to approximately solve Newton’s equations; special features
include use of an explicit sparse Hessian or finite\sphinxhyphen{}difference
gradient\sphinxhyphen{}Hessian products within the PCG iteration; the exact
Newton search directions can be used optionally; by default the
algorithm checks for negative curvature to prevent convergence
to a stationary point having negative eigenvalues; if a saddle
point is desired this test can be removed by disabling “negtest”

\sphinxstylestrong{TNSOLVE Subroutine}

“tnsolve” uses a linear conjugate gradient method to find
an approximate solution to the set of linear equations
represented in matrix form by Hp = \sphinxhyphen{}g (Newton’s equations)

\sphinxstylestrong{TORFIT1 Function}

“torfit1” is a service routine that computes the energy and
gradient for a low storage BFGS optimization in Cartesian
coordinate space

\sphinxstylestrong{TORGUESS Subroutine}

“torguess” set approximate torsion amplitude parameters based
on atom type and connected atoms

\sphinxstylestrong{TORPHASE Subroutine}

“torphase” sets the n\sphinxhyphen{}fold amplitude and phase values
for each torsion via sorting of the input parameters

\sphinxstylestrong{TORQUE Subroutine}

“torque” takes the torque values on a single site defined by
a local coordinate frame and converts to Cartesian forces on
the original site and sites specifying the local frame, also
gives the x,y,z\sphinxhyphen{}force components needed for virial computation

\sphinxstylestrong{TORSER Function}

“torser” computes the torsional error function and its first
derivatives with respect to the atomic Cartesian coordinates
based on the deviation of specified torsional angles from
desired values, the contained bond angles are also restrained
to avoid a numerical instability

\sphinxstylestrong{TORSFIT Program}

“torsfit” refines torsional force field parameters based on
a quantum mechanical potential surface and analytical gradient

\sphinxstylestrong{TORSIONS Subroutine}

“torsions” finds the total number of torsional angles and
the numbers of the four atoms defining each torsional angle

\sphinxstylestrong{TORUS Subroutine}

“torus” sets a list of all of the temporary torus positions
by testing for a torus between each atom and its neighbors

\sphinxstylestrong{TOTERR Function}

“toterr” is the error function and derivatives for a distance
geometry embedding; it includes components from the distance
bounds, hard sphere contacts, local geometry, chirality and
torsional restraint errors

\sphinxstylestrong{TRANSFORM Subroutine}

“transform” diagonalizes the current basis vectors to produce
trial roots for sliding block iterative matrix diagonalization

\sphinxstylestrong{TRANSIT Function}

“transit” evaluates the synchronous transit function and
gradient; linear and quadratic transit paths are available

\sphinxstylestrong{TRBASIS Subroutine}

“trbasis” forms translation and rotation basis vectors used
during vibrational analysis via block iterative diagonalization

\sphinxstylestrong{TRIANGLE Subroutine}

“triangle” smooths the upper and lower distance bounds via
the triangle inequality using a full\sphinxhyphen{}matrix variant of the
Floyd\sphinxhyphen{}Warshall shortest path algorithm; this routine is
usually much slower than the sparse matrix shortest path
methods in “geodesic” and “trifix”, and should be used only
for comparison with answers generated by those routines

\sphinxstylestrong{TRIFIX Subroutine}

“trifix” rebuilds both the upper and lower distance bound
matrices following tightening of one or both of the bounds
between a specified pair of atoms, “p” and “q”, using a
modification of Murchland’s shortest path update algorithm

\sphinxstylestrong{TRIGGER Subroutine}

“trigger” constructs a set of initial trial vectors for
use during sliding block iterative matrix diagonalization

\sphinxstylestrong{TRIMHEAD Subroutine}

“trimhead” removes blank spaces before the first non\sphinxhyphen{}blank
character in a text string by shifting the string to the left

\sphinxstylestrong{TRIMTEXT Function}

“trimtext” finds and returns the location of the last
non\sphinxhyphen{}blank character before the first null character in
an input text string; the function returns zero if no
such character is found

\sphinxstylestrong{TRIPLE Function}

“triple” finds the triple product of three vectors; used as
a service routine by the Connolly surface area and volume
computation

\sphinxstylestrong{TRUST Subroutine}

“trust” updates the model trust region for a nonlinear least
squares calculation based on ideas found in NL2SOL and Dennis
and Schnabel’s book

\sphinxstylestrong{UBUILD Subroutine}

“ubuild” performs a complete rebuild of the polarization
preconditioner neighbor list for all sites

\sphinxstylestrong{UDIRECT1 Subroutine}

“udirect1” computes the reciprocal space contribution of the
permanent atomic multipole moments to the field

\sphinxstylestrong{UDIRECT2A Subroutine}

“udirect2a” computes the real space contribution of the permanent
atomic multipole moments to the field via a double loop

\sphinxstylestrong{UDIRECT2B Subroutine}

“udirect2b” computes the real space contribution of the permanent
atomic multipole moments to the field via a neighbor list

\sphinxstylestrong{UFIELD0A Subroutine}

“ufield0a” computes the mutual electrostatic field due to
induced dipole moments via a double loop

\sphinxstylestrong{UFIELD0B Subroutine}

“ufield0b” computes the mutual electrostatic field due to
induced dipole moments via a pair list

\sphinxstylestrong{UFIELD0C Subroutine}

“ufield0c” computes the mutual electrostatic field due to
induced dipole moments via Ewald summation

\sphinxstylestrong{UFIELD0D Subroutine}

“ufield0d” computes the mutual electrostatic field due to
induced dipole moments for use with with generalized Kirkwood
implicit solvation

\sphinxstylestrong{UFIELD0E Subroutine}

“ufield0e” computes the mutual electrostatic field due to
induced dipole moments via a Poisson\sphinxhyphen{}Boltzmann solver

\sphinxstylestrong{UFIELDI Subroutine}

“ufieldi” computes the electrostatic field due to intergroup
induced dipole moments

\sphinxstylestrong{ULIGHT Subroutine}

“ulight” performs a complete rebuild of the polarization
preconditioner pair neighbor list for all sites using the
method of lights

\sphinxstylestrong{ULIST Subroutine}

“ulist” performs an update or a complete rebuild of the
neighbor lists for the polarization preconditioner

\sphinxstylestrong{ULSPRED Subroutine}

“ulspred” uses standard extrapolation or a least squares fit
to set coefficients of an induced dipole predictor polynomial

\sphinxstylestrong{UMUTUAL1 Subroutine}

“umutual1” computes the reciprocal space contribution of the
induced atomic dipole moments to the field

\sphinxstylestrong{UMUTUAL2A Subroutine}

“umutual2a” computes the real space contribution of the induced
atomic dipole moments to the field via a double loop

\sphinxstylestrong{UMUTUAL2B Subroutine}

“umutual2b” computes the real space contribution of the induced
atomic dipole moments to the field via a neighbor list

\sphinxstylestrong{UNITCELL Subroutine}

“unitcell” gets the periodic boundary box size and related
values from an external keyword file

\sphinxstylestrong{UPCASE Subroutine}

“upcase” converts a text string to all upper case letters

\sphinxstylestrong{URYGUESS Function}

“uryguess” sets approximate Urey\sphinxhyphen{}Bradley force constants
based on atom type and connected atoms

\sphinxstylestrong{USCALE0A Subroutine}

“uscale0a” builds and applies a preconditioner for the conjugate
gradient induced dipole solver using a double loop

\sphinxstylestrong{USCALE0B Subroutine}

“uscale0b” builds and applies a preconditioner for the conjugate
gradient induced dipole solver using a neighbor pair list

\sphinxstylestrong{VALENCE Program}

“valence” refines force field parameters for valence terms based
on a quantum mechanical optimized structure and frequencies

\sphinxstylestrong{VALFIT1 Function}

“valfit1” is a service routine that computes the RMS error
and gradient for valence parameters fit to QM results

\sphinxstylestrong{VALGUESS Subroutine}

“valguess” sets approximate valence parameter values based on
quantum mechanical structure and frequency data

\sphinxstylestrong{VALMIN1 Function}

“valmin1” is a service routine that computes the molecular
energy and gradient during valence parameter optimization

\sphinxstylestrong{VALRMS Function}

“valrms” evaluates a valence parameter goodness\sphinxhyphen{}of\sphinxhyphen{}fit error
function based on comparison of forces, frequencies, bond
lengths and angles to QM results

\sphinxstylestrong{VAM Subroutine}

“vam” takes the analytical molecular surface defined
as a collection of spherical and toroidal polygons
and uses it to compute the volume and surface area

\sphinxstylestrong{VARPRM Subroutine}

“varprm” copies the current optimization values into the
corresponding electrostatic potential energy parameters

\sphinxstylestrong{VARPRM Subroutine}

“varprm” copies the current optimization values into the
corresponding valence potential energy parameters

\sphinxstylestrong{VBUILD Subroutine}

“vbuild” performs a complete rebuild of the van der Waals
pair neighbor list for all sites

\sphinxstylestrong{VCROSS Subroutine}

“vcross” finds the cross product of two vectors

\sphinxstylestrong{VDWERR Function}

“vdwerr” is the hard sphere van der Waals bound error function
and derivatives that penalizes close nonbonded contacts,
pairwise neighbors are generated via the method of lights

\sphinxstylestrong{VDWGUESS Subroutine}

“vdwguess” sets initial VDW parameters based on atom type
and connected atoms

\sphinxstylestrong{VECANG Function}

“vecang” finds the angle between two vectors handed with respect
to a coordinate axis; returns an angle in the range {[}0,2*pi{]}

\sphinxstylestrong{VERLET Subroutine}

“verlet” performs a single molecular dynamics time step
via the velocity Verlet multistep recursion formula

\sphinxstylestrong{VERSION Subroutine}

“version” checks the name of a file about to be opened; if
if “old” status is passed, the name of the highest current
version is returned; if “new” status is passed the filename
of the next available unused version is generated

\sphinxstylestrong{VIBBIG Program}

“vibbig” performs large\sphinxhyphen{}scale vibrational mode analysis using
only vector storage and gradient evaluations; preconditioning
is via an approximate inverse from a block diagonal Hessian,
and a sliding block method is used to converge any number of
eigenvectors starting from either lowest or highest frequency

\sphinxstylestrong{VIBRATE Program}

“vibrate” performs a vibrational normal mode analysis; the
Hessian matrix of second derivatives is determined and then
diagonalized both directly and after mass weighting; output
consists of the eigenvalues of the force constant matrix as
well as the vibrational frequencies and displacements

\sphinxstylestrong{VIBROT Program}

“vibrot” computes the eigenvalues and eigenvectors of the
torsional Hessian matrix

\sphinxstylestrong{VIRIYZE Subroutine}

“propyze” finds and prints the internal virial, the dE/dV value
and an estimate of the pressure

\sphinxstylestrong{VLIGHT Subroutine}

“vlight” performs a complete rebuild of the van der Waals
pair neighbor list for all sites using the method of lights

\sphinxstylestrong{VLIST Subroutine}

“vlist” performs an update or a complete rebuild of the
nonbonded neighbor lists for vdw sites

\sphinxstylestrong{VNORM Subroutine}

“vnorm” normalizes a vector to unit length; used as a
service routine by the Connolly surface area and volume
computation

\sphinxstylestrong{VOLUME Subroutine}

“volume” calculates the excluded volume via the Connolly
analytical volume and surface area algorithm

\sphinxstylestrong{VOLUME1 Subroutine}

“volume1” calculates first derivatives of the total excluded
volume with respect to the Cartesian coordinates of each atom

\sphinxstylestrong{VOLUME2 Subroutine}

“volume2” calculates second derivatives of the total excluded
volume with respect to the Cartesian coordinates of the atoms

\sphinxstylestrong{WATSON Subroutine}

“watson” uses a rigid body optimization to approximately
align the paired strands of a nucleic acid double helix

\sphinxstylestrong{WATSON1 Function}

“watson1” is a service routine that computes the energy
and gradient for optimally conditioned variable metric
optimization of rigid bodies

\sphinxstylestrong{WIGGLE Subroutine}

“wiggle” applies a random perturbation to the atomic coordinates
to avoid numerical instabilities for various linear, planar and
symmetric structures

\sphinxstylestrong{XTALERR Subroutine}

“xtalerr” computes an error function value derived from
lattice energies, dimer intermolecular energies and the
gradient with respect to structural parameters

\sphinxstylestrong{XTALFIT Program}

“xtalfit” determines optimized van der Waals and electrostatic
parameters by fitting to crystal structures, lattice energies,
and dimer structures and interaction energies

\sphinxstylestrong{XTALMIN Program}

“xtalmin” performs a full crystal energy minimization by
optimizing over fractional atomic coordinates and the six
lattice lengths and angles

\sphinxstylestrong{XTALMIN1 Function}

“xtalmin1” is a service routine that computes the energy and
gradient with respect to fractional coordinates and lattice
dimensions for a crystal energy minimization

\sphinxstylestrong{XTALMOVE Subroutine}

“xtalmove” converts fractional to Cartesian coordinates for
rigid molecules during optimization of force field parameters

\sphinxstylestrong{XTALPRM Subroutine}

“xtalprm” stores or retrieves a molecular structure; used to
make a previously stored structure the active structure, or to
store a structure for later use

\sphinxstylestrong{XTALWRT Subroutine}

“xtalwrt” prints intermediate results during fitting of
force field parameters to structures and energies

\sphinxstylestrong{XYZATM Subroutine}

“xyzatm” computes the Cartesian coordinates of a single
atom from its defining internal coordinate values

\sphinxstylestrong{XYZEDIT Program}

“xyzedit” provides for modification and manipulation
of the contents of Cartesian coordinates files

\sphinxstylestrong{XYZINT Program}

“xyzint” takes as input a Cartesian coordinates file, then
converts to and writes out an internal coordinates file

\sphinxstylestrong{XYZMOL2 Program}

“xyzmol2” takes as input a Cartesian coordinates file,
converts to and then writes out a Tripos MOL2 file

\sphinxstylestrong{XYZPDB Program}

“xyzpdb” takes as input a Cartesian coordinates file,
then converts to and writes out a Protein Data Bank file

\sphinxstylestrong{XYZRIGID Subroutine}

“xyzrigid” computes the center of mass and Euler angle rigid
body coordinates for each atom group in the system

\sphinxstylestrong{ZATOM Subroutine}

“zatom” adds an atom to the end of the current Z\sphinxhyphen{}matrix
and then increments the atom counter; atom type, defining
atoms and internal coordinates are passed as arguments

\sphinxstylestrong{ZHELP Subroutine}

“zhelp” prints the general information and instructions
for the Z\sphinxhyphen{}matrix editing program

\sphinxstylestrong{ZVALUE Subroutine}

“zvalue” gets user supplied values for selected coordinates
as needed by the internal coordinate editing program


\chapter{Modules \& Global Variables}
\label{\detokenize{text/modules:modules-global-variables}}\label{\detokenize{text/modules::doc}}
The Fortran modules found in the Tinker package are listed below along with a brief description of the variables associated with each module. Each individual module contains a set of globally allocated variables available to any program unit upon inclusion of that module. A source listing containing each of the Tinker functions and subroutines and its included modules can be produced by running the “listing.make” script found in the distribution.

\sphinxstylestrong{ACTION Module        total number of each energy term type}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
neb             number of bond stretch energy terms computed
nea             number of angle bend energy terms computed
neba            number of stretch\PYGZhy{}bend energy terms computed
neub            number of Urey\PYGZhy{}Bradley energy terms computed
neaa            number of angle\PYGZhy{}angle energy terms computed
neopb           number of out\PYGZhy{}of\PYGZhy{}plane bend energy terms computed
neopd           number of out\PYGZhy{}of\PYGZhy{}plane distance energy terms computed
neid            number of improper dihedral energy terms computed
neit            number of improper torsion energy terms computed
net             number of torsional energy terms computed
nept            number of pi\PYGZhy{}system torsion energy terms computed
nebt            number of stretch\PYGZhy{}torsion energy terms computed
neat            number of angle\PYGZhy{}torsion energy terms computed
nett            number of torsion\PYGZhy{}torsion energy terms computed
nev             number of van der Waals energy terms computed
ner             number of Pauli repulsion energy terms computed
nedsp           number of dispersion energy terms computed
nec             number of charge\PYGZhy{}charge energy terms computed
necd            number of charge\PYGZhy{}dipole energy terms computed
ned             number of dipole\PYGZhy{}dipole energy terms computed
nem             number of multipole energy terms computed
nep             number of polarization energy terms computed
nect            number of charge transfer energy terms computed
new             number of Ewald summation energy terms computed
nerxf           number of reaction field energy terms computed
nes             number of solvation energy terms computed
nelf            number of metal ligand field energy terms computed
neg             number of geometric restraint energy terms computed
nex             number of extra energy terms computed
\end{sphinxVerbatim}

\sphinxstylestrong{ALIGN Module        information for structure superposition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nfit            number of atoms to use in superimposing two structures
ifit            atom numbers of pairs of atoms to be superimposed
wfit            weights assigned to atom pairs during superposition
\end{sphinxVerbatim}

\sphinxstylestrong{ANALYZ Module        energy components partitioned to atoms}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
aesum           total potential energy partitioned over atoms
aeb             bond stretch energy partitioned over atoms
aea             angle bend energy partitioned over atoms
aeba            stretch\PYGZhy{}bend energy partitioned over atoms
aeub            Urey\PYGZhy{}Bradley energy partitioned over atoms
aeaa            angle\PYGZhy{}angle energy partitioned over atoms
aeopb           out\PYGZhy{}of\PYGZhy{}plane bend energy partitioned over atoms
aeopd           out\PYGZhy{}of\PYGZhy{}plane distance energy partitioned over atoms
aeid            improper dihedral energy partitioned over atoms
aeit            improper torsion energy partitioned over atoms
aet             torsional energy partitioned over atoms
aept            pi\PYGZhy{}system torsion energy partitioned over atoms
aebt            stretch\PYGZhy{}torsion energy partitioned over atoms
aeat            angle\PYGZhy{}torsion energy partitioned over atoms
aett            torsion\PYGZhy{}torsion energy partitioned over atoms
aev             van der Waals energy partitioned over atoms
aer             Pauli repulsion energy partitioned over atoms
aedsp           damped dispersion energy partitioned over atoms
aec             charge\PYGZhy{}charge energy partitioned over atoms
aecd            charge\PYGZhy{}dipole energy partitioned over atoms
aed             dipole\PYGZhy{}dipole energy partitioned over atoms
aem             multipole energy partitioned over atoms
aep             polarization energy partitioned over atoms
aect            charge transfer energy partitioned over atoms
aerxf           reaction field energy partitioned over atoms
aes             solvation energy partitioned over atoms
aelf            metal ligand field energy partitioned over atoms
aeg             geometric restraint energy partitioned over atoms
aex             extra energy term partitioned over atoms
\end{sphinxVerbatim}

\sphinxstylestrong{ANGANG Module        angle\sphinxhyphen{}angles in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nangang         total number of angle\PYGZhy{}angle interactions
iaa             angle numbers used in each angle\PYGZhy{}angle term
kaa             force constant for angle\PYGZhy{}angle cross terms
\end{sphinxVerbatim}

\sphinxstylestrong{ANGBND Module        bond angle bends in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nangle          total number of angle bends in the system
iang            numbers of the atoms in each angle bend
ak              harmonic angle force constant (kcal/mole/rad**2)
anat            ideal bond angle or phase shift angle (degrees)
afld            periodicity for Fourier angle bending term
\end{sphinxVerbatim}

\sphinxstylestrong{ANGPOT Module        angle bend functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
angunit         convert angle bending energy to kcal/mole
stbnunit        convert stretch\PYGZhy{}bend energy to kcal/mole
aaunit          convert angle\PYGZhy{}angle energy to kcal/mole
opbunit         convert out\PYGZhy{}of\PYGZhy{}plane bend energy to kcal/mole
opdunit         convert out\PYGZhy{}of\PYGZhy{}plane distance energy to kcal/mole
cang            cubic coefficient in angle bending potential
qang            quartic coefficient in angle bending potential
pang            quintic coefficient in angle bending potential
sang            sextic coefficient in angle bending potential
copb            cubic coefficient in out\PYGZhy{}of\PYGZhy{}plane bend potential
qopb            quartic coefficient in out\PYGZhy{}of\PYGZhy{}plane bend potential
popb            quintic coefficient in out\PYGZhy{}of\PYGZhy{}plane bend potential
sopb            sextic coefficient in out\PYGZhy{}of\PYGZhy{}plane bend potential
copd            cubic coefficient in out\PYGZhy{}of\PYGZhy{}plane distance potential
qopd            quartic coefficient in out\PYGZhy{}of\PYGZhy{}plane distance potential
popd            quintic coefficient in out\PYGZhy{}of\PYGZhy{}plane distance potential
sopd            sextic coefficient in out\PYGZhy{}of\PYGZhy{}plane distance potential
opbtyp          type of out\PYGZhy{}of\PYGZhy{}plane bend potential energy function
angtyp          type of angle bending function for each bond angle
\end{sphinxVerbatim}

\sphinxstylestrong{ANGTOR Module        angle\sphinxhyphen{}torsions in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nangtor         total number of angle\PYGZhy{}torsion interactions
iat             torsion and angle numbers used in angle\PYGZhy{}torsion
kant            1\PYGZhy{}, 2\PYGZhy{} and 3\PYGZhy{}fold angle\PYGZhy{}torsion force constants
\end{sphinxVerbatim}

\sphinxstylestrong{ARGUE Module        command line arguments at run time}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxarg          maximum number of command line arguments
narg            number of command line arguments to the program
listarg         flag to mark available command line arguments
arg             strings containing the command line arguments
\end{sphinxVerbatim}

\sphinxstylestrong{ASCII Module        selected ASCII character code values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
null            decimal value of ASCII code for null (0)
tab             decimal value of ASCII code for tab (9)
linefeed        decimal value of ASCII code for linefeed (10)
formfeed        decimal value of ASCII code for formfeed (12)
carriage        decimal value of ASCII code for carriage return (13)
escape          decimal value of ASCII code for escape (27)
space           decimal value of ASCII code for blank space (32)
exclamation     decimal value of ASCII code for exclamation (33)
quote           decimal value of ASCII code for double quote (34)
pound           decimal value of ASCII code for pound sign (35)
dollar          decimal value of ASCII code for dollar sign (36)
percent         decimal value of ASCII code for percent sign (37)
ampersand       decimal value of ASCII code for ampersand (38)
apostrophe      decimal value of ASCII code for single quote (39)
asterisk        decimal value of ASCII code for asterisk (42)
plus            decimal value of ASCII code for plus sign (43)
comma           decimal value of ASCII code for comma (44)
minus           decimal value of ASCII code for minus sign (45)
period          decimal value of ASCII code for period (46)
frontslash      decimal value of ASCII codd for frontslash (47)
colon           decimal value of ASCII code for colon (58)
semicolon       decimal value of ASCII code for semicolon (59)
equal           decimal value of ASCII code for equal sign (61)
question        decimal value of ASCII code for question mark (63)
atsign          decimal value of ASCII code for at sign (64)
backslash       decimal value of ASCII code for backslash (92)
caret           decimal value of ASCII code for caret (94)
underbar        decimal value of ASCII code for underbar (95)
vertical        decimal value of ASCII code for vertical bar (124)
tilde           decimal value of ASCII code for tilde (126)
nbsp            decimal value of ASCII code for nobreak space (255)
\end{sphinxVerbatim}

\sphinxstylestrong{ATMLST Module        bond and angle local geometry indices}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bndlist         numbers of the bonds involving each atom
anglist         numbers of the angles centered on each atom
balist          numbers of the bonds comprising each angle
\end{sphinxVerbatim}

\sphinxstylestrong{ATOMID Module        atomic properties for current atoms}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tag             integer atom labels from input coordinates file
class           atom class number for each atom in the system
atomic          atomic number for each atom in the system
valence         valence number for each atom in the system
mass            atomic weight for each atom in the system
name            atom name for each atom in the system
story           descriptive type for each atom in system
\end{sphinxVerbatim}

\sphinxstylestrong{ATOMS Module        number, position and type of atoms}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
n               total number of atoms in the current system
type            atom type number for each atom in the system
x               current x\PYGZhy{}coordinate for each atom in the system
y               current y\PYGZhy{}coordinate for each atom in the system
z               current z\PYGZhy{}coordinate for each atom in the system
\end{sphinxVerbatim}

\sphinxstylestrong{BATH Module        thermostat and barostat control values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnose         maximum length of Nose\PYGZhy{}Hoover thermostat chain
voltrial        mean number of steps between Monte Carlo moves
kelvin          target value for the system temperature (K)
atmsph          target value for the system pressure (atm)
tautemp         time constant for Berendsen thermostat (psec)
taupres         time constant for Berendsen barostat (psec)
compress        isothermal compressibility of medium (atm\PYGZhy{}1)
collide         collision frequency for Andersen thermostat
eta             velocity value for Bussi\PYGZhy{}Parrinello barostat
volmove         maximum volume move for Monte Carlo barostat (Ang**3)
vbar            velocity of log volume for Nose\PYGZhy{}Hoover barostat
qbar            mass of the volume for Nose\PYGZhy{}Hoover barostat
gbar            force for the volume for Nose\PYGZhy{}Hoover barostat
vnh             velocity of each chained Nose\PYGZhy{}Hoover thermostat
qnh             mass for each chained Nose\PYGZhy{}Hoover thermostat
gnh             force for each chained Nose\PYGZhy{}Hoover thermostat
isothermal      logical flag governing use of temperature control
isobaric        logical flag governing use of pressure control
anisotrop       logical flag governing use of anisotropic pressure
thermostat      choice of temperature control method to be used
barostat        choice of pressure control method to be used
volscale        choice of scaling method for Monte Carlo barostat
\end{sphinxVerbatim}

\sphinxstylestrong{BITOR Module        bitorsions in the current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nbitor          total number of bitorsions in the system
ibitor          numbers of the atoms in each bitorsion
\end{sphinxVerbatim}

\sphinxstylestrong{BNDPOT Module        bond stretch functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cbnd            cubic coefficient in bond stretch potential
qbnd            quartic coefficient in bond stretch potential
bndunit         convert bond stretch energy to kcal/mole
bndtyp          type of bond stretch potential energy function
\end{sphinxVerbatim}

\sphinxstylestrong{BNDSTR Module        bond stretches in the current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nbond           total number of bond stretches in the system
ibnd            numbers of the atoms in each bond stretch
bk              bond stretch force constants (kcal/mole/Ang**2)
bl              ideal bond length values in Angstroms
\end{sphinxVerbatim}

\sphinxstylestrong{BOUND Module        periodic boundary condition controls}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
polycut         cutoff distance for infinite polymer nonbonds
polycut2        square of infinite polymer nonbond cutoff
use\PYGZus{}bounds      flag to use periodic boundary conditions
use\PYGZus{}replica     flag to use replicates for periodic system
use\PYGZus{}polymer     flag to mark presence of infinite polymer
\end{sphinxVerbatim}

\sphinxstylestrong{BOXES Module        periodic boundary condition parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
xbox            length of a\PYGZhy{}axis of periodic box in Angstroms
ybox            length of b\PYGZhy{}axis of periodic box in Angstroms
zbox            length of c\PYGZhy{}axis of periodic box in Angstroms
alpha           angle between b\PYGZhy{} and c\PYGZhy{}axes of box in degrees
beta            angle between a\PYGZhy{} and c\PYGZhy{}axes of box in degrees
gamma           angle between a\PYGZhy{} and b\PYGZhy{}axes of box in degrees
xbox2           half of the a\PYGZhy{}axis length of periodic box
ybox2           half of the b\PYGZhy{}axis length of periodic box
zbox2           half of the c\PYGZhy{}axis length of periodic box
box34           three\PYGZhy{}fourths axis length of truncated octahedron
volbox          volume in Ang**3 of the periodic box
beta\PYGZus{}sin        sine of the beta periodic box angle
beta\PYGZus{}cos        cosine of the beta periodic box angle
gamma\PYGZus{}sin       sine of the gamma periodic box angle
gamma\PYGZus{}cos       cosine of the gamma periodic box angle
beta\PYGZus{}term       term used in generating triclinic box
gamma\PYGZus{}term      term used in generating triclinic box
lvec            real space lattice vectors as matrix rows
recip           reciprocal lattice vectors as matrix columns
orthogonal      flag to mark periodic box as orthogonal
monoclinic      flag to mark periodic box as monoclinic
triclinic       flag to mark periodic box as triclinic
octahedron      flag to mark box as truncated octahedron
spacegrp        space group symbol for the unit cell type
\end{sphinxVerbatim}

\sphinxstylestrong{CELL Module        replicated cell periodic boundaries}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ncell           total number of cell replicates for periodic boundaries
icell           offset along axes for each replicate periodic cell
xcell           length of the a\PYGZhy{}axis of the complete replicated cell
ycell           length of the b\PYGZhy{}axis of the complete replicated cell
zcell           length of the c\PYGZhy{}axis of the complete replicated cell
xcell2          half the length of the a\PYGZhy{}axis of the replicated cell
ycell2          half the length of the b\PYGZhy{}axis of the replicated cell
zcell2          half the length of the c\PYGZhy{}axis of the replicated cell
\end{sphinxVerbatim}

\sphinxstylestrong{CFLUX Module        charge flux terms in current system}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bflx            bond stretching charge flux constant (electrons/Ang)
aflx            angle bending charge flux constant (electrons/radian)
abflx           asymmetric stretch charge flux constant (electrons/Ang)
\end{sphinxVerbatim}

\sphinxstylestrong{CHARGE Module        partial charges in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nion            total number of partial charges in system
iion            number of the atom site for each partial charge
jion            neighbor generation site for each partial charge
kion            cutoff switching site for each partial charge
pchg            current atomic partial charge values (e\PYGZhy{})
pchg0           original partial charge values for charge flux
\end{sphinxVerbatim}

\sphinxstylestrong{CHGPEN Module        charge penetration in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ncp             total number of charge penetration sites in system
pcore           number of core electrons at each multipole site
pval            number of valence electrons at each multipole site
pval0           original number of valence electrons for charge flux
palpha          charge penetration damping at each multipole site
\end{sphinxVerbatim}

\sphinxstylestrong{CHGPOT Module        charge\sphinxhyphen{}charge functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
electric        energy factor in kcal/mole for current force field
dielec          dielectric constant for electrostatic interactions
ebuffer         electrostatic buffering constant added to distance
c1scale         factor by which 1\PYGZhy{}1 charge interactions are scaled
c2scale         factor by which 1\PYGZhy{}2 charge interactions are scaled
c3scale         factor by which 1\PYGZhy{}3 charge interactions are scaled
c4scale         factor by which 1\PYGZhy{}4 charge interactions are scaled
c5scale         factor by which 1\PYGZhy{}5 charge interactions are scaled
neutnbr         logical flag governing use of neutral group neighbors
neutcut         logical flag governing use of neutral group cutoffs
\end{sphinxVerbatim}

\sphinxstylestrong{CHGTRN Module        charge transfer for current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nct             total number of dispersion sites in the system
chgct           charge for charge transfer at each multipole site
dmpct           charge transfer damping factor at each multipole site
\end{sphinxVerbatim}

\sphinxstylestrong{CHRONO Module        clock time values for current program}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
twall           current processor wall clock time in seconds
tcpu            elapsed cpu time from start of program in seconds
\end{sphinxVerbatim}

\sphinxstylestrong{CHUNKS Module        PME grid spatial decomposition values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nchunk          total number of spatial regions for PME grid
nchk1           number of spatial regions along the a\PYGZhy{}axis
nchk2           number of spatial regions along the b\PYGZhy{}axis
nchk3           number of spatial regions along the c\PYGZhy{}axis
ngrd1           number of grid points per region along a\PYGZhy{}axis
ngrd2           number of grid points per region along b\PYGZhy{}axis
ngrd3           number of grid points per region along c\PYGZhy{}axis
nlpts           PME grid points to the left of center point
nrpts           PME grid points to the right of center point
grdoff          offset for index into B\PYGZhy{}spline coefficients
pmetable        PME grid spatial regions involved for each site
\end{sphinxVerbatim}

\sphinxstylestrong{COUPLE Module        atom neighbor connectivity lists}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
n12             number of atoms directly bonded to each atom
n13             number of atoms in a 1\PYGZhy{}3 relation to each atom
n14             number of atoms in a 1\PYGZhy{}4 relation to each atom
n15             number of atoms in a 1\PYGZhy{}5 relation to each atom
i12             atom numbers of atoms 1\PYGZhy{}2 connected to each atom
i13             atom numbers of atoms 1\PYGZhy{}3 connected to each atom
i14             atom numbers of atoms 1\PYGZhy{}4 connected to each atom
i15             atom numbers of atoms 1\PYGZhy{}5 connected to each atom
\end{sphinxVerbatim}

\sphinxstylestrong{CTRPOT Module        charge transfer functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ctrntyp         type of charge transfer term (SEPARATE or COMBINED)
\end{sphinxVerbatim}

\sphinxstylestrong{DERIV Module        Cartesian coord derivative components}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
desum           total energy Cartesian coordinate derivatives
deb             bond stretch Cartesian coordinate derivatives
dea             angle bend Cartesian coordinate derivatives
deba            stretch\PYGZhy{}bend Cartesian coordinate derivatives
deub            Urey\PYGZhy{}Bradley Cartesian coordinate derivatives
deaa            angle\PYGZhy{}angle Cartesian coordinate derivatives
deopb           out\PYGZhy{}of\PYGZhy{}plane bend Cartesian coordinate derivatives
deopd           out\PYGZhy{}of\PYGZhy{}plane distance Cartesian coordinate derivatives
deid            improper dihedral Cartesian coordinate derivatives
deit            improper torsion Cartesian coordinate derivatives
det             torsional Cartesian coordinate derivatives
dept            pi\PYGZhy{}system torsion Cartesian coordinate derivatives
debt            stretch\PYGZhy{}torsion Cartesian coordinate derivatives
deat            angle\PYGZhy{}torsion Cartesian coordinate derivatives
dett            torsion\PYGZhy{}torsion Cartesian coordinate derivatives
dev             van der Waals Cartesian coordinate derivatives
der             Pauli repulsion Cartesian coordinate derivatives
dedsp           damped dispersion Cartesian coordinate derivatives
dec             charge\PYGZhy{}charge Cartesian coordinate derivatives
decd            charge\PYGZhy{}dipole Cartesian coordinate derivatives
ded             dipole\PYGZhy{}dipole Cartesian coordinate derivatives
dem             multipole Cartesian coordinate derivatives
dep             polarization Cartesian coordinate derivatives
dect            charge transfer Cartesian coordinate derivatives
derxf           reaction field Cartesian coordinate derivatives
des             solvation Cartesian coordinate derivatives
delf            metal ligand field Cartesian coordinate derivatives
deg             geometric restraint Cartesian coordinate derivatives
dex             extra energy term Cartesian coordinate derivatives
\end{sphinxVerbatim}

\sphinxstylestrong{DIPOLE Module        bond dipoles in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ndipole         total number of dipoles in the system
idpl            numbers of atoms that define each dipole
bdpl            magnitude of each of the dipoles (Debye)
sdpl            position of each dipole between defining atoms
\end{sphinxVerbatim}

\sphinxstylestrong{DISGEO Module        distance geometry bounds \& parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
vdwmax          maximum value of hard sphere sum for an atom pair
compact         index of local distance compaction on embedding
pathmax         maximum value of upper bound after smoothing
dbnd            distance geometry upper and lower bounds matrix
georad          hard sphere radii for distance geometry atoms
use\PYGZus{}invert      flag to use enantiomer closest to input structure
use\PYGZus{}anneal      flag to use simulated annealing refinement
\end{sphinxVerbatim}

\sphinxstylestrong{DISP Module        damped dispersion for current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ndisp           total number of dispersion sites in the system
idisp           number of the atom for each dispersion site
csixpr          pairwise sum of C6 dispersion coefficients
csix            C6 dispersion coefficient value at each site
adisp           alpha dispersion damping value at each site
\end{sphinxVerbatim}

\sphinxstylestrong{DMA Module        QM spherical harmonic multipole moments}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mp              atomic monopole charge values from DMA
dpx             atomic dipole moment x\PYGZhy{}component from DMA
dpy             atomic dipole moment y\PYGZhy{}component from DMA
dpz             atomic dipole moment z\PYGZhy{}component from DMA
q20             atomic Q20 quadrupole component from DMA (zz)
q21c            atomic Q21c quadrupole component from DMA (xz)
q21s            atomic Q21s quadrupole component from DMA (yz)
q22c            atomic Q22c quadrupole component from DMA (xx\PYGZhy{}yy)
q22s            atomic Q22s quadrupole component from DMA (xy)
\end{sphinxVerbatim}

\sphinxstylestrong{DOMEGA Module        derivative components over torsions}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tesum           total energy derivatives over torsions
teb             bond stretch derivatives over torsions
tea             angle bend derivatives over torsions
teba            stretch\PYGZhy{}bend derivatives over torsions
teub            Urey\PYGZhy{}Bradley derivatives over torsions
teaa            angle\PYGZhy{}angle derivatives over torsions
teopb           out\PYGZhy{}of\PYGZhy{}plane bend derivatives over torsions
teopd           out\PYGZhy{}of\PYGZhy{}plane distance derivatives over torsions
teid            improper dihedral derivatives over torsions
teit            improper torsion derivatives over torsions
tet             torsional derivatives over torsions
tept            pi\PYGZhy{}system torsion derivatives over torsions
tebt            stretch\PYGZhy{}torsion derivatives over torsions
teat            angle\PYGZhy{}torsion derivatives over torsions
tett            torsion\PYGZhy{}torsion derivatives over torsions
tev             van der Waals derivatives over torsions
ter             Pauli repulsion derivatives over torsions
tedsp           dampled dispersion derivatives over torsions
tec             charge\PYGZhy{}charge derivatives over torsions
tecd            charge\PYGZhy{}dipole derivatives over torsions
ted             dipole\PYGZhy{}dipole derivatives over torsions
tem             atomic multipole derivatives over torsions
tep             polarization derivatives over torsions
tect            charge transfer derivatives over torsions
terxf           reaction field derivatives over torsions
tes             solvation derivatives over torsions
telf            metal ligand field derivatives over torsions
teg             geometric restraint derivatives over torsions
tex             extra energy term derivatives over torsions
\end{sphinxVerbatim}

\sphinxstylestrong{DSPPOT Module        dispersion interaction scale factors}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dsp2scale       scale factor for 1\PYGZhy{}2 dispersion energy interactions
dsp3scale       scale factor for 1\PYGZhy{}3 dispersion energy interactions
dsp4scale       scale factor for 1\PYGZhy{}4 dispersion energy interactions
dsp5scale       scale factor for 1\PYGZhy{}5 dispersion energy interactions
use\PYGZus{}dcorr       flag to use long range dispersion correction
\end{sphinxVerbatim}

\sphinxstylestrong{ENERGI Module        individual potential energy components}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
esum            total potential energy of the system
eb              bond stretch potential energy of the system
ea              angle bend potential energy of the system
eba             stretch\PYGZhy{}bend potential energy of the system
eub             Urey\PYGZhy{}Bradley potential energy of the system
eaa             angle\PYGZhy{}angle potential energy of the system
eopb            out\PYGZhy{}of\PYGZhy{}plane bend potential energy of the system
eopd            out\PYGZhy{}of\PYGZhy{}plane distance potential energy of the system
eid             improper dihedral potential energy of the system
eit             improper torsion potential energy of the system
et              torsional potential energy of the system
ept             pi\PYGZhy{}system torsion potential energy of the system
ebt             stretch\PYGZhy{}torsion potential energy of the system
eat             angle\PYGZhy{}torsion potential energy of the system
ett             torsion\PYGZhy{}torsion potential energy of the system
ev              van der Waals potential energy of the system
er              Pauli repulsion potential energy of the system
edsp            dampled dispersion potential energy of the system
ec              charge\PYGZhy{}charge potential energy of the system
ecd             charge\PYGZhy{}dipole potential energy of the system
ed              dipole\PYGZhy{}dipole potential energy of the system
em              atomic multipole potential energy of the system
ep              polarization potential energy of the system
ect             charge transfer potential energy of the system
erxf            reaction field potential energy of the system
es              solvation potential energy of the system
elf             metal ligand field potential energy of the system
eg              geometric restraint potential energy of the system
ex              extra term potential energy of the system
\end{sphinxVerbatim}

\sphinxstylestrong{EWALD Module        Ewald summation parameters and options}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
aewald          current value of Ewald convergence coefficient
aeewald         Ewald convergence coefficient for electrostatics
apewald         Ewald convergence coefficient for polarization
adewald         Ewald convergence coefficient for dispersion
boundary        Ewald boundary condition; none, tinfoil or vacuum
\end{sphinxVerbatim}

\sphinxstylestrong{FACES Module        Connolly area and volume variables}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxcls          maximum number of neighboring atom pairs
maxtt           maximum number of temporary tori
maxt            maximum number of total tori
maxp            maximum number of probe positions
maxv            maximum number of vertices
maxen           maximum number of concave edges
maxfn           maximum number of concave faces
maxc            maximum number of circles
maxeq           maximum number of convex edges
maxfs           maximum number of saddle faces
maxfq           maximum number of convex faces
maxcy           maximum number of cycles
mxcyeq          maximum number of convex edge cycles
mxfqcy          maximum number of convex face cycles
\end{sphinxVerbatim}

\sphinxstylestrong{FFT Module        Fast Fourier transform control values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxprime        maximum number of prime factors of FFT dimension
iprime          prime factorization of each FFT dimension (FFTPACK)
planf           pointer to forward transform data structure (FFTW)
planb           pointer to backward transform data structure (FFTW)
ffttable        intermediate array used by the FFT routine (FFTPACK)
ffttyp          type of FFT package; currently FFTPACK or FFTW
\end{sphinxVerbatim}

\sphinxstylestrong{FIELDS Module        molecular mechanics force field type}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxbio          maximum number of biopolymer atom definitions
biotyp          force field atom type of each biopolymer type
forcefield      string used to describe the current forcefield
\end{sphinxVerbatim}

\sphinxstylestrong{FILES Module        name \& number of current structure file}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nprior          number of previously existing cycle files
ldir            length in characters of the directory name
leng            length in characters of the base filename
filename        base filename used by default for all files
outfile         output filename used for intermediate results
\end{sphinxVerbatim}

\sphinxstylestrong{FRACS Module        distances to molecular center of mass}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
xfrac           fractional coordinate along a\PYGZhy{}axis of center of mass
yfrac           fractional coordinate along b\PYGZhy{}axis of center of mass
zfrac           fractional coordinate along c\PYGZhy{}axis of center of mass
\end{sphinxVerbatim}

\sphinxstylestrong{FREEZE Module        definition of holonomic constraints}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nrat            number of holonomic distance constraints to apply
nratx           number of atom group holonomic constraints to apply
iratx           group number of group in a holonomic constraint
kratx           spatial constraint type (1=plane, 2=line, 3=point)
irat            atom numbers of atoms in a holonomic constraint
rateps          convergence tolerance for holonomic constraints
krat            ideal distance value for holonomic constraint
use\PYGZus{}rattle      logical flag to set use of holonomic contraints
ratimage        flag to use minimum image for holonomic constraint
\end{sphinxVerbatim}

\sphinxstylestrong{GKSTUF Module        generalized Kirkwood solvation values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gkc             tuning parameter exponent in the f(GB) function
gkr             generalized Kirkwood cavity radii for atom types
\end{sphinxVerbatim}

\sphinxstylestrong{GROUP Module        partitioning of system into atom groups}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ngrp            total number of atom groups in the system
kgrp            contiguous list of the atoms in each group
grplist         number of the group to which each atom belongs
igrp            first and last atom of each group in the list
grpmass         total mass of all the atoms in each group
wgrp            weight for each set of group\PYGZhy{}group interactions
use\PYGZus{}group       flag to use partitioning of system into groups
use\PYGZus{}intra       flag to include only intragroup interactions
use\PYGZus{}inter       flag to include only intergroup interactions
\end{sphinxVerbatim}

\sphinxstylestrong{HESCUT Module        cutoff for Hessian matrix elements}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
hesscut         magnitude of smallest allowed Hessian element
\end{sphinxVerbatim}

\sphinxstylestrong{HESSN Module        Cartesian Hessian elements for one atom}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
hessx           Hessian elements for x\PYGZhy{}component of current atom
hessy           Hessian elements for y\PYGZhy{}component of current atom
hessz           Hessian elements for z\PYGZhy{}component of current atom
\end{sphinxVerbatim}

\sphinxstylestrong{HPMF Module        hydrophobic potential of mean force term}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rcarbon         radius of a carbon atom for use with HPMF
rwater          radius of a water molecule for use with HPMF
acsurf          surface area of a hydrophobic carbon atom
safact          constant for calculation of atomic surface area
tgrad           tanh slope (set very steep, default=100)
toffset         shift the tanh plot along the x\PYGZhy{}axis (default=6)
hpmfcut         cutoff distance for pairwise HPMF interactions
hd1             hd2,hd3  hydrophobic PMF well depth parameter
hc1             hc2,hc3  hydrophobic PMF well center point
hw1             hw2,hw3  reciprocal of the hydrophobic PMF well width
npmf            number of hydrophobic carbon atoms in the system
ipmf            number of the atom for each HPMF carbon atom site
rpmf            radius of each atom for use with hydrophobic PMF
acsa            SASA value for each hydrophobic PMF carbon atom
\end{sphinxVerbatim}

\sphinxstylestrong{IELSCF Module        extended Lagrangian induced dipoles}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nfree\PYGZus{}aux       total degrees of freedom for auxiliary dipoles
tautemp\PYGZus{}aux     time constant for auliliary Berendsen thermostat
kelvin\PYGZus{}aux      target system temperature for auxiliary dipoles
uaux            auxiliary induced dipole value at each site
upaux           auxiliary shadow induced dipoles at each site
vaux            auxiliary induced dipole velocity at each site
vpaux           auxiliary shadow dipole velocity at each site
aaux            auxiliary induced dipole acceleration at each site
apaux           auxiliary shadow dipole acceleration at each site
use\PYGZus{}ielscf      flag to use inertial extended Lagrangian method
\end{sphinxVerbatim}

\sphinxstylestrong{IMPROP Module        improper dihedrals in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
niprop          total number of improper dihedral angles in the system
iiprop          numbers of the atoms in each improper dihedral angle
kprop           force constant values for improper dihedral angles
vprop           ideal improper dihedral angle value in degrees
\end{sphinxVerbatim}

\sphinxstylestrong{IMPTOR Module        improper torsions in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nitors          total number of improper torsional angles in the system
iitors          numbers of the atoms in each improper torsional angle
itors1          1\PYGZhy{}fold amplitude and phase for each improper torsion
itors2          2\PYGZhy{}fold amplitude and phase for each improper torsion
itors3          3\PYGZhy{}fold amplitude and phase for each improper torsion
\end{sphinxVerbatim}

\sphinxstylestrong{INFORM Module        program I/O and flow control values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxask          maximum number of queries for interactive input
digits          decimal places output for energy and coordinates
iprint          steps between status printing (0=no printing)
iwrite          steps between coordinate saves (0=no saves)
isend           steps between socket communication (0=no sockets)
silent          logical flag to turn off all information printing
verbose         logical flag to turn on extra information printing
debug           logical flag to turn on full debug printing
holdup          logical flag to wait for carriage return on exit
abort           logical flag to stop execution at next chance
\end{sphinxVerbatim}

\sphinxstylestrong{INTER Module        sum of intermolecular energy components}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
einter          total intermolecular potential energy
\end{sphinxVerbatim}

\sphinxstylestrong{IOUNIT Module        Fortran input/output unit numbers}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
input           Fortran I/O unit for main input (default=5)
iout            Fortran I/O unit for main output (default=6)
\end{sphinxVerbatim}

\sphinxstylestrong{KANANG Module        angle\sphinxhyphen{}angle term forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
anan            angle\PYGZhy{}angle cross term parameters for each atom class
\end{sphinxVerbatim}

\sphinxstylestrong{KANGS Module        bond angle bend forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxna           maximum number of harmonic angle bend parameter entries
maxna5          maximum number of 5\PYGZhy{}membered ring angle bend entries
maxna4          maximum number of 4\PYGZhy{}membered ring angle bend entries
maxna3          maximum number of 3\PYGZhy{}membered ring angle bend entries
maxnap          maximum number of in\PYGZhy{}plane angle bend parameter entries
maxnaf          maximum number of Fourier angle bend parameter entries
acon            force constant parameters for harmonic angle bends
acon5           force constant parameters for 5\PYGZhy{}ring angle bends
acon4           force constant parameters for 4\PYGZhy{}ring angle bends
acon3           force constant parameters for 3\PYGZhy{}ring angle bends
aconp           force constant parameters for in\PYGZhy{}plane angle bends
aconf           force constant parameters for Fourier angle bends
ang             bond angle parameters for harmonic angle bends
ang5            bond angle parameters for 5\PYGZhy{}ring angle bends
ang4            bond angle parameters for 4\PYGZhy{}ring angle bends
ang3            bond angle parameters for 3\PYGZhy{}ring angle bends
angp            bond angle parameters for in\PYGZhy{}plane angle bends
angf            phase shift angle and periodicity for Fourier bends
ka              string of atom classes for harmonic angle bends
ka5             string of atom classes for 5\PYGZhy{}ring angle bends
ka4             string of atom classes for 4\PYGZhy{}ring angle bends
ka3             string of atom classes for 3\PYGZhy{}ring angle bends
kap             string of atom classes for in\PYGZhy{}plane angle bends
kaf             string of atom classes for Fourier angle bends
\end{sphinxVerbatim}

\sphinxstylestrong{KANTOR Module        angle\sphinxhyphen{}torsion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnat          maximum number of angle\PYGZhy{}torsion parameter entries
atcon           torsional amplitude parameters for angle\PYGZhy{}torsion
kat             string of atom classes for angle\PYGZhy{}torsion terms
\end{sphinxVerbatim}

\sphinxstylestrong{KATOMS Module        atom definition forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
atmcls          atom class number for each of the atom types
atmnum          atomic number for each of the atom types
ligand          number of atoms to be attached to each atom type
weight          average atomic mass of each atom type
symbol          modified atomic symbol for each atom type
describe        string identifying each of the atom types
\end{sphinxVerbatim}

\sphinxstylestrong{KBONDS Module        bond stretching forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnb           maximum number of bond stretch parameter entries
maxnb5          maximum number of 5\PYGZhy{}membered ring bond stretch entries
maxnb4          maximum number of 4\PYGZhy{}membered ring bond stretch entries
maxnb3          maximum number of 3\PYGZhy{}membered ring bond stretch entries
maxnel          maximum number of electronegativity bond corrections
bcon            force constant parameters for harmonic bond stretch
bcon5           force constant parameters for 5\PYGZhy{}ring bond stretch
bcon4           force constant parameters for 4\PYGZhy{}ring bond stretch
bcon3           force constant parameters for 3\PYGZhy{}ring bond stretch
blen            bond length parameters for harmonic bond stretch
blen5           bond length parameters for 5\PYGZhy{}ring bond stretch
blen4           bond length parameters for 4\PYGZhy{}ring bond stretch
blen3           bond length parameters for 3\PYGZhy{}ring bond stretch
dlen            electronegativity bond length correction parameters
kb              string of atom classes for harmonic bond stretch
kb5             string of atom classes for 5\PYGZhy{}ring bond stretch
kb4             string of atom classes for 4\PYGZhy{}ring bond stretch
kb3             string of atom classes for 3\PYGZhy{}ring bond stretch
kel             string of atom classes for electronegativity corrections
\end{sphinxVerbatim}

\sphinxstylestrong{KCHRGE Module        partial charge forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
chg             partial charge parameters for each atom type
\end{sphinxVerbatim}

\sphinxstylestrong{KCPEN Module        charge penetration forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cpele           valence electron magnitude for each atom class
cpalp           alpha charge penetration parameter for each atom class
\end{sphinxVerbatim}

\sphinxstylestrong{KCTRN Module        charge transfer forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ctchg           charge transfer magnitude for each atom class
ctdmp           alpha charge transfer parameter for each atom class
\end{sphinxVerbatim}

\sphinxstylestrong{KDIPOL Module        bond dipole forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnd           maximum number of bond dipole parameter entries
maxnd5          maximum number of 5\PYGZhy{}membered ring dipole entries
maxnd4          maximum number of 4\PYGZhy{}membered ring dipole entries
maxnd3          maximum number of 3\PYGZhy{}membered ring dipole entries
dpl             dipole moment parameters for bond dipoles
dpl5            dipole moment parameters for 5\PYGZhy{}ring dipoles
dpl4            dipole moment parameters for 4\PYGZhy{}ring dipoles
dpl3            dipole moment parameters for 3\PYGZhy{}ring dipoles
pos             dipole position parameters for bond dipoles
pos5            dipole position parameters for 5\PYGZhy{}ring dipoles
pos4            dipole position parameters for 4\PYGZhy{}ring dipoles
pos3            dipole position parameters for 3\PYGZhy{}ring dipoles
kd              string of atom classes for bond dipoles
kd5             string of atom classes for 5\PYGZhy{}ring dipoles
kd4             string of atom classes for 4\PYGZhy{}ring dipoles
kd3             string of atom classes for 3\PYGZhy{}ring dipoles
\end{sphinxVerbatim}

\sphinxstylestrong{KDSP Module        damped dispersion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
dspsix          C6 dispersion coefficient for each atom class
dspdmp          alpha dispersion parameter for each atom class
\end{sphinxVerbatim}

\sphinxstylestrong{KEYS Module        contents of the keyword control file}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxkey          maximum number of lines in the keyword file
nkey            number of nonblank lines in the keyword file
keyline         contents of each individual keyword file line
\end{sphinxVerbatim}

\sphinxstylestrong{KHBOND Module        H\sphinxhyphen{}bonding term forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnhb          maximum number of hydrogen bonding pair entries
radhb           radius parameter for hydrogen bonding pairs
epshb           well depth parameter for hydrogen bonding pairs
khb             string of atom types for hydrogen bonding pairs
\end{sphinxVerbatim}

\sphinxstylestrong{KIPROP Module        improper dihedral forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxndi          maximum number of improper dihedral parameter entries
dcon            force constant parameters for improper dihedrals
tdi             ideal dihedral angle values for improper dihedrals
kdi             string of atom classes for improper dihedral angles
\end{sphinxVerbatim}

\sphinxstylestrong{KITORS Module        improper torsion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnti          maximum number of improper torsion parameter entries
ti1             torsional parameters for improper 1\PYGZhy{}fold rotation
ti2             torsional parameters for improper 2\PYGZhy{}fold rotation
ti3             torsional parameters for improper 3\PYGZhy{}fold rotation
kti             string of atom classes for improper torsional parameters
\end{sphinxVerbatim}

\sphinxstylestrong{KMULTI Module        atomic multipole forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnmp          maximum number of atomic multipole parameter entries
multip          atomic monopole, dipole and quadrupole values
mpaxis          type of local axis definition for atomic multipoles
kmp             string of atom types for atomic multipoles
\end{sphinxVerbatim}

\sphinxstylestrong{KOPBND Module        out\sphinxhyphen{}of\sphinxhyphen{}plane bend forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnopb         maximum number of out\PYGZhy{}of\PYGZhy{}plane bending entries
opbn            force constant parameters for out\PYGZhy{}of\PYGZhy{}plane bending
kopb            string of atom classes for out\PYGZhy{}of\PYGZhy{}plane bending
\end{sphinxVerbatim}

\sphinxstylestrong{KOPDST Module        out\sphinxhyphen{}of\sphinxhyphen{}plane distance forcefield params}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnopd         maximum number of out\PYGZhy{}of\PYGZhy{}plane distance entries
opds            force constant parameters for out\PYGZhy{}of\PYGZhy{}plane distance
kopd            string of atom classes for out\PYGZhy{}of\PYGZhy{}plane distance
\end{sphinxVerbatim}

\sphinxstylestrong{KORBS Module        pisystem orbital forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnpi          maximum number of pisystem bond parameter entries
maxnpi5         maximum number of 5\PYGZhy{}membered ring pibond entries
maxnpi4         maximum number of 4\PYGZhy{}membered ring pibond entries
sslope          slope for bond stretch vs. pi\PYGZhy{}bond order
sslope5         slope for 5\PYGZhy{}ring bond stretch vs. pi\PYGZhy{}bond order
sslope4         slope for 4\PYGZhy{}ring bond stretch vs. pi\PYGZhy{}bond order
tslope          slope for 2\PYGZhy{}fold torsion vs. pi\PYGZhy{}bond order
tslope5         slope for 5\PYGZhy{}ring 2\PYGZhy{}fold torsion vs. pi\PYGZhy{}bond order
tslope4         slope for 4\PYGZhy{}ring 2\PYGZhy{}fold torsion vs. pi\PYGZhy{}bond order
electron        number of pi\PYGZhy{}electrons for each atom class
ionize          ionization potential for each atom class
repulse         repulsion integral value for each atom class
kpi             string of atom classes for pisystem bonds
kpi5            string of atom classes for 5\PYGZhy{}ring pisystem bonds
kpi4            string of atom classes for 4\PYGZhy{}ring pisystem bonds
\end{sphinxVerbatim}

\sphinxstylestrong{KPITOR Module        pi\sphinxhyphen{}system torsion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnpt          maximum number of pi\PYGZhy{}system torsion parameter entries
ptcon           force constant parameters for pi\PYGZhy{}system torsions
kpt             string of atom classes for pi\PYGZhy{}system torsion terms
\end{sphinxVerbatim}

\sphinxstylestrong{KPOLR Module        polarizability forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pgrp            connected types in polarization group of each atom type
polr            dipole polarizability parameters for each atom type
athl            Thole polarizability damping value for each atom type
ddir            direct polarization damping value for each atom type
\end{sphinxVerbatim}

\sphinxstylestrong{KREPL Module        Pauli repulsion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
prsiz           Pauli repulsion size value for each atom class
prdmp           alpha Pauli repulsion parameter for each atom class
prele           number of valence electrons for each atom class
\end{sphinxVerbatim}

\sphinxstylestrong{KSTBND Module        stretch\sphinxhyphen{}bend forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnsb          maximum number of stretch\PYGZhy{}bend parameter entries
stbn            force constant parameters for stretch\PYGZhy{}bend terms
ksb             string of atom classes for stretch\PYGZhy{}bend terms
\end{sphinxVerbatim}

\sphinxstylestrong{KSTTOR Module        stretch\sphinxhyphen{}torsion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnbt          maximum number of stretch\PYGZhy{}torsion parameter entries
btcon           torsional amplitude parameters for stretch\PYGZhy{}torsion
kbt             string of atom classes for stretch\PYGZhy{}torsion terms
\end{sphinxVerbatim}

\sphinxstylestrong{KTORSN Module        torsional angle forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnt           maximum number of torsional angle parameter entries
maxnt5          maximum number of 5\PYGZhy{}membered ring torsion entries
maxnt4          maximum number of 4\PYGZhy{}membered ring torsion entries
t1              torsional parameters for standard 1\PYGZhy{}fold rotation
t2              torsional parameters for standard 2\PYGZhy{}fold rotation
t3              torsional parameters for standard 3\PYGZhy{}fold rotation
t4              torsional parameters for standard 4\PYGZhy{}fold rotation
t5              torsional parameters for standard 5\PYGZhy{}fold rotation
t6              torsional parameters for standard 6\PYGZhy{}fold rotation
t15             torsional parameters for 1\PYGZhy{}fold rotation in 5\PYGZhy{}ring
t25             torsional parameters for 2\PYGZhy{}fold rotation in 5\PYGZhy{}ring
t35             torsional parameters for 3\PYGZhy{}fold rotation in 5\PYGZhy{}ring
t45             torsional parameters for 4\PYGZhy{}fold rotation in 5\PYGZhy{}ring
t55             torsional parameters for 5\PYGZhy{}fold rotation in 5\PYGZhy{}ring
t65             torsional parameters for 6\PYGZhy{}fold rotation in 5\PYGZhy{}ring
t14             torsional parameters for 1\PYGZhy{}fold rotation in 4\PYGZhy{}ring
t24             torsional parameters for 2\PYGZhy{}fold rotation in 4\PYGZhy{}ring
t34             torsional parameters for 3\PYGZhy{}fold rotation in 4\PYGZhy{}ring
t44             torsional parameters for 4\PYGZhy{}fold rotation in 4\PYGZhy{}ring
t54             torsional parameters for 5\PYGZhy{}fold rotation in 4\PYGZhy{}ring
t64             torsional parameters for 6\PYGZhy{}fold rotation in 4\PYGZhy{}ring
kt              string of atom classes for torsional angles
kt5             string of atom classes for 5\PYGZhy{}ring torsions
kt4             string of atom classes for 4\PYGZhy{}ring torsions
\end{sphinxVerbatim}

\sphinxstylestrong{KTRTOR Module        torsion\sphinxhyphen{}torsion forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxntt          maximum number of torsion\PYGZhy{}torsion parameter entries
maxtgrd         maximum dimension of torsion\PYGZhy{}torsion spline grid
maxtgrd2        maximum number of torsion\PYGZhy{}torsion spline grid points
tnx             number of columns in torsion\PYGZhy{}torsion spline grid
tny             number of rows in torsion\PYGZhy{}torsion spline grid
ttx             angle values for first torsion of spline grid
tty             angle values for second torsion of spline grid
tbf             function values at points on spline grid
tbx             gradient over first torsion of spline grid
tby             gradient over second torsion of spline grid
tbxy            Hessian cross components over spline grid
ktt             string of torsion\PYGZhy{}torsion atom classes
\end{sphinxVerbatim}

\sphinxstylestrong{KURYBR Module        Urey\sphinxhyphen{}Bradley term forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnu           maximum number of Urey\PYGZhy{}Bradley parameter entries
ucon            force constant parameters for Urey\PYGZhy{}Bradley terms
dst13           ideal 1\PYGZhy{}3 distance parameters for Urey\PYGZhy{}Bradley terms
ku              string of atom classes for Urey\PYGZhy{}Bradley terms
\end{sphinxVerbatim}

\sphinxstylestrong{KVDWPR Module        special vdw term forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxnvp          maximum number of special van der Waals pair entries
radpr           radius parameter for special van der Waals pairs
epspr           well depth parameter for special van der Waals pairs
kvpr            string of atom classes for special van der Waals pairs
\end{sphinxVerbatim}

\sphinxstylestrong{KVDWS Module        van der Waals term forcefield parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rad             van der Waals radius parameter for each atom type
eps             van der Waals well depth parameter for each atom type
rad4            van der Waals radius parameter in 1\PYGZhy{}4 interactions
eps4            van der Waals well depth parameter in 1\PYGZhy{}4 interactions
reduct          van der Waals reduction factor for each atom type
\end{sphinxVerbatim}

\sphinxstylestrong{LIGHT Module        method of lights pair neighbors indices}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nlight          total number of sites for method of lights calculation
kbx             low index of neighbors of each site in the x\PYGZhy{}sorted list
kby             low index of neighbors of each site in the y\PYGZhy{}sorted list
kbz             low index of neighbors of each site in the z\PYGZhy{}sorted list
kex             high index of neighbors of each site in the x\PYGZhy{}sorted list
key             high index of neighbors of each site in the y\PYGZhy{}sorted list
kez             high index of neighbors of each site in the z\PYGZhy{}sorted list
locx            maps the x\PYGZhy{}sorted list into original interaction list
locy            maps the y\PYGZhy{}sorted list into original interaction list
locz            maps the z\PYGZhy{}sorted list into original interaction list
rgx             maps the original interaction list into x\PYGZhy{}sorted list
rgy             maps the original interaction list into y\PYGZhy{}sorted list
rgz             maps the original interaction list into z\PYGZhy{}sorted list
\end{sphinxVerbatim}

\sphinxstylestrong{LIMITS Module        interaction taper \& cutoff distances}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
vdwcut          cutoff distance for van der Waals interactions
repcut          cutoff distance for Pauli repulsion interactions
dispcut         cutoff distance for dispersion interactions
chgcut          cutoff distance for charge\PYGZhy{}charge interactions
dplcut          cutoff distance for dipole\PYGZhy{}dipole interactions
mpolecut        cutoff distance for atomic multipole interactions
ctrncut         cutoff distance for charge transfer interactions
vdwtaper        distance at which van der Waals switching begins
reptaper        distance at which Pauli repulsion switching begins
disptaper       distance at which dispersion switching begins
chgtaper        distance at which charge\PYGZhy{}charge switching begins
dpltaper        distance at which dipole\PYGZhy{}dipole switching begins
mpoletaper      distance at which atomic multipole switching begins
ctrntaper       distance at which charge transfer switching begins
ewaldcut        cutoff distance for real space Ewald electrostatics
dewaldcut       cutoff distance for real space Ewald dispersion
usolvcut        cutoff distance for dipole solver preconditioner
use\PYGZus{}ewald       logical flag governing use of electrostatic Ewald
use\PYGZus{}dewald      logical flag governing use of dispersion Ewald
use\PYGZus{}lights      logical flag governing use of method of lights
use\PYGZus{}list        logical flag governing use of any neighbor lists
use\PYGZus{}vlist       logical flag governing use of van der Waals list
use\PYGZus{}dlist       logical flag governing use of dispersion list
use\PYGZus{}clist       logical flag governing use of charge list
use\PYGZus{}mlist       logical flag governing use of multipole list
use\PYGZus{}ulist       logical flag governing use of preconditioner list
\end{sphinxVerbatim}

\sphinxstylestrong{LINMIN Module        line search minimization parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
stpmin          minimum step length in current line search direction
stpmax          maximum step length in current line search direction
cappa           stringency of line search (0=tight \PYGZlt{} cappa \PYGZlt{} 1=loose)
slpmax          projected gradient above which stepsize is reduced
angmax          maximum angle between search direction and \PYGZhy{}gradient
intmax          maximum number of interpolations during line search
\end{sphinxVerbatim}

\sphinxstylestrong{MATH Module        mathematical and geometrical constants}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pi              numerical value of the geometric constant
elog            numerical value of the natural logarithm base
radian          conversion factor from radians to degrees
logten          numerical value of the natural log of ten
twosix          numerical value of the sixth root of two
sqrtpi          numerical value of the square root of Pi
sqrttwo         numerical value of the square root of two
sqrtthree       numerical value of the square root of three
\end{sphinxVerbatim}

\sphinxstylestrong{MDSTUF Module        molecular dynamics trajectory controls}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nfree           total number of degrees of freedom for a system
irest           steps between removal of COM motion (0=no removal)
bmnmix          mixing coefficient for use with Beeman integrator
arespa          inner time step for use with RESPA integrator
dorest          logical flag to remove center of mass motion
integrate       type of molecular dynamics integration algorithm
\end{sphinxVerbatim}

\sphinxstylestrong{MERCK Module        MMFF\sphinxhyphen{}specific force field parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nlignes         number of atom pairs having MMFF Bond Type 1
bt\PYGZus{}1            atom pairs having MMFF Bond Type 1
eqclass         table of atom class equivalencies used to find
default         parameters if explicit values are missing
see             J. Comput. Chem., 17, 490\PYGZhy{}519, \PYGZsq{}95, Table IV)
crd             number of attached neighbors    |
val             valency value                   |  see T. A. Halgren,
pilp            if 0, no lone pair              |  J. Comput. Chem.,
if              1, one or more lone pair(s)  |  17, 616\PYGZhy{}645 (1995)
mltb            multibond indicator             |
arom            aromaticity indicator           |
lin             linearity indicator             |
sbmb            single\PYGZhy{} vs multiple\PYGZhy{}bond flag   |
mmffarom        aromatic rings parameters
mmffaromc       cationic aromatic rings parameters
mmffaroma       anionic aromatic rings parameters
\end{sphinxVerbatim}

\sphinxstylestrong{MINIMA Module        general parameters for minimizations}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
fctmin          value below which function is deemed optimized
hguess          initial value for the H\PYGZhy{}matrix diagonal elements
maxiter         maximum number of iterations during optimization
nextiter        iteration number to use for the first iteration
\end{sphinxVerbatim}

\sphinxstylestrong{MOLCUL Module        individual molecules in current system}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nmol            total number of separate molecules in the system
imol            first and last atom of each molecule in the list
kmol            contiguous list of the atoms in each molecule
molcule         number of the molecule to which each atom belongs
totmass         total weight of all the molecules in the system
molmass         molecular weight for each molecule in the system
\end{sphinxVerbatim}

\sphinxstylestrong{MOLDYN Module        MD trajectory velocity \& acceleration}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
v               current velocity of each atom along the x,y,z\PYGZhy{}axes
a               current acceleration of each atom along x,y,z\PYGZhy{}axes
aalt            alternate acceleration of each atom along x,y,z\PYGZhy{}axes
\end{sphinxVerbatim}

\sphinxstylestrong{MOMENT Module        electric multipole moment components}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
netchg          net electric charge for the total system
netdpl          dipole moment magnitude for the total system
netqdp          diagonal quadrupole (Qxx, Qyy, Qzz) for system
xdpl            dipole vector x\PYGZhy{}component in the global frame
ydpl            dipole vector y\PYGZhy{}component in the global frame
zdpl            dipole vector z\PYGZhy{}component in the global frame
xxqdp           quadrupole tensor xx\PYGZhy{}component in global frame
xyqdp           quadrupole tensor xy\PYGZhy{}component in global frame
xzqdp           quadrupole tensor xz\PYGZhy{}component in global frame
yxqdp           quadrupole tensor yx\PYGZhy{}component in global frame
yyqdp           quadrupole tensor yy\PYGZhy{}component in global frame
yzqdp           quadrupole tensor yz\PYGZhy{}component in global frame
zxqdp           quadrupole tensor zx\PYGZhy{}component in global frame
zyqdp           quadrupole tensor zy\PYGZhy{}component in global frame
zzqdp           quadrupole tensor zz\PYGZhy{}component in global frame
\end{sphinxVerbatim}

\sphinxstylestrong{MPLPOT Module        multipole functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
m2scale         scale factor for 1\PYGZhy{}2 multipole energy interactions
m3scale         scale factor for 1\PYGZhy{}3 multipole energy interactions
m4scale         scale factor for 1\PYGZhy{}4 multipole energy interactions
m5scale         scale factor for 1\PYGZhy{}5 multipole energy interactions
use\PYGZus{}chgpen      flag to use charge penetration damped potential
pentyp          type of penetration damping (NONE, GORDON1, GORDON2)
\end{sphinxVerbatim}

\sphinxstylestrong{MPOLE Module        atomic multipoles in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxpole         max components (monopole=1,dipole=4,quadrupole=13)
npole           total number of multipole sites in the system
ipole           number of the atom for each multipole site
polsiz          number of multipole components at each atom
pollist         multipole site for each atom (0=no multipole)
zaxis           number of the z\PYGZhy{}axis defining atom for each site
xaxis           number of the x\PYGZhy{}axis defining atom for each site
yaxis           number of the y\PYGZhy{}axis defining atom for each site
pole            traceless Cartesian multipoles in the local frame
rpole           traceless Cartesian multipoles in the global frame
spole           spherical harmonic multipoles in the local frame
srpole          spherical harmonic multipoles in the global frame
mono0           original atomic monopole values for charge flux
polaxe          local axis type for each multipole site
\end{sphinxVerbatim}

\sphinxstylestrong{MRECIP Module        reciprocal PME for permanent multipoles}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
vmxx            scalar sum xx\PYGZhy{}component of virial due to multipoles
vmyy            scalar sum yy\PYGZhy{}component of virial due to multipoles
vmzz            scalar sum zz\PYGZhy{}component of virial due to multipoles
vmxy            scalar sum xy\PYGZhy{}component of virial due to multipoles
vmxz            scalar sum xz\PYGZhy{}component of virial due to multipoles
vmyz            scalar sum yz\PYGZhy{}component of virial due to multipoles
cmp             Cartesian permenent multipoles as polytensor vector
fmp             fractional permanent multipoles as polytensor vector
cphi            Cartesian permanent multipole potential and field
fphi            fractional permanent multipole potential and field
\end{sphinxVerbatim}

\sphinxstylestrong{MUTANT Module        free energy calculation hybrid atoms}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nmut            number of atoms mutated from initial to final state
vcouple         van der Waals lambda type (0=decouple, 1=annihilate)
imut            atomic sites differing in initial and final state
type0           atom type of each atom in the initial state system
class0          atom class of each atom in the initial state system
type1           atom type of each atom in the final state system
class1          atom class of each atom in the final state system
lambda          generic weighting between initial and final states
tlambda         state weighting value for torsional potential
vlambda         state weighting value for van der Waals potentials
elambda         state weighting value for electrostatic potentials
scexp           scale factor for soft core buffered 14\PYGZhy{}7 potential
scalpha         scale factor for soft core buffered 14\PYGZhy{}7 potential
mut             true if an atom is to be mutated, false otherwise
\end{sphinxVerbatim}

\sphinxstylestrong{NEIGH Module        pairwise neighbor list indices \& storage}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxvlst         maximum size of van der Waals pair neighbor lists
maxelst         maximum size of electrostatic pair neighbor lists
maxulst         maximum size of dipole preconditioner pair lists
nvlst           number of sites in list for each vdw site
vlst            site numbers in neighbor list of each vdw site
nelst           number of sites in list for each electrostatic site
elst            site numbers in list of each electrostatic site
nulst           number of sites in list for each preconditioner site
ulst            site numbers in list of each preconditioner site
lbuffer         width of the neighbor list buffer region
pbuffer         width of the preconditioner list buffer region
lbuf2           square of half the neighbor list buffer width
pbuf2           square of half the preconditioner list buffer width
vbuf2           square of van der Waals cutoff plus the list buffer
vbufx           square of van der Waals cutoff plus 2X list buffer
dbuf2           square of dispersion cutoff plus the list buffer
dbufx           square of dispersion cutoff plus 2X list buffer
cbuf2           square of charge cutoff plus the list buffer
cbufx           square of charge cutoff plus 2X list buffer
mbuf2           square of multipole cutoff plus the list buffer
mbufx           square of multipole cutoff plus 2X list buffer
ubuf2           square of preconditioner cutoff plus the list buffer
ubufx           square of preconditioner cutoff plus 2X list buffer
xvold           x\PYGZhy{}coordinate at last vdw/dispersion list update
yvold           y\PYGZhy{}coordinate at last vdw/dispersion list update
zvold           z\PYGZhy{}coordinate at last vdw/dispersion list update
xeold           x\PYGZhy{}coordinate at last electrostatic list update
yeold           y\PYGZhy{}coordinate at last electrostatic list update
zeold           z\PYGZhy{}coordinate at last electrostatic list update
xuold           x\PYGZhy{}coordinate at last preconditioner list update
yuold           y\PYGZhy{}coordinate at last preconditioner list update
zuold           z\PYGZhy{}coordinate at last preconditioner list update
dovlst          logical flag to rebuild vdw neighbor list
dodlst          logical flag to rebuild dispersion neighbor list
doclst          logical flag to rebuild charge neighbor list
domlst          logical flag to rebuild multipole neighbor list
doulst          logical flag to rebuild preconditioner neighbor list
\end{sphinxVerbatim}

\sphinxstylestrong{NONPOL Module        nonpolar cavity \& dispersion parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
epso            water oxygen eps for implicit dispersion term
epsh            water hydrogen eps for implicit dispersion term
rmino           water oxygen Rmin for implicit dispersion term
rminh           water hydrogen Rmin for implicit dispersion term
awater          water number density at standard temp \PYGZam{} pressure
slevy           enthalpy\PYGZhy{}to\PYGZhy{}free energy scale factor for dispersion
solvprs         limiting microscopic solvent pressure value
surften         limiting macroscopic surface tension value
spcut           starting radius for solvent pressure tapering
spoff           cutoff radius for solvent pressure tapering
stcut           starting radius for surface tension tapering
stoff           cutoff radius for surface tension tapering
rcav            atomic radius of each atom for cavitation energy
rdisp           atomic radius of each atom for dispersion energy
cdisp           maximum dispersion energy for each atom
\end{sphinxVerbatim}

\sphinxstylestrong{NUCLEO Module        parameters for nucleic acid structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pucker          sugar pucker, either 2=2\PYGZsq{}\PYGZhy{}endo or 3=3\PYGZsq{}\PYGZhy{}endo
glyco           glycosidic torsional angle for each nucleotide
bkbone          phosphate backbone angles for each nucleotide
dblhlx          flag to mark system as nucleic acid double helix
deoxy           flag to mark deoxyribose or ribose sugar units
hlxform         helix form (A, B or Z) of polynucleotide strands
\end{sphinxVerbatim}

\sphinxstylestrong{OMEGA Module        torsional space dihedral angle values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nomega          number of dihedral angles allowed to rotate
iomega          numbers of two atoms defining rotation axis
zline           line number in Z\PYGZhy{}matrix of each dihedral angle
dihed           current value in radians of each dihedral angle
\end{sphinxVerbatim}

\sphinxstylestrong{OPBEND Module        out\sphinxhyphen{}of\sphinxhyphen{}plane bends in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nopbend         total number of out\PYGZhy{}of\PYGZhy{}plane bends in the system
iopb            bond angle numbers used in out\PYGZhy{}of\PYGZhy{}plane bending
opbk            force constant values for out\PYGZhy{}of\PYGZhy{}plane bending
\end{sphinxVerbatim}

\sphinxstylestrong{OPDIST Module        out\sphinxhyphen{}of\sphinxhyphen{}plane distances in structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nopdist         total number of out\PYGZhy{}of\PYGZhy{}plane distances in the system
iopd            numbers of the atoms in each out\PYGZhy{}of\PYGZhy{}plane distance
opdk            force constant values for out\PYGZhy{}of\PYGZhy{}plane distance
\end{sphinxVerbatim}

\sphinxstylestrong{OPENMP Module        OpenMP processor and thread values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nproc           number of processors available to OpenMP
nthread         number of threads to be used with OpenMP
\end{sphinxVerbatim}

\sphinxstylestrong{ORBITS Module        conjugated pisystem orbital energies}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
qorb            number of pi\PYGZhy{}electrons contributed by each atom
worb            ionization potential of each pisystem atom
emorb           repulsion integral for each pisystem atom
\end{sphinxVerbatim}

\sphinxstylestrong{OUTPUT Module        output file format control parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
archive         logical flag to save structures in an archive
noversion       logical flag governing use of filename versions
overwrite       logical flag to overwrite intermediate files inplace
cyclesave       logical flag to mark use of numbered cycle files
velsave         logical flag to save velocity vector components
frcsave         logical flag to save force vector components
uindsave        logical flag to save induced atomic dipoles
coordtype       selects Cartesian, internal, rigid body or none
\end{sphinxVerbatim}

\sphinxstylestrong{PARAMS Module        force field parameter file contents}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxprm          maximum number of lines in the parameter file
nprm            number of nonblank lines in the parameter file
prmline         contents of each individual parameter file line
\end{sphinxVerbatim}

\sphinxstylestrong{PATHS Module        Elber reaction path method parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pnorm           length of the reactant\PYGZhy{}product vector
acoeff          transformation matrix \PYGZsq{}A\PYGZsq{} from Elber algorithm
pc0             reactant Cartesian coordinates as variables
pc1             product Cartesian coordinates as variables
pvect           vector connecting the reactant and product
pstep           step per cycle along reactant\PYGZhy{}product vector
pzet            current projection on reactant\PYGZhy{}product vector
gc              gradient of the path constraints
\end{sphinxVerbatim}

\sphinxstylestrong{PBSTUF Module        Poisson\sphinxhyphen{}Boltzmann solvation parameters}

APBS configuration parameters (see APBS documentation for details). In
the column on the right are possible values for each variable, with default
values given in brackets. Only a subset of the APBS options are supported
and/or are appropriate for use with AMOEBA.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
pbtyp           lpbe
pbsoln          mg\PYGZhy{}auto, [mg\PYGZhy{}manual]
bcfl            boundary conditions              zero, sdh, [mdh]
chgm            multipole discretization         spl4
srfm            surface method                   mol, smol, [spl4]
dime            number of grid points            [65, 65, 65]
grid            grid spacing (mg\PYGZhy{}manual)         fxn of \PYGZdq{}dime\PYGZdq{}
cgrid           coarse grid spacing              fxn of \PYGZdq{}dime\PYGZdq{}
fgrid           fine grid spacing                cgrid / 2
gcent           grid center (mg\PYGZhy{}manual)          center of mass
cgcent          coarse grid center               center of mass
fgcent          fine grid center                 center of mass
pdie            solute/homogeneous dieletric     [1.0]
sdie            solvent dieletric                [78.3]
ionn            number of ion species            [0]
ionc            ion concentration (M)            [0.0]
ionq            ion charge (electrons)           [1.0]
ionr            ion radius (A)                   [2.0]
srad            solvent probe radius (A)         [1.4]
swin            surface spline window width      [0.3]
sdens           density of surface points        [10.0]
smin            minimum distance between an      [10.0]
pbe             Poisson\PYGZhy{}Boltzmann permanent multipole solvation energy
apbe            Poisson\PYGZhy{}Boltzmann permanent multipole energy over atoms
pbr             Poisson\PYGZhy{}Boltzmann cavity radii for atom types
pbep            Poisson\PYGZhy{}Boltzmann energies on permanent multipoles
pbfp            Poisson\PYGZhy{}Boltzmann forces on permanent multipoles
pbtp            Poisson\PYGZhy{}Boltzmann torques on permanent multipoles
pbeuind         Poisson\PYGZhy{}Boltzmann field due to induced dipoles
pbeuinp         Poisson\PYGZhy{}Boltzmann field due to non\PYGZhy{}local induced dipoles
\end{sphinxVerbatim}

\sphinxstylestrong{PDB Module        Protein Data Bank structure definition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
npdb            number of atoms stored in Protein Data Bank format
nres            number of residues stored in Protein Data Bank format
resnum          number of the residue to which each atom belongs
resatm          number of first and last atom in each residue
npdb12          number of atoms directly bonded to each CONECT atom
ipdb12          atom numbers of atoms connected to each CONECT atom
pdblist         list of the Protein Data Bank atom number of each atom
xpdb            x\PYGZhy{}coordinate of each atom stored in PDB format
ypdb            y\PYGZhy{}coordinate of each atom stored in PDB format
zpdb            z\PYGZhy{}coordinate of each atom stored in PDB format
altsym          string with PDB alternate locations to be included
pdbres          Protein Data Bank residue name assigned to each atom
pdbatm          Protein Data Bank atom name assigned to each atom
pdbtyp          Protein Data Bank record type assigned to each atom
chnsym          string with PDB chain identifiers to be included
instyp          string with PDB insertion records to be included
\end{sphinxVerbatim}

\sphinxstylestrong{PHIPSI Module        phi\sphinxhyphen{}psi\sphinxhyphen{}omega\sphinxhyphen{}chi angles for protein}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
chiral          chirality of each amino acid residue (1=L, \PYGZhy{}1=D)
disulf          residue joined to each residue via a disulfide link
phi             value of the phi angle for each amino acid residue
psi             value of the psi angle for each amino acid residue
omg             value of the omega angle for each amino acid residue
chi             values of the chi angles for each amino acid residue
\end{sphinxVerbatim}

\sphinxstylestrong{PIORBS Module        conjugated system in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
norbit          total number of pisystem orbitals in the system
nconj           total number of separate conjugated piystems
reorbit         number of evaluations between orbital updates
nbpi            total number of bonds affected by the pisystem
ntpi            total number of torsions affected by the pisystem
iorbit          numbers of the atoms containing pisystem orbitals
iconj           first and last atom of each pisystem in the list
kconj           contiguous list of atoms in each pisystem
piperp          atoms defining a normal plane to each orbital
ibpi            bond and piatom numbers for each pisystem bond
itpi            torsion and pibond numbers for each pisystem torsion
pbpl            pi\PYGZhy{}bond orders for bonds in \PYGZdq{}planar\PYGZdq{} pisystem
pnpl            pi\PYGZhy{}bond orders for bonds in \PYGZdq{}nonplanar\PYGZdq{} pisystem
listpi          atom list indicating whether each atom has an orbital
\end{sphinxVerbatim}

\sphinxstylestrong{PISTUF Module        bond order\sphinxhyphen{}related pisystem parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
bkpi            bond stretch force constants for pi\PYGZhy{}bond order of 1.0
blpi            ideal bond length values for a pi\PYGZhy{}bond order of 1.0
kslope          rate of force constant decrease with bond order decrease
lslope          rate of bond length increase with a bond order decrease
torsp2          2\PYGZhy{}fold torsional energy barrier for pi\PYGZhy{}bond order of 1.0
\end{sphinxVerbatim}

\sphinxstylestrong{PITORS Module        pi\sphinxhyphen{}system torsions in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
npitors         total number of pi\PYGZhy{}system torsional interactions
ipit            numbers of the atoms in each pi\PYGZhy{}system torsion
kpit            2\PYGZhy{}fold pi\PYGZhy{}system torsional force constants
\end{sphinxVerbatim}

\sphinxstylestrong{PME Module        values for particle mesh Ewald summation}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nfft1           current number of PME grid points along a\PYGZhy{}axis
nfft2           current number of PME grid points along b\PYGZhy{}axis
nfft3           current number of PME grid points along c\PYGZhy{}axis
nefft1          number of grid points along electrostatic a\PYGZhy{}axis
nefft2          number of grid points along electrostatic b\PYGZhy{}axis
nefft3          number of grid points along electrostatic c\PYGZhy{}axis
ndfft1          number of grid points along dispersion a\PYGZhy{}axis
ndfft2          number of grid points along dispersion b\PYGZhy{}axis
ndfft3          number of grid points along dispersion c\PYGZhy{}axis
bsorder         current order of the PME B\PYGZhy{}spline values
bseorder        order of the electrostatic PME B\PYGZhy{}spline values
bsporder        order of the polarization PME B\PYGZhy{}spline values
bsdorder        order of the dispersion PME B\PYGZhy{}spline values
igrid           initial Ewald grid values for B\PYGZhy{}spline
bsmod1          B\PYGZhy{}spline moduli along the a\PYGZhy{}axis direction
bsmod2          B\PYGZhy{}spline moduli along the b\PYGZhy{}axis direction
bsmod3          B\PYGZhy{}spline moduli along the c\PYGZhy{}axis direction
bsbuild         B\PYGZhy{}spline derivative coefficient temporary storage
thetai1         B\PYGZhy{}spline coefficients along the a\PYGZhy{}axis
thetai2         B\PYGZhy{}spline coefficients along the b\PYGZhy{}axis
thetai3         B\PYGZhy{}spline coefficients along the c\PYGZhy{}axis
qgrid           values on the particle mesh Ewald grid
qfac            prefactors for the particle mesh Ewald grid
\end{sphinxVerbatim}

\sphinxstylestrong{POLAR Module        induced dipole moments \& polarizability}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
npolar          total number of polarizable sites in the system
ipolar          number of the multipole for each polarizable site
polarity        dipole polarizability for each multipole site (Ang**3)
thole           Thole polarizability damping value for each site
dirdamp         direct polarization damping value for each site
pdamp           value of polarizability scale factor for each site
udir            direct induced dipole components at each multipole site
udirp           direct induced dipoles in field used for energy terms
udirs           direct GK or PB induced dipoles at each multipole site
udirps          direct induced dipoles in field used for GK or PB energy
uind            mutual induced dipole components at each multipole site
uinp            mutual induced dipoles in field used for energy terms
uinds           mutual GK or PB induced dipoles at each multipole site
uinps           mutual induced dipoles in field used for GK or PB energy
uexact          exact SCF induced dipoles to full numerical precision
douind          flag to allow induced dipoles at each atomic site
\end{sphinxVerbatim}

\sphinxstylestrong{POLGRP Module        polarization group connectivity lists}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxp11          maximum number of atoms in a polarization group
maxp12          maximum number of atoms in groups 1\PYGZhy{}2 to an atom
maxp13          maximum number of atoms in groups 1\PYGZhy{}3 to an atom
maxp14          maximum number of atoms in groups 1\PYGZhy{}4 to an atom
np11            number of atoms in polarization group of each atom
np12            number of atoms in groups 1\PYGZhy{}2 to each atom
np13            number of atoms in groups 1\PYGZhy{}3 to each atom
np14            number of atoms in groups 1\PYGZhy{}4 to each atom
ip11            atom numbers of atoms in same group as each atom
ip12            atom numbers of atoms in groups 1\PYGZhy{}2 to each atom
ip13            atom numbers of atoms in groups 1\PYGZhy{}3 to each atom
ip14            atom numbers of atoms in groups 1\PYGZhy{}4 to each atom
\end{sphinxVerbatim}

\sphinxstylestrong{POLOPT Module        induced dipoles for OPT extrapolation}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxopt          maximum order for OPT induced dipole extrapolation
optorder        highest coefficient order for OPT dipole extrapolation
optlevel        current OPT order for reciprocal potential and field
copt            coefficients for OPT total induced dipole moments
copm            coefficients for OPT incremental induced dipole moments
uopt            OPT induced dipole components at each multipole site
uoptp           OPT induced dipoles in field used for energy terms
uopts           OPT GK or PB induced dipoles at each multipole site
uoptps          OPT induced dipoles in field used for GK or PB energy
fopt            OPT fractional reciprocal potentials at multipole sites
foptp           OPT fractional reciprocal potentials for energy terms
\end{sphinxVerbatim}

\sphinxstylestrong{POLPCG Module        induced dipoles via the PCG solver}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mindex          index into preconditioner inverse for PCG solver
pcgpeek         value of acceleration factor for PCG peek step
minv            preconditioner inverse for induced dipole PCG solver
pcgprec         flag to allow use of preconditioner with PCG solver
pcgguess        flag to use initial PCG based on direct field
\end{sphinxVerbatim}

\sphinxstylestrong{POLPOT Module        polarization functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
politer         maximum number of induced dipole SCF iterations
poleps          induced dipole convergence criterion (rms Debye/atom)
p2scale         scale factor for 1\PYGZhy{}2 polarization energy interactions
p3scale         scale factor for 1\PYGZhy{}3 polarization energy interactions
p4scale         scale factor for 1\PYGZhy{}4 polarization energy interactions
p5scale         scale factor for 1\PYGZhy{}5 polarization energy interactions
p2iscale        scale factor for 1\PYGZhy{}2 intragroup polarization energy
p3iscale        scale factor for 1\PYGZhy{}3 intragroup polarization energy
p4iscale        scale factor for 1\PYGZhy{}4 intragroup polarization energy
p5iscale        scale factor for 1\PYGZhy{}5 intragroup polarization energy
d1scale         scale factor for intra\PYGZhy{}group direct induction
d2scale         scale factor for 1\PYGZhy{}2 group direct induction
d3scale         scale factor for 1\PYGZhy{}3 group direct induction
d4scale         scale factor for 1\PYGZhy{}4 group direct induction
u1scale         scale factor for intra\PYGZhy{}group mutual induction
u2scale         scale factor for 1\PYGZhy{}2 group mutual induction
u3scale         scale factor for 1\PYGZhy{}3 group mutual induction
u4scale         scale factor for 1\PYGZhy{}4 group mutual induction
w2scale         scale factor for 1\PYGZhy{}2 induced dipole interactions
w3scale         scale factor for 1\PYGZhy{}3 induced dipole interactions
w4scale         scale factor for 1\PYGZhy{}4 induced dipole interactions
w5scale         scale factor for 1\PYGZhy{}5 induced dipole interactions
udiag           acceleration factor for induced dipole SCF iterations
dpequal         flag to set dscale values equal to pscale values
use\PYGZus{}thole       flag to use Thole damped polarization interactions
use\PYGZus{}dirdamp     flag to use damped direct polarization interactions
poltyp          type of polarization (MUTUAL, DIRECT, OPT or TCG)
\end{sphinxVerbatim}

\sphinxstylestrong{POLTCG Module        induced dipoles via the TCG solver}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tcgorder        total number of TCG iterations to be used
tcgnab          number of mutual induced dipole components
tcgpeek         value of acceleration factor for TCG peek step
uad             left\PYGZhy{}hand side mutual induced d\PYGZhy{}dipoles
uap             left\PYGZhy{}hand side mutual induced p\PYGZhy{}dipoles
ubd             right\PYGZhy{}hand side mutual induced d\PYGZhy{}dipoles
ubp             right\PYGZhy{}hand side mutual induced p\PYGZhy{}dipoles
tcgguess        flag to use initial TCG based on direct field
\end{sphinxVerbatim}

\sphinxstylestrong{POTENT Module        usage of potential energy components}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
use\PYGZus{}bond        logical flag governing use of bond stretch potential
use\PYGZus{}angle       logical flag governing use of angle bend potential
use\PYGZus{}strbnd      logical flag governing use of stretch\PYGZhy{}bend potential
use\PYGZus{}urey        logical flag governing use of Urey\PYGZhy{}Bradley potential
use\PYGZus{}angang      logical flag governing use of angle\PYGZhy{}angle cross term
use\PYGZus{}opbend      logical flag governing use of out\PYGZhy{}of\PYGZhy{}plane bend term
use\PYGZus{}opdist      logical flag governing use of out\PYGZhy{}of\PYGZhy{}plane distance
use\PYGZus{}improp      logical flag governing use of improper dihedral term
use\PYGZus{}imptor      logical flag governing use of improper torsion term
use\PYGZus{}tors        logical flag governing use of torsional potential
use\PYGZus{}pitors      logical flag governing use of pi\PYGZhy{}system torsion term
use\PYGZus{}strtor      logical flag governing use of stretch\PYGZhy{}torsion term
use\PYGZus{}angtor      logical flag governing use of angle\PYGZhy{}torsion term
use\PYGZus{}tortor      logical flag governing use of torsion\PYGZhy{}torsion term
use\PYGZus{}vdw         logical flag governing use of vdw der Waals potential
use\PYGZus{}repuls      logical flag governing use of Pauli repulsion term
use\PYGZus{}disp        logical flag governing use of dispersion potential
use\PYGZus{}charge      logical flag governing use of charge\PYGZhy{}charge potential
use\PYGZus{}chgdpl      logical flag governing use of charge\PYGZhy{}dipole potential
use\PYGZus{}dipole      logical flag governing use of dipole\PYGZhy{}dipole potential
use\PYGZus{}mpole       logical flag governing use of multipole potential
use\PYGZus{}polar       logical flag governing use of polarization term
use\PYGZus{}chgtrn      logical flag governing use of charge transfer term
use\PYGZus{}chgflx      logical flag governing use of charge flux term
use\PYGZus{}rxnfld      logical flag governing use of reaction field term
use\PYGZus{}solv        logical flag governing use of continuum solvation term
use\PYGZus{}metal       logical flag governing use of ligand field term
use\PYGZus{}geom        logical flag governing use of geometric restraints
use\PYGZus{}extra       logical flag governing use of extra potential term
use\PYGZus{}born        logical flag governing use of Born radii values
use\PYGZus{}orbit       logical flag governing use of pisystem computation
\end{sphinxVerbatim}

\sphinxstylestrong{POTFIT Module        values for electrostatic potential fit}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nconf           total number of configurations to be analyzed
namax           maximum number of atoms in the largest configuration
ngatm           total number of atoms with active potential grid points
nfatm           total number of atoms in electrostatic potential fit
npgrid          total number of electrostatic potential grid points
ipgrid          atom associated with each potential grid point
resp            weight used to restrain parameters to original values
xdpl0           target x\PYGZhy{}component of the molecular dipole moment
ydpl0           target y\PYGZhy{}component of the molecular dipole moment
zdpl0           target z\PYGZhy{}component of the molecular dipole moment
xxqdp0          target xx\PYGZhy{}component of the molecular quadrupole moment
xyqdp0          target xy\PYGZhy{}component of the molecular quadrupole moment
xzqdp0          target xz\PYGZhy{}component of the molecular quadrupole moment
yyqdp0          target yy\PYGZhy{}component of the molecular quadrupole moment
yzqdp0          target yz\PYGZhy{}component of the molecular quadrupole moment
zzqdp0          target zz\PYGZhy{}component of the molecular quadrupole moment
fit0            initial value of each parameter used in potential fit
fchg            partial charges by atom type during potential fit
fpol            atomic multipoles by atom type during potential fit
pgrid           Cartesian coordinates of potential grid points
epot            values of electrostatic potential at grid points
use\PYGZus{}dpl         flag to include molecular dipole in potential fit
use\PYGZus{}qdp         flag to include molecular quadrupole in potential fit
fit\PYGZus{}mpl         flag for atomic monopoles to vary in potential fit
fit\PYGZus{}dpl         flag for atomic dipoles to vary in potential fit
fit\PYGZus{}qdp         flag for atomic quadrupoles to vary in potential fit
fitchg          flag marking atom types for use in partial charge fit
fitpol          flag marking atom types for use in atomic multipole fit
gatm            flag to use potential grid points around each atom
fatm            flag to use each atom in electrostatic potential fit
\end{sphinxVerbatim}

\sphinxstylestrong{PTABLE Module        symbols and info for chemical elements}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxele          maximum number of elements from periodic table
atmass          standard atomic weight for each chemical element
vdwrad          van der Waals radius for each chemical element
covrad          covalent radius for each chemical element
elemnt          atomic symbol for each chemical element
\end{sphinxVerbatim}

\sphinxstylestrong{REFER Module        reference atomic coordinate storage}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nref            total number of atoms in each reference system
refltitle       length in characters of each reference title line
refleng         length in characters of each reference filename
reftyp          atom types of the atoms in each reference system
n12ref          number of atoms bonded to each reference atom
i12ref          atom numbers of atoms 1\PYGZhy{}2 connected to each atom
xboxref         reference a\PYGZhy{}axis length of periodic box
yboxref         reference b\PYGZhy{}axis length of periodic box
zboxref         reference c\PYGZhy{}axis length of periodic box
alpharef        reference angle between b\PYGZhy{} and c\PYGZhy{}axes of box
betaref         reference angle between a\PYGZhy{} and c\PYGZhy{}axes of box
gammaref        reference angle between a\PYGZhy{} and b\PYGZhy{}axes of box
xref            reference x\PYGZhy{}coordinates for atoms in each system
yref            reference y\PYGZhy{}coordinates for atoms in each system
zref            reference z\PYGZhy{}coordinates for atoms in each system
refnam          atom names of the atoms in each reference system
reffile         base filename for each reference system
reftitle        title used to describe each reference system
\end{sphinxVerbatim}

\sphinxstylestrong{REPEL Module        Pauli repulsion for current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nrep            total number of repulsion sites in the system
sizpr           Pauli repulsion size parameter value at each site
dmppr           Pauli repulsion alpha damping value at each site
elepr           Pauli repulsion valence electrons at each site
\end{sphinxVerbatim}

\sphinxstylestrong{REPPOT Module        repulsion interaction scale factors}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
r2scale         scale factor for 1\PYGZhy{}2 repulsion energy interactions
r3scale         scale factor for 1\PYGZhy{}3 repulsion energy interactions
r4scale         scale factor for 1\PYGZhy{}4 repulsion energy interactions
r5scale         scale factor for 1\PYGZhy{}5 repulsion energy interactions
\end{sphinxVerbatim}

\sphinxstylestrong{RESDUE Module        amino acid \& nucleotide residue names}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxamino        maximum number of amino acid residue types
maxnuc          maximum number of nucleic acid residue types
ntyp            biotypes for mid\PYGZhy{}chain peptide backbone N atoms
catyp           biotypes for mid\PYGZhy{}chain peptide backbone CA atoms
ctyp            biotypes for mid\PYGZhy{}chain peptide backbone C atoms
hntyp           biotypes for mid\PYGZhy{}chain peptide backbone HN atoms
otyp            biotypes for mid\PYGZhy{}chain peptide backbone O atoms
hatyp           biotypes for mid\PYGZhy{}chain peptide backbone HA atoms
cbtyp           biotypes for mid\PYGZhy{}chain peptide backbone CB atoms
nntyp           biotypes for N\PYGZhy{}terminal peptide backbone N atoms
cantyp          biotypes for N\PYGZhy{}terminal peptide backbone CA atoms
cntyp           biotypes for N\PYGZhy{}terminal peptide backbone C atoms
hnntyp          biotypes for N\PYGZhy{}terminal peptide backbone HN atoms
ontyp           biotypes for N\PYGZhy{}terminal peptide backbone O atoms
hantyp          biotypes for N\PYGZhy{}terminal peptide backbone HA atoms
nctyp           biotypes for C\PYGZhy{}terminal peptide backbone N atoms
cactyp          biotypes for C\PYGZhy{}terminal peptide backbone CA atoms
cctyp           biotypes for C\PYGZhy{}terminal peptide backbone C atoms
hnctyp          biotypes for C\PYGZhy{}terminal peptide backbone HN atoms
octyp           biotypes for C\PYGZhy{}terminal peptide backbone O atoms
hactyp          biotypes for C\PYGZhy{}terminal peptide backbone HA atoms
o5typ           biotypes for nucleotide backbone and sugar O5\PYGZsq{} atoms
c5typ           biotypes for nucleotide backbone and sugar C5\PYGZsq{} atoms
h51typ          biotypes for nucleotide backbone and sugar H5\PYGZsq{} atoms
h52typ          biotypes for nucleotide backbone and sugar H5\PYGZsq{}\PYGZsq{} atoms
c4typ           biotypes for nucleotide backbone and sugar C4\PYGZsq{} atoms
h4typ           biotypes for nucleotide backbone and sugar H4\PYGZsq{} atoms
o4typ           biotypes for nucleotide backbone and sugar O4\PYGZsq{} atoms
c1typ           biotypes for nucleotide backbone and sugar C1\PYGZsq{} atoms
h1typ           biotypes for nucleotide backbone and sugar H1\PYGZsq{} atoms
c3typ           biotypes for nucleotide backbone and sugar C3\PYGZsq{} atoms
h3typ           biotypes for nucleotide backbone and sugar H3\PYGZsq{} atoms
c2typ           biotypes for nucleotide backbone and sugar C2\PYGZsq{} atoms
h21typ          biotypes for nucleotide backbone and sugar H2\PYGZsq{} atoms
o2typ           biotypes for nucleotide backbone and sugar O2\PYGZsq{} atoms
h22typ          biotypes for nucleotide backbone and sugar H2\PYGZsq{}\PYGZsq{} atoms
o3typ           biotypes for nucleotide backbone and sugar O3\PYGZsq{} atoms
ptyp            biotypes for nucleotide backbone and sugar P atoms
optyp           biotypes for nucleotide backbone and sugar OP atoms
h5ttyp          biotypes for nucleotide backbone and sugar H5T atoms
h3ttyp          biotypes for nucleotide backbone and sugar H3T atoms
amino           three\PYGZhy{}letter abbreviations for amino acids types
nuclz           three\PYGZhy{}letter abbreviations for nucleic acids types
amino1          one\PYGZhy{}letter abbreviations for amino acids types
nuclz1          one\PYGZhy{}letter abbreviations for nucleic acids types
\end{sphinxVerbatim}

\sphinxstylestrong{RESTRN Module        parameters for geometrical restraints}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
npfix           number of position restraints to be applied
ndfix           number of distance restraints to be applied
nafix           number of angle restraints to be applied
ntfix           number of torsional restraints to be applied
ngfix           number of group distance restraints to be applied
nchir           number of chirality restraints to be applied
ipfix           atom number involved in each position restraint
kpfix           flags to use x\PYGZhy{}, y\PYGZhy{}, z\PYGZhy{}coordinate position restraints
idfix           atom numbers defining each distance restraint
iafix           atom numbers defining each angle restraint
itfix           atom numbers defining each torsional restraint
igfix           group numbers defining each group distance restraint
ichir           atom numbers defining each chirality restraint
depth           depth of shallow Gaussian basin restraint
width           exponential width coefficient of Gaussian basin
rwall           radius of spherical droplet boundary restraint
xpfix           x\PYGZhy{}coordinate target for each restrained position
ypfix           y\PYGZhy{}coordinate target for each restrained position
zpfix           z\PYGZhy{}coordinate target for each restrained position
pfix            force constant and flat\PYGZhy{}well range for each position
dfix            force constant and target range for each distance
afix            force constant and target range for each angle
tfix            force constant and target range for each torsion
gfix            force constant and target range for each group distance
chir            force constant and target range for chiral centers
use\PYGZus{}basin       logical flag governing use of Gaussian basin
use\PYGZus{}wall        logical flag governing use of droplet boundary
\end{sphinxVerbatim}

\sphinxstylestrong{RGDDYN Module        rigid body MD velocities and momenta}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
xcmo            x\PYGZhy{}component from each atom to center of rigid body
ycmo            y\PYGZhy{}component from each atom to center of rigid body
zcmo            z\PYGZhy{}component from each atom to center of rigid body
vcm             current translational velocity of each rigid body
wcm             current angular velocity of each rigid body
lm              current angular momentum of each rigid body
vc              half\PYGZhy{}step translational velocity for kinetic energy
wc              half\PYGZhy{}step angular velocity for kinetic energy
linear          logical flag to mark group as linear or nonlinear
\end{sphinxVerbatim}

\sphinxstylestrong{RIGID Module        rigid body coordinates for atom groups}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
xrb             rigid body reference x\PYGZhy{}coordinate for each atom
yrb             rigid body reference y\PYGZhy{}coordinate for each atom
zrb             rigid body reference z\PYGZhy{}coordinate for each atom
rbc             current rigid body coordinates for each group
use\PYGZus{}rigid       flag to mark use of rigid body coordinate system
\end{sphinxVerbatim}

\sphinxstylestrong{RING Module        number and location of ring structures}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nring3          total number of 3\PYGZhy{}membered rings in the system
nring4          total number of 4\PYGZhy{}membered rings in the system
nring5          total number of 5\PYGZhy{}membered rings in the system
nring6          total number of 6\PYGZhy{}membered rings in the system
nring7          total number of 7\PYGZhy{}membered rings in the system
iring3          numbers of the atoms involved in each 3\PYGZhy{}ring
iring4          numbers of the atoms involved in each 4\PYGZhy{}ring
iring5          numbers of the atoms involved in each 5\PYGZhy{}ring
iring6          numbers of the atoms involved in each 6\PYGZhy{}ring
iring7          numbers of the atoms involved in each 7\PYGZhy{}ring
\end{sphinxVerbatim}

\sphinxstylestrong{ROTBND Module        molecule partitions for bond rotation}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nrot            total number of atoms moving when bond rotates
rot             atom numbers of atoms moving when bond rotates
use\PYGZus{}short       logical flag governing use of shortest atom list
\end{sphinxVerbatim}

\sphinxstylestrong{RXNFLD Module        reaction field matrix and indices}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ijk             indices into the reaction field element arrays
b1              first reaction field matrix element array
b2              second reaction field matrix element array
\end{sphinxVerbatim}

\sphinxstylestrong{RXNPOT Module        reaction field functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rfsize          radius of reaction field sphere centered at origin
rfbulkd         bulk dielectric constant of reaction field continuum
rfterms         number of terms to use in reaction field summation
\end{sphinxVerbatim}

\sphinxstylestrong{SCALES Module        optimization parameter scale factors}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
scale           multiplicative factor for each optimization parameter
set\PYGZus{}scale       logical flag to show if scale factors have been set
\end{sphinxVerbatim}

\sphinxstylestrong{SEQUEN Module        sequence information for biopolymer}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nseq            total number of residues in biopolymer sequences
nchain          number of separate biopolymer sequence chains
ichain          first and last residue in each biopolymer chain
seqtyp          residue type for each residue in the sequence
seq             three\PYGZhy{}letter code for each residue in the sequence
chnnam          one\PYGZhy{}letter identifier for each sequence chain
chntyp          contents of each chain (GENERIC, PEPTIDE or NUCLEIC)
\end{sphinxVerbatim}

\sphinxstylestrong{SHUNT Module        polynomial switching function values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
off             distance at which the potential energy goes to zero
off2            square of distance at which the potential goes to zero
cut             distance at which switching of the potential begins
cut2            square of distance at which the switching begins
c0              zeroth order coefficient of multiplicative switch
c1              first order coefficient of multiplicative switch
c2              second order coefficient of multiplicative switch
c3              third order coefficient of multiplicative switch
c4              fourth order coefficient of multiplicative switch
c5              fifth order coefficient of multiplicative switch
f0              zeroth order coefficient of additive switch function
f1              first order coefficient of additive switch function
f2              second order coefficient of additive switch function
f3              third order coefficient of additive switch function
f4              fourth order coefficient of additive switch function
f5              fifth order coefficient of additive switch function
f6              sixth order coefficient of additive switch function
f7              seventh order coefficient of additive switch function
\end{sphinxVerbatim}

\sphinxstylestrong{SIZES Module        parameters to set array dimensions}

“sizes” sets values for critical array dimensions used
throughout the software; these parameters fix the size of
the largest systems that can be handled

\begin{sphinxVerbatim}[commandchars=\\\{\}]
parameter       maximum allowed number of:
maxatm          atoms in the molecular system
maxtyp          force field atom type definitions
maxclass        force field atom class definitions
maxval          atoms directly bonded to an atom
maxref          stored reference molecular systems
maxgrp          user\PYGZhy{}defined groups of atoms
maxres          residues in the macromolecule
maxfix          geometric constraints and restraints
\end{sphinxVerbatim}

\sphinxstylestrong{SOCKET Module        socket communication control parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
skttyp          socket information type (1=DYN, 2=OPT)
cstep           current dynamics or optimization step number
cdt             current dynamics cumulative simulation time
cenergy         current potential energy from simulation
sktstart        logical flag to indicate socket initialization
sktstop         logical flag to indicate socket shutdown
use\PYGZus{}socket      logical flag governing use of external sockets
\end{sphinxVerbatim}

\sphinxstylestrong{SOLUTE Module        continuum solvation model parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
doffset         dielectric offset to continuum solvation atomic radii
p1              single\PYGZhy{}atom scale factor for analytical Still radii
p2              1\PYGZhy{}2 interaction scale factor for analytical Still radii
p3              1\PYGZhy{}3 interaction scale factor for analytical Still radii
p4              nonbonded scale factor for analytical Still radii
p5              soft cutoff parameter for analytical Still radii
rsolv           atomic radius of each atom for continuum solvation
asolv           atomic surface area solvation parameters
rborn           Born radius of each atom for GB/SA solvation
drb             solvation derivatives with respect to Born radii
drbp            GK polarization derivatives with respect to Born radii
drobc           chain rule term for Onufriev\PYGZhy{}Bashford\PYGZhy{}Case radii
gpol            polarization self\PYGZhy{}energy values for each atom
shct            overlap scale factors for Hawkins\PYGZhy{}Cramer\PYGZhy{}Truhlar radii
aobc            alpha values for Onufriev\PYGZhy{}Bashford\PYGZhy{}Case radii
bobc            beta values for Onufriev\PYGZhy{}Bashford\PYGZhy{}Case radii
gobc            gamma values for Onufriev\PYGZhy{}Bashford\PYGZhy{}Case radii
vsolv           atomic volume of each atom for use with ACE
wace            \PYGZdq{}omega\PYGZdq{} values for atom class pairs for use with ACE
s2ace           \PYGZdq{}sigma\PYGZca{}2\PYGZdq{} values for atom class pairs for use with ACE
uace            \PYGZdq{}mu\PYGZdq{} values for atom class pairs for use with ACE
solvtyp         type of continuum solvation energy model in use
borntyp         method to be used for the Born radius computation
\end{sphinxVerbatim}

\sphinxstylestrong{STODYN Module        SD trajectory frictional coefficients}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
friction        global frictional coefficient for exposed particle
fgamma          atomic frictional coefficients for each atom
use\PYGZus{}sdarea      logical flag to use surface area friction scaling
\end{sphinxVerbatim}

\sphinxstylestrong{STRBND Module        stretch\sphinxhyphen{}bends in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nstrbnd         total number of stretch\PYGZhy{}bend interactions
isb             angle and bond numbers used in stretch\PYGZhy{}bend
sbk             force constants for stretch\PYGZhy{}bend terms
\end{sphinxVerbatim}

\sphinxstylestrong{STRTOR Module        stretch\sphinxhyphen{}torsions in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nstrtor         total number of stretch\PYGZhy{}torsion interactions
ist             torsion and bond numbers used in stretch\PYGZhy{}torsion
kst             1\PYGZhy{}, 2\PYGZhy{} and 3\PYGZhy{}fold stretch\PYGZhy{}torsion force constants
\end{sphinxVerbatim}

\sphinxstylestrong{SYNTRN Module        synchronous transit path definition}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tpath           value of the path coordinate (0=reactant, 1=product)
ppath           path coordinate for extra point in quadratic transit
xmin1           reactant coordinates as array of optimization variables
xmin2           product coordinates as array of optimization variables
xm              extra coordinate set for quadratic synchronous transit
\end{sphinxVerbatim}

\sphinxstylestrong{TARRAY Module        store dipole\sphinxhyphen{}dipole matrix elements}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ntpair          number of stored dipole\PYGZhy{}dipole matrix elements
tindex          index into stored dipole\PYGZhy{}dipole matrix values
tdipdip         stored dipole\PYGZhy{}dipole matrix element values
\end{sphinxVerbatim}

\sphinxstylestrong{TITLES Module        title for current molecular system}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ltitle          length in characters of the nonblank title string
title           title used to describe the current structure
\end{sphinxVerbatim}

\sphinxstylestrong{TORPOT Module        torsional functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
idihunit        convert improper dihedral energy to kcal/mole
itorunit        convert improper torsion amplitudes to kcal/mole
torsunit        convert torsional parameter amplitudes to kcal/mole
ptorunit        convert pi\PYGZhy{}system torsion energy to kcal/mole
storunit        convert stretch\PYGZhy{}torsion energy to kcal/mole
atorunit        convert angle\PYGZhy{}torsion energy to kcal/mole
ttorunit        convert torsion\PYGZhy{}torsion energy to kcal/mole
\end{sphinxVerbatim}

\sphinxstylestrong{TORS Module        torsional angles in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ntors           total number of torsional angles in the system
itors           numbers of the atoms in each torsional angle
tors1           1\PYGZhy{}fold amplitude and phase for each torsional angle
tors2           2\PYGZhy{}fold amplitude and phase for each torsional angle
tors3           3\PYGZhy{}fold amplitude and phase for each torsional angle
tors4           4\PYGZhy{}fold amplitude and phase for each torsional angle
tors5           5\PYGZhy{}fold amplitude and phase for each torsional angle
tors6           6\PYGZhy{}fold amplitude and phase for each torsional angle
\end{sphinxVerbatim}

\sphinxstylestrong{TORTOR Module        torsion\sphinxhyphen{}torsions in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ntortor         total number of torsion\PYGZhy{}torsion interactions
itt             atoms and parameter indices for torsion\PYGZhy{}torsion
\end{sphinxVerbatim}

\sphinxstylestrong{TREE Module        potential smoothing search tree levels}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxpss          maximum number of potential smoothing levels
nlevel          number of levels of potential smoothing used
etree           energy reference value at the top of the tree
ilevel          smoothing deformation value at each tree level
\end{sphinxVerbatim}

\sphinxstylestrong{UNITS Module        physical constants and unit conversions}

D. B. Newell, F. Cabiati, J. Fischer, K. Fujii, S. G. Karshenboim,
S. Margolis, E. de Mirandes, P. J. Mohr, F. Nez, K. Pachucki,
T. J. Quinn, N. Taylor, M. Wang, B. M. Wood and Z. Zhang, “The
CODATA 2017 Values of h, e, k, and Na for the Revision of the SI”,
Metrologia, 55, L13\sphinxhyphen{}L16 (2018)

P. J. Mohr, D. B. Newell and B. N. Taylor, “CODATA Recommended
Values of the Fundamental Physical Constants: 2014”, Journal of
Physical and Chemical Reference Data, 45, 043102 (2016)

Where available, values are from the 2017 CODATA adjustment
based on exact physical constants for the revised SI

Other values are from the 2014 CODATA reference constants; also
available online from the National Institute of Standards and
Technology at \sphinxurl{http://physics.nist.gov/cuu/Constants/index.html/}

The conversion from calorie to Joule is the definition of the
thermochemical calorie as 1 cal = 4.1840 J from ISO 31\sphinxhyphen{}4 (1992)

The “coulomb” energy conversion factor is found by dimensional
analysis of Coulomb’s Law, ie, by dividing the square of the
elementary charge in Coulombs by 4*pi*eps0*rij, where eps0 is
the permittivity of vacuum (the “electric constant”); note that
eps0 is typically given in F/m, equivalent to C**2/(J\sphinxhyphen{}m)

The approximate value used for the Debye, 3.33564 x 10\sphinxhyphen{}30 C\sphinxhyphen{}m,
is from IUPAC Compendium of Chemical Technology, 2nd Ed. (1997)

The value of “prescon” is based on definition of 1 atmosphere
as 101325 Pa set by the 10th Conference Generale des Poids et
Mesures (1954), where a Pascal (Pa) is equal to a J/m**3

\begin{sphinxVerbatim}[commandchars=\\\{\}]
avogadro        Avogadro\PYGZsq{}s number (N) in particles/mole
lightspd        speed of light in vacuum (c) in cm/ps
boltzmann       Boltzmann constant (kB) in g*Ang**2/ps**2/mole/K
gasconst        ideal gas constant (R) in kcal/mole/K
elemchg         elementary charge of a proton in Coulombs
vacperm         vacuum permittivity (electric constant, eps0) in F/m
emass           mass of an electron in atomic mass units
planck          Planck\PYGZsq{}s constant (h) in J\PYGZhy{}s
joule           conversion from calorie to joule
ekcal           conversion from kcal to g*Ang**2/ps**2
bohr            conversion from Bohr to Angstrom
hartree         conversion from Hartree to kcal/mole
evolt           conversion from Hartree to electron\PYGZhy{}volt
efreq           conversion from Hartree to cm\PYGZhy{}1
coulomb         conversion from electron**2/Ang to kcal/mole
debye           conversion from electron\PYGZhy{}Ang to Debye
prescon         conversion from kcal/mole/Ang**3 to Atm
\end{sphinxVerbatim}

\sphinxstylestrong{UPRIOR Module        previous values of induced dipoles}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxpred         maximum number of predictor induced dipoles to save
nualt           number of sets of prior induced dipoles in storage
maxualt         number of sets of induced dipoles needed for predictor
gear            coefficients for Gear predictor binomial method
aspc            coefficients for always stable predictor\PYGZhy{}corrector
bpred           coefficients for induced dipole predictor polynomial
bpredp          coefficients for predictor polynomial in energy field
bpreds          coefficients for predictor for PB/GK solvation
bpredps         coefficients for predictor in PB/GK energy field
udalt           prior values for induced dipoles at each site
upalt           prior values for induced dipoles in energy field
usalt           prior values for induced dipoles for PB/GK solvation
upsalt          prior values for induced dipoles in PB/GK energy field
use\PYGZus{}pred        flag to control use of induced dipole prediction
polpred         type of predictor polynomial (GEAR, ASPC or LSQR)
\end{sphinxVerbatim}

\sphinxstylestrong{UREY Module        Urey\sphinxhyphen{}Bradley interactions in structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nurey           total number of Urey\PYGZhy{}Bradley terms in the system
iury            numbers of the atoms in each Urey\PYGZhy{}Bradley interaction
uk              Urey\PYGZhy{}Bradley force constants (kcal/mole/Ang**2)
ul              ideal 1\PYGZhy{}3 distance values in Angstroms
\end{sphinxVerbatim}

\sphinxstylestrong{URYPOT Module        Urey\sphinxhyphen{}Bradley functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
cury            cubic coefficient in Urey\PYGZhy{}Bradley potential
qury            quartic coefficient in Urey\PYGZhy{}Bradley potential
ureyunit        convert Urey\PYGZhy{}Bradley energy to kcal/mole
\end{sphinxVerbatim}

\sphinxstylestrong{USAGE Module        atoms active during energy computation}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nuse            total number of active atoms in energy calculation
iuse            numbers of the atoms active in energy calculation
use             true if an atom is active, false if inactive
\end{sphinxVerbatim}

\sphinxstylestrong{VALFIT Module        valence term parameter fitting values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
fit\PYGZus{}bond        logical flag to fit bond stretch parameters
fit\PYGZus{}angle       logical flag to fit angle bend parameters
fit\PYGZus{}strbnd      logical flag to fit stretch\PYGZhy{}bend parameters
fit\PYGZus{}urey        logical flag to fit Urey\PYGZhy{}Bradley parameters
fit\PYGZus{}opbend      logical flag to fit out\PYGZhy{}of\PYGZhy{}plane bend parameters
fit\PYGZus{}tors        logical flag to fit torsional parameters
fit\PYGZus{}struct      logical flag to structure\PYGZhy{}fit valence parameters
fit\PYGZus{}force       logical flag to force\PYGZhy{}fit valence parameters
\end{sphinxVerbatim}

\sphinxstylestrong{VDW Module        van der Waals terms in current structure}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nvdw            total number van der Waals active sites in the system
ivdw            number of the atom for each van der Waals active site
jvdw            type or class index into vdw parameters for each atom
ired            attached atom from which reduction factor is applied
kred            value of reduction factor parameter for each atom
xred            reduced x\PYGZhy{}coordinate for each atom in the system
yred            reduced y\PYGZhy{}coordinate for each atom in the system
zred            reduced z\PYGZhy{}coordinate for each atom in the system
radmin          minimum energy distance for each atom class pair
epsilon         well depth parameter for each atom class pair
radmin4         minimum energy distance for 1\PYGZhy{}4 interaction pairs
epsilon4        well depth parameter for 1\PYGZhy{}4 interaction pairs
radhbnd         minimum energy distance for hydrogen bonding pairs
epshbnd         well depth parameter for hydrogen bonding pairs
\end{sphinxVerbatim}

\sphinxstylestrong{VDWPOT Module        van der Waals functional form details}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
igauss          coefficients of Gaussian fit to vdw potential
ngauss          number of Gaussians used in fit to vdw potential
abuck           value of \PYGZdq{}A\PYGZdq{} constant in Buckingham vdw potential
bbuck           value of \PYGZdq{}B\PYGZdq{} constant in Buckingham vdw potential
cbuck           value of \PYGZdq{}C\PYGZdq{} constant in Buckingham vdw potential
ghal            value of \PYGZdq{}gamma\PYGZdq{} in buffered 14\PYGZhy{}7 vdw potential
dhal            value of \PYGZdq{}delta\PYGZdq{} in buffered 14\PYGZhy{}7 vdw potential
v2scale         factor by which 1\PYGZhy{}2 vdw interactions are scaled
v3scale         factor by which 1\PYGZhy{}3 vdw interactions are scaled
v4scale         factor by which 1\PYGZhy{}4 vdw interactions are scaled
v5scale         factor by which 1\PYGZhy{}5 vdw interactions are scaled
use\PYGZus{}vcorr       flag to use long range van der Waals correction
vdwindex        indexing mode (atom type or class) for vdw parameters
vdwtyp          type of van der Waals potential energy function
radtyp          type of parameter (sigma or R\PYGZhy{}min) for atomic size
radsiz          atomic size provided as radius or diameter
radrule         combining rule for atomic size parameters
epsrule         combining rule for vdw well depth parameters
gausstyp        type of Gaussian fit to van der Waals potential
\end{sphinxVerbatim}

\sphinxstylestrong{VIBS Module        iterative vibrational analysis components}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
rho             trial vectors for iterative vibrational analysis
rhok            alternate vectors for iterative vibrational analysis
rwork           temporary work array for eigenvector transformation
\end{sphinxVerbatim}

\sphinxstylestrong{VIRIAL Module        components of internal virial tensor}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
vir             total internal virial Cartesian tensor components
use\PYGZus{}virial      logical flag governing use of virial computation
\end{sphinxVerbatim}

\sphinxstylestrong{WARP Module        potential surface smoothing parameters}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
deform          value of the smoothing deformation parameter
difft           diffusion coefficient for torsional potential
diffv           diffusion coefficient for van der Waals potential
diffc           diffusion coefficient for charge\PYGZhy{}charge potential
m2              second moment of the GDA gaussian for each atom
use\PYGZus{}smooth      flag to use a potential energy smoothing method
use\PYGZus{}dem         flag to use diffusion equation method potential
use\PYGZus{}gda         flag to use gaussian density annealing potential
use\PYGZus{}tophat      flag to use analytical tophat smoothed potential
use\PYGZus{}stophat     flag to use shifted tophat smoothed potential
\end{sphinxVerbatim}

\sphinxstylestrong{XTALS Module        structures used for parameter fitting}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
maxlsq          maximum number of least squares variables
maxrsd          maximum number of residual functions
nxtal           number of molecular structures to be stored
nvary           number of potential parameters to optimize
ivary           index for the types of potential parameters
iresid          structure to which each residual function refers
vary            atom numbers involved in potential parameters
e0\PYGZus{}lattice      ideal lattice energy for the current crystal
vartyp          type of each potential parameter to be optimized
rsdtyp          experimental variable for each of the residuals
\end{sphinxVerbatim}

\sphinxstylestrong{ZCLOSE Module        Z\sphinxhyphen{}matrix ring openings and closures}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nadd            number of added bonds between Z\PYGZhy{}matrix atoms
ndel            number of bonds between Z\PYGZhy{}matrix bonds to delete
iadd            numbers of the atom pairs defining added bonds
idel            numbers of the atom pairs defining deleted bonds
\end{sphinxVerbatim}

\sphinxstylestrong{ZCOORD Module        Z\sphinxhyphen{}matrix internal coordinate values}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
iz              defining atom numbers for each Z\PYGZhy{}matrix atom
zbond           bond length used to define each Z\PYGZhy{}matrix atom
zang            bond angle used to define each Z\PYGZhy{}matrix atom
ztors           angle or torsion used to define Z\PYGZhy{}matrix atom
\end{sphinxVerbatim}


\chapter{Test Cases \& Examples}
\label{\detokenize{text/test-cases:test-cases-examples}}\label{\detokenize{text/test-cases::doc}}
This section contains brief descriptions of the sample calculations found in the EXAMPLE subdirectory of the Tinker distribution. These examples exercise several of the current Tinker programs and are intended to provide a flavor of the capabilities of the package.

\sphinxstylestrong{ANION Test}

Computes an estimation of the free energy of hydration of Cl\sphinxhyphen{} anion vs. Br\sphinxhyphen{} anion via a 2 picosecond simulation on a “hybrid” anion in a box of water followed by a free energy perturbation calculation.

\sphinxstylestrong{ARGON Test}

Performs an initial energy minimization on a periodic box containing 150 argon atoms followed by 6 picoseconds of a molecular dynamics using a modified Beeman integration algorithm and a Bersedsen thermostat.

\sphinxstylestrong{CLUSTER Test}

Performs a set of 10 Gaussian density annealing (GDA) trials on a cluster of 13 argon atoms in an attempt to locate the global minimum energy structure.

\sphinxstylestrong{CRAMBIN Test}

Generates a Tinker file from a PDB file, followed by a single point energy computation and determination of the molecular volume and surface area.

\sphinxstylestrong{CYCLOHEX Test}

First approximately locates the transition state between chair and boat cyclohexane, followed by subsequent refinement of the transition state and a final vibrational analysis to show that a single negative frequency is associated with the saddle point.

\sphinxstylestrong{DHFR Test}

Performs 10 steps of molecular dynamics on a pre\sphinxhyphen{}equilibrated system of DHFR protein in a box or water using the AMOEBA force field. Note this test case is the so\sphinxhyphen{}called Joint Amber\sphinxhyphen{}CHARMM “JAC” benchmark containing 23558 total atoms.

\sphinxstylestrong{DIALANINE Test}

Finds all the local minima of alanine dipeptide via a potential energy surface scan using torsional modes to jump between the minima.

\sphinxstylestrong{ENKEPHALIN Test}

Produces coordinates from the met\sphinxhyphen{}enkephalin amino acid sequence and phi/psi angles, followed by truncated Newton energy minimization and determination of the lowest frequency normal mode.

\sphinxstylestrong{ETHANOL Test}

Performs fitting of torsional parameter values for the ethanol C\sphinxhyphen{}C\sphinxhyphen{}O\sphinxhyphen{}H bond based on relative quantum mechanical (G09) energies for rotating the C\sphinxhyphen{}O bond.

\sphinxstylestrong{FORMAMIDE Test}

Generates a unit cell from fractional coordinates, followed by full crystal energy minimization and determination of optimal carbonyl oxygen energy parameters from a fit to lattice energy and structure.

\sphinxstylestrong{GPCR Test}

Finds the lowest\sphinxhyphen{}frequency normal mode of bacteriorhodopsin using vibrational analysis via a sliding block iterative matrix diagonalization. Alter the gpcr.run script to save the file gpcr.001 for later viewing of the mode.

\sphinxstylestrong{HELIX Test}

Performs a rigid\sphinxhyphen{}body optimization of the packing of two idealized polyalanine helices using only van der Waals interactions.

\sphinxstylestrong{ICE Test}

Performs a short MD simulation of the monoclinic ice V crystal form using the iAMOEBA water model, pairwise neighbor lists and PME electrostatics.

\sphinxstylestrong{IFABP Test}

Generates three distance geometry structures for intestinal fatty acid binding protein from a set of NOE distance restraints and torsional restraints.

\sphinxstylestrong{METHANOL Test}

Processes distributed multipole analysis (DMA) output to extract coordinates and permanent multipoles, set local frames and polarization groups, remove intramolecular polarization, detect and average equivalent atomic sites.

\sphinxstylestrong{NITROGEN Test}

Calculates the self\sphinxhyphen{}diffusion constant and the N\sphinxhyphen{}N radial distribution function for liquid nitrogen via analysis of a 50ps MD trajectory.

\sphinxstylestrong{SALT Test}

Converts a sodium chloride assymetric unit to the corresponding unit cell, then runs a crystal minimization starting from the initial diffraction structure using Ewald summation to model the long\sphinxhyphen{}range electrostatic interactions.

\sphinxstylestrong{TETRAALA Test}

Generates capped alanine tetrapeptide in an extended conformation, then use Monte Carlo Minimization with random torsional moves to find the global minimum energy structure.

\sphinxstylestrong{WATER Test}

Fits the electrostatic potential around an AMOEBA water molecule to the QM\sphinxhyphen{}derived potential (MP2/aug\sphinxhyphen{}cc\sphinxhyphen{}pVTZ) on a grid of points outside the molecular surface.


\chapter{Benchmark Results}
\label{\detokenize{text/benchmarks:benchmark-results}}\label{\detokenize{text/benchmarks::doc}}
The tables in this section provide CPU benchmarks for basic Tinker energy and derivative evaluations, vibrational analysis and molecular dynamics simulation. All times are in seconds and were measured with Tinker executables dimensioned to a maximum of 1000000 atoms. Each benchmark was run on an unloaded machine and is the fastest time reported for that particular machine. The first five benchmarks are run serial on a single thread, while the last four benchmarks reflect OpenMP parallel performance. If you have built Tinker on an alternative machine type and are able to run the benchmarks on the additional machine type, please send the results for inclusion in a future listing.


\section{Calmodulin Energy Evaluation (Serial)}
\label{\detokenize{text/benchmarks:calmodulin-energy-evaluation-serial}}
Gas\sphinxhyphen{}Phase Calmodulin Molecule, 2264 Atoms, Amber ff94 Force Field, No Nonbonded Cutoffs, 100 Evaluations

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU        Energy       Gradient       Hessian}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150        26.2         50.9       149.9
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462        17.6         34.7       106.8
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650        12.2         32.9        95.4
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670         7.2         16.6        50.4
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ         7.3         16.7        51.5
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H         5.4         10.4        33.2
\end{sphinxVerbatim}


\section{Crambin Crystal Energy Evaluation (Serial)}
\label{\detokenize{text/benchmarks:crambin-crystal-energy-evaluation-serial}}
Crambin Unit Cell, 1360 Atoms in Periodic Unit Cell, OPLS\sphinxhyphen{}UA Force Field with PME Electrostatics, 9.0 Ang vdw Cutoff, 1000 Evaluations

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU        Energy       Gradient       Hessian}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150        36.6         54.1       220.5
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462        34.6         47.8       190.8
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650        31.3         43.8       161.0
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670        19.1         26.0        85.0
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ        18.8         26.6        87.8
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H        15.6         19.9        67.9
\end{sphinxVerbatim}


\section{Crambin Normal Mode Calculation (Serial)}
\label{\detokenize{text/benchmarks:crambin-normal-mode-calculation-serial}}
Hessian Eigenvalues, Normal Modes and Vibrational Freqencies for the 42\sphinxhyphen{}Amino Acid, 642\sphinxhyphen{}Atom Protein Crambin, CHARMM\sphinxhyphen{}22 Force Field with Cutoffs

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU                   Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150                41.1
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462                40.5
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650                23.5
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670                15.9
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ                15.3
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H                11.0
\end{sphinxVerbatim}


\section{Water Box Molecular Dynamics using TIP3P (Serial)}
\label{\detokenize{text/benchmarks:water-box-molecular-dynamics-using-tip3p-serial}}
MD run of 10000 Steps for 216 TIP3P Waters in 18.643 Ang Periodic Box, 9.0 Ang Shifted \& Switched Cutoffs, Rattle for Rigid TIP3P, 1.0 fs Time Step with Modified Beeman Integrator

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU                   Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150               214.0
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462               152.1
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650               158.1
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670                80.4
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ                82.1
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H                55.1
\end{sphinxVerbatim}


\section{Water Box Molecular Dynamics using AMOEBA (Serial)}
\label{\detokenize{text/benchmarks:water-box-molecular-dynamics-using-amoeba-serial}}
MD run of 1000 Steps for 216 AMOEBA Waters in a 18.643 Ang Box, Neighbor Lists, PME with a 20x20x20 FFT and 7.0 Ang Real\sphinxhyphen{}Space Cutoff, 9.0 Ang vdW Cutoff with Correction, 1.0 fs Time Step with Modified Beeman Integrator, and 0.00001 RMS Induced Dipole Convergence

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU                   Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150               112.8
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462                99.7
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650                82.7
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670                46.9
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ                48.7
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H                37.0
\end{sphinxVerbatim}


\section{MD on DHFR in Water using CHARMM (OpenMP Parallel)}
\label{\detokenize{text/benchmarks:md-on-dhfr-in-water-using-charmm-openmp-parallel}}
MD run of 100 Steps for CHARMM DHFR in Water (23558 Atoms, 62.23 Ang Box), Neighbor Lists, PME with a 64x64x64 FFT and 7.0 Ang Real\sphinxhyphen{}Space Cutoff, 9.0 Ang vdW Cutoff, 1.0 fs Time Step with Modified Beeman Integrator; OpenMP timings as “wall clock” time, with parallel speedup in parentheses

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU       Core/Thread          Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/1       105.8 (1.00)
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/4        68.1 (1.55)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/1        88.3 (1.00)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/8        49.1 (1.80)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650          12/1        76.6 (1.00)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650         12/24        33.9 (2.26)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/1        44.7 (1.00)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/2        32.5 (1.38)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/4        25.0 (1.79)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/1        45.4 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/2        34.3 (1.32)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/4        26.9 (1.69)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/8        23.8 (1.91)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/1        34.5 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/2        23.6 (1.46)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/4        16.8 (2.05)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/6        14.5 (2.38)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H          6/12        14.1 (2.45)
\end{sphinxVerbatim}


\section{MD on DHFR in Water using AMOEBA (OpenMP Parallel)}
\label{\detokenize{text/benchmarks:md-on-dhfr-in-water-using-amoeba-openmp-parallel}}
MD run of 100 Steps for AMOEBA DHFR in Water (23558 Atoms, 62.23 Ang Box), Neighbor Lists, PME with a 64x64x64 FFT and 7.0 Ang Real\sphinxhyphen{}Space Cutoff, 9.0 Ang vdW Cutoff with Correction, 1.0 fs Time Step with Modified Beeman Integrator, and 0.00001 RMS Induced Dipole Convergence; OpenMP timings reported as “wall clock” time, with parallel speedup in parentheses

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU       Core/Thread          Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/1       507.5 (1.00)
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/4       246.3 (2.06)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/1       432.2 (1.00)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/8       158.0 (2.74)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650          12/1       357.6 (1.00)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650         12/24        98.3 (3.64)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/1       202.6 (1.00)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/2       143.5 (1.41)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/4        92.2 (2.20)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/1       219.1 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/2       159.8 (1.37)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/4        98.6 (2.22)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/8        85.0 (2.58)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/1       153.3 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/2       108.0 (1.42)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/4        69.7 (2.20)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/6        57.1 (2.68)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H          6/12        59.5 (2.58)
\end{sphinxVerbatim}


\section{MD on COX\sphinxhyphen{}2 in Water using OPLS\sphinxhyphen{}AA (OpenMP Parallel)}
\label{\detokenize{text/benchmarks:md-on-cox-2-in-water-using-opls-aa-openmp-parallel}}
MD run of 100 Steps for OPLS\sphinxhyphen{}AA COX\sphinxhyphen{}2 in Water (174219 Atoms, 120.0 Ang Box), Neighbor Lists, PME with a 128x128x128 FFT and 7.0 Ang Real\sphinxhyphen{}Space Cutoff, 9.0 Ang vdW Cutoff, 1.0 fs Time Step with Modified Beeman Integrator; RATTLE for all X\sphinxhyphen{}H bonds and rigid TIP3P Water; OpenMP timings reported as “wall clock” time, with parallel speedup in parentheses

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU       Core/Thread          Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/1        798.6 (1.00)
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/4        487.2 (1.65)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/1        698.5 (1.00)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/8        392.8 (1.78)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650          12/1        543.6 (1.00)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650         12/24        240.2 (2.26)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/1        344.2 (1.00)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/2        270.9 (1.27)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/4        196.8 (1.75)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/1        347.6 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/2        276.1 (1.26)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/4        193.7 (1.79)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/8        173.2 (2.01)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/1        262.3 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/2        202.4 (1.30)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/4        143.2 (1.83)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/6        127.2 (2.06)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H          6/12        120.9 (2.17)
\end{sphinxVerbatim}


\section{MD on COX\sphinxhyphen{}2 in Water using AMOEBA (OpenMP Parallel)}
\label{\detokenize{text/benchmarks:md-on-cox-2-in-water-using-amoeba-openmp-parallel}}
MD run of 100 Steps for AMOEBA COX\sphinxhyphen{}2 in Water (174219 Atoms, 120.0 Ang Box), Neighbor Lists, PME with a 128x128x128 FFT and 7.0 Ang Real\sphinxhyphen{}Space Cutoff, 9.0 Ang vdW Cutoff with Correction, 1.0 fs Time Step with Modified Beeman Integrator, and 0.00001 RMS Induced Dipole Convergence; OpenMP timings reported as “wall clock” time, with parallel speedup in parentheses

\sphinxstylestrong{Machine Type (OS/Compiler)                           CPU       Core/Thread          Seconds}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/1      5427.4 (1.00)
Mac Pro 1.1 (MacOS 10.11, GNU 7.1)             5150           4/4      2369.3 (2.29)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/1      4872.7 (1.00)
Mac Pro 3.1 (MacOS 10.13, GNU 8.1)            E5462           8/8      1727.8 (2.82)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650          12/1      3686.6 (1.00)
Mac Pro 5.1 (MacOS 10.13, GNU 8.1)            X5650         12/24       779.0 (4.73)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/1      2240.2 (1.00)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/2      1509.2 (1.00)
iMac 14.2 (MacOS 10.13, GNU 8.1)               4670           4/4       916.8 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/1      2279.8 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/2      1494.0 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/4       897.6 (1.00)
MacBook Pro 11.3 (MacOS 10.13, GNU 8.1)      4960HQ           4/8       763.5 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/1      1621.2 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/2      1114.9 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/4       701.3 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H           6/6       577.4 (1.00)
Razer Blade 15 (Ubuntu 18.04, GNU 7.5)        9750H          6/12       545.2 (1.00)
\end{sphinxVerbatim}


\chapter{Acknowledgments}
\label{\detokenize{text/acknowledgements:acknowledgments}}\label{\detokenize{text/acknowledgements::doc}}
The Tinker package has developed over a period of many years, very slowly during the late\sphinxhyphen{}1980s, and more rapidly since the mid\sphinxhyphen{}1990s in Jay Ponder’s research group at the Washington University School of Medicine in Saint Louis. Many people have played significant roles in the development of the package into its current form. The major contributors are listed below:

\sphinxstylestrong{Stew Rubenstein}

coordinate interconversions; original optimization methods and torsional angle manipulation

\sphinxstylestrong{Craig Kundrot}

molecular surface area \& volume and their derivatives

\sphinxstylestrong{Shawn Huston}

original Amber/OPLS implementation; free energy calculations; time correlation functions

\sphinxstylestrong{Mike Dudek}

initial multipole models for peptides and proteins

\sphinxstylestrong{Yong “Mike” Kong}

multipole electrostatics; dipole polarization; reaction field treatment; TINKER water model

\sphinxstylestrong{Reece Hart}

potential smoothing methodology; Scheraga’s DEM, Straub’s GDA and extensions

\sphinxstylestrong{Mike Hodsdon}

extension of the Tinker distance geometry program and its application to NMR NOE structure determination

\sphinxstylestrong{Rohit Pappu}

potential smoothing methodology and PSS algorithms; rigid body optimization; GB/SA solvation derivatives

\sphinxstylestrong{Wijnand Mooij}

MM3 directional hydrogen bonding term; crystal lattice minimization code

\sphinxstylestrong{Gerald Loeffler}

stochastic/Langevin dynamics implementation

\sphinxstylestrong{Marina Vorobieva \& Nina Sokolova}

nucleic acid building module and parameter translation

\sphinxstylestrong{Peter Bagossi}

AMOEBA force field parameters for alkanes and diatomics

\sphinxstylestrong{Pengyu Ren}

Ewald summation for polarizable atomic multipoles; AMOEBA force field for water, organics and peptides

\sphinxstylestrong{Anders Carlsson}

original ligand field potential energy term for transition metals

\sphinxstylestrong{Andrey Kutepov}

integrator for rigid\sphinxhyphen{}body dynamics trajectories

\sphinxstylestrong{Tom Darden}

Particle Mesh Ewald (PME) code, and development of PME for the AMOEBA force field

\sphinxstylestrong{Alan Grossfield}

Monte Carlo minimization; tophat potential smoothing

\sphinxstylestrong{Michael Schnieders}

Force Field Explorer GUI for Tinker; neighbor lists for nonbonded interactions

\sphinxstylestrong{Chuanjie Wu}

solvation free energy calculations; AMOEBA nucleic acid force field; parameterization tools for Tinker

\sphinxstylestrong{Justin Xiang}

angular overlap and valence bond potential models for transition metals

\sphinxstylestrong{David Gohara}

OpenMP parallelization of energy terms including PME, and parallel neighbor lists

\sphinxstylestrong{Chao Lu}

derivatives of potential energy with respect to lambda for metadynamics and similar methods

\sphinxstylestrong{Aaron Gordon}

enthalpy and entropy estimates as an adjunct to BAR free energy calculation

\sphinxstylestrong{Zhi Wang}

Bennett acceptance ratio (BAR) for free energy calculations

\sphinxstylestrong{Josh Rackers \& Rose Silva}

implementation of the HIPPO force field for water and general organic molecules

It is critically important that Tinker’s distributed force field parameter sets exactly reproduce the intent of the original force field authors. We would like to thank Julian Tirado\sphinxhyphen{}Rives (OPLS\sphinxhyphen{}AA), Alex MacKerell (CHARMM27), Wilfred van Gunsteren (GROMOS), and Adrian Roitberg and Carlos Simmerling (AMBER) for their help in testing Tinker’s results against those given by the authentic programs and parameter sets. Lou Allinger provided updated parameters for MM2 and MM3 on several occasions. His very successful methods provided the original inspiration for the development of Tinker.

Still other workers have devoted considerable time in developing code that will hopefully be incorporated into future Tinker versions; for example, Jim Kress (UFF implementation) and Michael Sheets (numerous code optimizations, thermodynamic integration). Finally, we wish to thank the many users of the Tinker package for their suggestions and comments, praise and criticism, which have resulted in a variety of improvements.


\chapter{References}
\label{\detokenize{text/references:references}}\label{\detokenize{text/references::doc}}
This section contains a list of the references to general theory, algorithms and implementation details which have been of use during the development of the Tinker package. Methods described in some of the references have been implemented in detail within the Tinker source code. Other references contain useful background information although the algorithms themselves are now obsolete. Still other papers contain ideas or extensions planned for future inclusion in Tinker. References for specific force field parameter sets are provided in an earlier section of this User’s Guide. This list is heavily skewed toward biomolecules in general and proteins in particular. This bias reflects our group’s major interests; however an attempt has been made to include methods which should be generally applicable.


\section{Molecular Mechanics \& Dynamics Software Packages}
\label{\detokenize{text/references:molecular-mechanics-dynamics-software-packages}}

\subsection{Tinker Software Tools}
\label{\detokenize{text/references:tinker-software-tools}}
\sphinxstylestrong{TINKER}

Tinker 8: Software Tools for Molecular Design, J. A. Rackers, Z. Wang, C. Lu, M. L. Laury, L. Lagardere, M. J. Schnieders, J.\sphinxhyphen{}P. Piquemal, P. Ren and J. W. Ponder, J. Chem. Theory Comput., 14, 5273\sphinxhyphen{}5289 (2018)

\sphinxstylestrong{TINKER\sphinxhyphen{}HP}

Tinker\sphinxhyphen{}HP: A Massively Parallel Molecular Dynamics Package for Multiscale Simulations of Large Complex Systems with Advanced Point Dipole Polarizable Force Fields, L. Lagardere, L.\sphinxhyphen{}H. Jolly, F. Lipparini, F. Aviat, B. Stamm, Z. F. Jing, M. Harger, H. Torabifard, G. A. Cisneros, M. J. Schnieders, N. Gresh, Y. Maday, P. Y. Ren, J. W. Ponder and J.\sphinxhyphen{}P. Piquemal, Chem. Sci., 9, 956\sphinxhyphen{}972 (2018)

\sphinxstylestrong{TINKER\sphinxhyphen{}OPENMM}

Tinker\sphinxhyphen{}OpenMM: Absolute and Relative Alchemical Free Energies Using AMOEBA on GPUs, M. Harger, D. Li, Z. Wang, K. Dalby, L. Lagardere, J.\sphinxhyphen{}P. Piquemal, J. Ponder and P. Ren, J. Comput. Chem., 38, 2047\sphinxhyphen{}2055 (2017)


\subsection{Alternative Molecular Modeling Software}
\label{\detokenize{text/references:alternative-molecular-modeling-software}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
AMBER          Peter Kollman, University of California, San Francisco
AMMP           Robert Harrison, Georgia State University, Atlanta
ARGOS          J. Andrew McCammon, University of California, San Diego
BOSS           William Jorgensen, Yale University
BRUGEL         Shoshona Wodak, Free University of Brussels
CFF            Shneior Lifson, Weizmann Institute
CHARMM         Martin Karplus, Harvard University
DELPHI         Bastian van de Graaf, Delft University of Technology
DISCOVER       Molecular Simulations Inc., San Diego
DL\PYGZus{}POLY        Ilian Todorov \PYGZam{} W. Smith, STFC Daresbury Laboratory
ECEPP          Harold Scheraga, Cornell University
ENCAD          Michael Levitt, Stanford University
FANTOM         Werner Braun, University of Texas, Galveston
FEDER/2        Nobuhiro Go, Kyoto University
GROMACS        Erik Lindahl, Stockholm University
GROMOS         Wilfred van Gunsteren, BIOMOS and ETH, Zurich
IMPACT         Ronald Levy, Temple University, Philadelphia
MACROMODEL     Schodinger, Inc., New York
MM2/MM3/MM4    N. Lou Allinger, University of Georgia
MMC            Cliff Dykstra, Indiana Univ.\PYGZhy{}Purdue Univ. at Indianapolis
MMFF           Thomas Halgren, Merck Research Laboratories, Rahway, NJ
MMTK           Konrad Hinsen, Inst. of Structural Biology, Grenoble
MOIL           Ron Elber, Cornell University
MOLARIS        Arieh Warshel, University of Southern California
MOLDY          Keith Refson, Oxford University
MOSCITO        Dietmar Paschek \PYGZam{} Alfons Geiger, Universitat Dortmund
NAMD           Klaus Schulten, University of Illinois, Urbana
OOMPAA         J. Andrew McCammon, University of California, San Diego
OPENMM         Peter Eastman \PYGZam{} Vijay Pande, Stanford University
ORAL           Karel Zimmerman, INRA, Jouy\PYGZhy{}en\PYGZhy{}Josas, France
ORIENT         Anthony Stone, Cambridge University
PCMODEL        Kevin Gilbert, Serena Software, Bloomington, Indiana
PEFF           Jan Dillen, University of Pretoria, South Africa
PHENIX         Paul Adams, Lawrence Berkeley Laboratory
Q              Johan Aqvist, Uppsala University
SIBFA          Nohad Gresh, INSERM, CNRS, Paris
SIGMA          Jan Hermans, University of North Carolina
SPASIBA        Gerard Vergoten, Universite de Lille
SPASMS         David Spellmeyer and the Kollman Group, UCSF
UTAH5          Cornelis Altona, Leiden University, Netherlands
XPLOR/CNS      Axel Brunger, Stanford University
YAMMP          Stephen Harvey, University of Alabama, Birmingham
YASP           Florian Mueller\PYGZhy{}Plathe, TU Darmstadt
YETI           Angelo Vedani, Biografik\PYGZhy{}Labor 3R, Basel
\end{sphinxVerbatim}

\sphinxstylestrong{AMBER}

An Overview of the Amber Biomolecular Simulation Package, R. Salomon\sphinxhyphen{}Ferrer, D. A. Case, R. C. Walker, WIREs Comput. Mol. Sci. 3, 198\sphinxhyphen{}210 (2013)

The Amber Biomolecular Simulation Programs. D. A. Case, T. E. Cheatham, III, T. Darden, H. Gohlke, R. Luo, K. M. Merz, Jr., A. Onufriev, C. Simmerling, B. Wang and R. Woods. J. Comput. Chem., 26, 1668\sphinxhyphen{}1688 (2005)

AMBER, a Package of Computer Programs for Applying Molecular Mechanics, Normal Mode Analysis, Molecular Dynamics and Free Energy Calculations to Simulate the Structural and Energetic Properties of Molecules, D. A Pearlman, D. A. Case, J. W. Caldwell, W. S. Ross, T. E. Cheatham III, S. DeBolt, D. Ferguson, G. Seibel and P. Kollman, Comp. Phys. Commun., 91, 1\sphinxhyphen{}41 (1995)

\sphinxstylestrong{AMMP}

Stiffness and Energy Conservation in Molecular Dynamics: An Improved Integrator, R. W. Harrison, J. Comput. Chem., 14, 1112\sphinxhyphen{}1122 (1993)

\sphinxstylestrong{ARGOS}

ARGOS, a Vectorized General Molecular Dynamics Program, T. P. Straatsma and J. A. McCammon, J. Comput. Chem., 11, 943\sphinxhyphen{}951 (1990)

\sphinxstylestrong{BOSS}

Molecular Modeling of Organic and Biomolecular Systems Using BOSS and MCPRO, W. L. Jorgensen and J. Tirado\sphinxhyphen{}Rives, J. Comput. Chem., 26, 1689\sphinxhyphen{}1700 (2005)

\sphinxstylestrong{BRUGEL}

Interactive Computer Animation of Macromolecules, P. Delhaise, M. Bardiaux and S. Wodak, J. Mol. Graphics, 2, 103\sphinxhyphen{}106 (1984)

\sphinxstylestrong{CHARMM}

CHARMM: The Biomolecular Simulation Program, B. R. Brooks, C. L. Brooks III, A. D. Mackerell, L. Nilsson, R. J. Petrella, B. Roux, Y. Won, G. Archontis, C. Bartels, S. Boresch A. Caflisch, L. Caves, Q. Cui, A. R. Dinner, M. Feig, S. Fischer, J. Gao, M. Hodoscek, W. Im, K. Kuczera, T. Lazaridis, J. Ma, V. Ovchinnikov, E. Paci, R. W. Pastor, C. B. Post, J. Z. Pu, M. Schaefer, B. Tidor, R. M. Venable, H. L. Woodcock, X. Wu, W. Yang, D. M. York, and M. Karplus, J. Comput. Chem., 30, 1545\sphinxhyphen{}1615 (2009)

CHARMM: The Energy Function and Its Parameterization with an Overview of the Program, A. D. MacKerell, Jr., B. Brooks, C. L. Brooks, III, L. Nilsson, B. Roux, Y. Won, and M. Karplus, in The Encyclopedia of Computational Chemistry, Vol. 1, pg. 271\sphinxhyphen{}277, John Wiley \& Sons, Chichester, 1998

CHARMM: A Program for Macromolecular Energy, Minimization, and Dynamics Calculations, B. R. Brooks, R. E. Bruccoleri, B. D. Olafson, D. J. States, S. Swaminathan and M. Karplus, J. Comput. Chem., 4, 187\sphinxhyphen{}217 (1983)

\sphinxstylestrong{DELPHI}

Delft Molecular Mechanics: A New Approach to Hydrocarbon Force Fields. Inclusion of a Geometry\sphinxhyphen{}Dependent Charge Calculation, A. C. T. van Duin, J. M. A. Baas  and B. van de Graaf, J. Chem. Soc. Faraday Trans., 90, 2881\sphinxhyphen{}2895 (1994)

\sphinxstylestrong{DL\_POLY}

DL\_POLY\_3: New Dimensions in Molecular Simulations via Massive Parallelism, I. T. Todorov, W. Smith, K. Trachenko and M. T. Dove, J. Mater. Chem., 16, 1911\sphinxhyphen{}1918 (2006)

\sphinxstylestrong{ENCAD}

Potential Energy Function and Parameters for Simulations for the Molecular Dynamics of Proteins and Nucleic Acids in Solution, M. Levitt, M. Hirshberg, R. Sharon and V. Daggett, Comp. Phys. Commun., 91, 215\sphinxhyphen{}231 (1995)

\sphinxstylestrong{FANTOM}

The Program FANTOM for Energy Refinement of Polypeptides and Proteins Using a Newton\sphinxhyphen{}Raphson Minimizer in Torsion Angle Space, T. Schaumann, W. Braun and K. Wurtrich, Biopolymers, 29, 679\sphinxhyphen{}694 (1990)

\sphinxstylestrong{FEDER/2}

FEDER/2: Program for Static and Dynamic Conformational Energy Analysis of Macro\sphinxhyphen{}molecules in Dihedral Angle Space, H. Wako, S. Endo, K. Nagayama and N. Go, Comp. Phys. Commun., 91, 233\sphinxhyphen{}251 (1995)

\sphinxstylestrong{GROMACS}

GROMACS: High Performance Molecular Simulations Through Multi\sphinxhyphen{}Level Parallelism from Laptops to Supercomputers, M. J. Abraham, T. Murtola, R. Schultz, S. Pall, J. C. Smith, B. Hess and E. Lindahl, SoftwareX, 1\sphinxhyphen{}2, 19\sphinxhyphen{}25 (2015)

GROMACS 4.5: A High\sphinxhyphen{}Throughput and Highly Parallel Open Source Molecular Simulation Toolkit, S. Pronk, S. Pall, R. Schulz, P. Larsson, P. Bjelkmar, R. Apostolov, M. R. Shirts, J. C. Smith, P. M. Kasson, D. van der Spoel, B. Hess and E. Lindahl, Bioinformatics, 29, 845\sphinxhyphen{}854 (2013)

GROMACS 3.0: A Package for Molecular Simulation and Trajectory Analysis, E. Lindahl, B. Hess and D. van der Spoel, J. Mol. Model., 7, 306\sphinxhyphen{}317 (2001)

\sphinxstylestrong{GROMOS}

The GROMOS Biomolecular Simulation Program Package, W. R. P. Scott, P. H. Hunenberger , I. G. Tironi, A. E. Mark, S. R. Billeter, J. Fennen, A. E. Torda, T. Huber, P. Kruger, W. F. van Gunsteren, J. Phys. Chem. A, 103, 3596\sphinxhyphen{}3607 (1999)

\sphinxstylestrong{IMPACT}

Integrated Modeling Program, Applide Chemical Theory (IMPACT), J. L. Banks, H. S. Beard, Y. Cao, A. E. Cho, W. Damm, R. Farid, A. K. Felts, T. A. Halgren, D. T. Mainz, J. R. Maple, R. Murphy, D. M. Philipp, M. P. Repasky, L. Y. Zhang, B. J. Berne, R. A. Friesner, E. Gallicchio and R. M. Levy, J. Comput. Chem., 26, 1752\sphinxhyphen{}1780 (2005)

\sphinxstylestrong{MACROMODEL}

MacroModel: An Integrated Software System for Modeling Organic and Bioorganic Molecules Using Molecular Mechanics, F. Mahamadi, N. G. J. Richards, W. C. Guida, R. Liskamp, M. Lipton, C. Caufield, G. Chang, T. Hendrickson and W. C. Still, J. Comput. Chem., 11, 440\sphinxhyphen{}467 (1990)

\sphinxstylestrong{MM2}

Conformational Analysis. 130. MM2. A Hydrocarbon Force Field Utilizing V1 and V2 Torsional Terms, N. L. Allinger, J. Am. Chem. Soc., 99, 8127\sphinxhyphen{}8134 (1977)

\sphinxstylestrong{MM3}

Molecular Mechanics. The MM3 Force Field for Hydrocarbons, N. L. Allinger, Y. H. Yuh and J.\sphinxhyphen{}H. Lii, J. Am. Chem. Soc., 111, 8551\sphinxhyphen{}8566 (1989)

\sphinxstylestrong{MM4}

An Improved Force Field (MM4) for Saturated Hydrocarbons, N. L. Allinger, K. Chen and J.\sphinxhyphen{}H. Lii, J. Comput. Chem., 17, 642\sphinxhyphen{}668 (1996)

\sphinxstylestrong{MMC}

Molecular Mechanics for Weakly Interacting Assemblies of Rare Gas Atoms and Small Molecules, C. E. Dykstra, J. Am. Chem. Soc., 111, 6168\sphinxhyphen{}6174 (1989)

\sphinxstylestrong{MMFF}

Merck Molecular Force Field. I. Basis, Form, Scope, Parameterization, and Performance of MMFF94, T. A. Halgren, J. Comput. Chem., 17, 490\sphinxhyphen{}516 (1996)

\sphinxstylestrong{MOIL}

MOIL: A Program for Simulations of Macromolecules, R. Elber, A. Roitberg, C. Simmerling, R. Goldstein, H. Li, G. Verkhiver, C. Keasar, J. Zhang and A. Ulitsky, Comp. Phys. Commun., 91, 159\sphinxhyphen{}189 (1995)

\sphinxstylestrong{MOSCITO}

Information available at the site \sphinxurl{http://139.30.122.11/MOSCITO/}

\sphinxstylestrong{NAMD}

Scalable Molecular Dynamics with NAMD, J. C. Phillips, R. Braun, W. Wang, J. Gumbart, E. Tajkhorshid, E. Villa, C. Chipot, R. D. Skeel, L. Kale and K. Schulten, J. Comput. Chem., 26, 1781\sphinxhyphen{}1802 (2005)

\sphinxstylestrong{OOMPAA}

OOMPAA: Object\sphinxhyphen{}oriented Model for Probing Assemblages of Atoms, G. A. Huber and J. A. McCammon, J. Comput. Phys., 151, 264\sphinxhyphen{}282 (1999)

\sphinxstylestrong{ORAL}

ORAL: All Purpose Molecular Mechanics Simulator and Energy Minimizer, K. Zimmermann, J. Comput. Chem., 12, 310\sphinxhyphen{}319 (1991)

\sphinxstylestrong{ORIENT}

Orient: A Program for Studying Interactions Between Molecules, Version 5.0, A. J. Stone, A. Dullweber, O. Engkvist, E. Fraschini, M. P. Hodges, A. W. Meredith, D. R. Nutt, P. L. A. Popelier and D. J. Wales, University of Cambridge, 2018

Information available at the site \sphinxurl{http://www-stone.ch.cam.ac.uk/programs.html\#Orient/}

\sphinxstylestrong{PCMODEL}

PCMODEL V9.0: Molecular Modeling Software, User’s Manual, Serena Software, Bloomington, IN, 2004

\sphinxstylestrong{PEFF}

PEFF: A Program for the Development of Empirical Force Fields, J. L. M. Dillen, J. Comput. Chem., 13, 257\sphinxhyphen{}267 (1992)

\sphinxstylestrong{PHENIX}

Macromolecular Structure Determination Using X\sphinxhyphen{}rays, Neutrons and Electrons: Recent Developments in Phenix, D. Liebschner, P. V. Afonine, M. L. Baker, G. Bunkóczi, V. B. Chen, T. I. Croll, B. Hintze, L.\sphinxhyphen{}W. Hung, S. Jain, A. J. McCoy, N. W. Moriarty, R. D. Oeffner, B. K. Poon, M. G. Prisant, R. J. Read, J. S. Richardson, D. C. Richardson, M. D. Sammito, O. V. Sobolev, D. H. Stockwell, T. C. Terwilliger, A. G. Urzhumtsev, L. L. Videau, C. J. Williams and P. D. Adams, Acta Cryst., D75, 861\sphinxhyphen{}877 (2019)

\sphinxstylestrong{Q}

Q: A Molecular Dynamics Program for Free Energy Calculations and Empirical Valene Bond Simulations in Biomolecular Systems, J. Marelius, K. Kolmodin, I. Feierberg and J. Aqvist, J. Mol. Graphics Modell., 16, 213\sphinxhyphen{}225 (1998)

\sphinxstylestrong{SIBFA}

Inter\sphinxhyphen{} and Intramolecular Interactions. Inception and Refinements of the SIBFA, Molecular Mechanics (SMM) Procedure, a Separable, Polarizable Methodology Grounded on ab Initio SCF/MP2 Computations. Examples of Applications to Molecular Recognition Problems, N. Gresh, J. Chim. Phys. PCB, 94, 1365\sphinxhyphen{}1416 (1997)

\sphinxstylestrong{SIGMA}

The Sigma MD Program and a Generic Interface Applicable to Multi\sphinxhyphen{}Functional Programs with Complex, Hierarchical Command Structure, G. Mann, R. Yun, L. Nyland, J. Prins, J. Board and J. Hermans, in Computational Methods for Macromolecules: Challenges and Applications, T. Schlick and H.\sphinxhyphen{}H. Gan, Eds., Springer, 2002

\sphinxstylestrong{UTAH5}

UTAH5: A Versatile Programme Package for the Calculation of Molecular Properties by Force Field Methods, D. H. Faber and C. Altona, Computers \& Chemistry, 1, 203\sphinxhyphen{}213 (1977)

\sphinxstylestrong{YAMMP}

Yammp: Development of a Molecular Mechanics Program Using the Modular Programming Method, R. K.\sphinxhyphen{}Z. Tan and S. C. Harvey, J. Comput. Chem., 14, 455\sphinxhyphen{}470 (1993)

\sphinxstylestrong{YASP}

YASP: A Molecular Simulation Package, F. Mueller\sphinxhyphen{}Plathe, Comput. Phys. Commun., 78, 77\sphinxhyphen{}94 (1993)

\sphinxstylestrong{YETI}

YETI: An Interactive Molecular Mechanics Program for Small\sphinxhyphen{}Molecule Protein Complexes, A. Vedani, J. Comput. Chem., 9, 269\sphinxhyphen{}280 (1988)


\section{Literature References by Topic}
\label{\detokenize{text/references:literature-references-by-topic}}

\subsection{Molecular Mechanics Methodology}
\label{\detokenize{text/references:molecular-mechanics-methodology}}
Molecular Mechanics, U. Burkert and N. L. Allinger, American Chemical Society, Washington, D.C., 1982

Molecular Structure: Understanding Steric and Electronic Effects from Molecular Mechanics, N. L. Allinger and D. W. Rogers, John Wiley \& Sons, Hoboken, New Jersey, 2010

Molecular Modeling of Inorganic Compounds, 2nd Ed., P. Comba and T. W. Hambley, Wiley\sphinxhyphen{}VCH, New York, 2001

Principles of Molecular Mechanics, K. Machida, Kodansha/John Wiley \& Sons, Tokyo/New York, 1999

Molecular Mechanics Across Chemistry, A. K. Rappe and C. J. Casewit, University Science Books, Sausalito, CA, 1997

Potential Energy Functions in Conformational Analysis (Lecture Notes in Chemistry, Vol. 27), K. Rasmussen, Springer\sphinxhyphen{}Verlag, Berlin, 1985


\subsection{Intermolecular Interactions}
\label{\detokenize{text/references:intermolecular-interactions}}
The Theory of Intermolecular Forces, 2nd Ed., A. J. Stone, Oxford University Press, 2013

Intermolecular and Surface Forces, 3rd Ed., J. N. Israelachvili, Academic Press, Amsterdam, 2013

Intermolecular Forces: Their Origin and Determination, G. C. Maitland, M. Rigby, E. B. Smith and W. A. Wakeham, Oxford University Press, 1981


\subsection{Computer Simulation Methodology}
\label{\detokenize{text/references:computer-simulation-methodology}}
Computer Simulation of Liquids, M. P. Allen and D. J. Tildesley, Oxford University Press, Oxford, 1987

Essentials of Computational Chemistry: Theories and Models, C. J. Cramer, John Wiley and Sons, New York, 2002

A Practical Introduction to the Simulation of Molecular Systems, M. J. Field, Cambridge Univ. Press, Cambridge, 1999

Understanding Molecular Simulation: From Algorithms to Applications, 2nd Ed., D. Frankel and B. Smit, Academic Press, San Diego, CA, 2001

Molecular Dynamics Simulation: Elementary Methods, J. M. Haile, John Wiley and Sons, New York, 1992

Introduction to Computational Chemistry, F. Jensen, John Wiley and Sons, New York, 1998

Molecular Modelling: Principles and Applications, 2nd Ed., A. R. Leach, Addison Wesley Longman, Essex, England, 2001

The Art of Molecular Dynamics Simulation, 2nd Ed., D. C. Rapaport, Cambridge University Press, Cambridge, 2004

Molecular Modeling and Simulation: An Interdisciplinary Guide, 2nd Ed., T. Schlick, Springer\sphinxhyphen{}Verlag, New York, 2010


\subsection{Modeling of Biological Macromolecules}
\label{\detokenize{text/references:modeling-of-biological-macromolecules}}
Computational Biochemistry and Biophysics, O. M. Becker, A. D. MacKerell, Jr., B. Roux and M. Watanabe, Eds., Marcel Dekker, New York, 2001

Proteins: A Theoretical Perspective of Dynamics, Structure, and Thermodynamics, C. L. Brooks III, M. Karplus and B. M. Pettitt, John Wiley and Sons, New York, 1988

Protein Simulations (Advances in Protein Chemistry, Vol. 66), V. Daggett, Ed., Academic Press/Elsevier, New York, 2003

Dynamics of Proteins and Nucleic Acids, J. A. McCammon and S. Harvey, Cambridge University Press, Cambridge, 1987

Computer Simulation of Biomolecular Systems, Vol. 1\sphinxhyphen{}3, W. F. van Gunsteren, P. K. Weiner and A. J. Wilkinson, Kluwer Academic Publishers, Dordrecht, 1989\sphinxhyphen{}1997


\subsection{Nonlinear Optimization Algorithms}
\label{\detokenize{text/references:nonlinear-optimization-algorithms}}
Numerical Optimization, 2nd Ed., J. Nocedal and S. J. Wright, Springer\sphinxhyphen{}Verlag, New York, 2006

Linear and Nonlinear Programming, 2nd Ed., I. Griva, S. G. Nash and A. Sofer, SIAM, Philadelphia, 2009

Practical Methods of Optimization, R. Fletcher, John Wiley \& Sons Ltd., Chichester, 1987

Linear and Nonlinear Programming, 4th Ed., D. G. Luenberger and Y. Ye, Springer, New York, 2016

Practical Optimization, P. E. Gill, W. Murray and M. H. Wright, Academic Press, New York, 1981

Updating Quasi\sphinxhyphen{}Newton Matrices with Limited Storage, J. Nocedal, Math. Comp., 773\sphinxhyphen{}782 (1980)

A Stable, Rapidly Converging Conjugate Gradient Method for Energy Minimization, S. J. Watowich, E. S. Meyer, R. Hagstrom and R. Josephs, J. Comput. Chem., 9, 650\sphinxhyphen{}661 (1988)

Optimally Conditioned Optimization Algorithms without Line Searches, W. C. Davidon, Math. Prog., 9, 1\sphinxhyphen{}30 (1975)


\subsection{Truncated Newton Optimization}
\label{\detokenize{text/references:truncated-newton-optimization}}
An Efficient Newton\sphinxhyphen{}like Method for Molecular Mechanics Energy Minimization of Large Molecules, J. W. Ponder and F. M. Richards, J. Comput. Chem., 8, 1016\sphinxhyphen{}1024 (1987)

Truncated\sphinxhyphen{}Newton Algorithms for Large\sphinxhyphen{}Scale Unconstrained Optimization, R. S. Dembo and T. Steihaug, Math. Prog., 26, 190\sphinxhyphen{}212 (1983)

Choosing the Forcing Terms in an Inexact Newton Method, S. C. Eisenstat and H. F. Walker, SIAM J. Sci. Comput., 17, 16\sphinxhyphen{}32 (1996)

A Powerful Truncated Newton Method for Potential Energy Minimization, T. Schlick and M. Overton, J. Comput. Chem., 8, 1025\sphinxhyphen{}1039 (1987)

The Incomplete Cholesky\sphinxhyphen{}Conjugate Gradient Method for the Iterative Solution of Systems of Linear Equations, D. S. Kershaw, J. Comput. Phys., 26, 43\sphinxhyphen{}65 (1978)

An Incomplete Factorization Technique for Positive Definite Linear Systems, T. A. Manteuffel, Math. Comp., 34, 473\sphinxhyphen{}497 (1980)

A Truncated Newton Minimizer Adapted for CHARMM and Biomolecular Applications, P. Derreumaux, G. Zhang and T. Schlick and B. R. Brooks, J. Comput. Chem., 15, 532\sphinxhyphen{}552 (1994)

Direct Methods for Sparse Matrices, I. S. Duff, A. M. Erisman and J. K. Reid, Oxford University Press, Oxford, 1986


\subsection{Potential Energy Smoothing}
\label{\detokenize{text/references:potential-energy-smoothing}}
Analysis and Application of Potential Energy Smoothing Methods for Global Optimization, R. V. Pappu, R. K. Hart and J. W. Ponder, J. Phys. Chem. B, 102, 9725\sphinxhyphen{}9742 (1998)

The Multiple\sphinxhyphen{}Minima Problem in the Conformational Analysis of Molecules. Deformation of the Potential Energy Hypersurface by the Diffusion Equation Method, L. Piela, J. Kostrowicki and H. A. Scheraga, J. Phys. Chem., 93, 3339\sphinxhyphen{}3346 (1989)

Simulated Annealing Using the Classical Density Distribution, J. Ma and J. E. Straub, J. Chem. Phys., 101, 533\sphinxhyphen{}541 (1994)

Cluster Structure Determination Using Gaussian Density Distribution Global Minimization Methods, C. Tsoo and C. L. Brooks, J. Chem. Phys., 101, 6405\sphinxhyphen{}6411 (1994)

Conformational Energy Minimization Using a Two\sphinxhyphen{}Stage Method, S. Nakamura, H. Hirose, M. Ikeguchi and J. Doi, J. Phys. Chem., 99, 8374\sphinxhyphen{}8378 (1995)

Structure Optimization Combining Soft\sphinxhyphen{}Core Interaction Functions, the Diffusion Equation Method, and Molecular Dynamics, T. Huber, A. E. Torda and W. F. van Gunsteren, J. Phys. Chem. A, 101, 5926\sphinxhyphen{}5930 (1997)

Finding Minimum\sphinxhyphen{}Energy Configurations of Lennard\sphinxhyphen{}Jones Clusters Using an Effective Potential, S. Schelstraete and H. Verschelde, J. Phys. Chem. A, 101, 310\sphinxhyphen{}315 (1998)

Global Optimization Using Bad Derivatives: Derivative\sphinxhyphen{}Free Method for Molecular Energy Minimization, I. Andricioaei and J. E. Straub, J. Comput. Chem., 19, 1445\sphinxhyphen{}1455 (1998)

Search for the Most Stable Structures on Potential Energy Surfaces, L. Piela, Coll. Czech. Chem. Commun., 63, 1368\sphinxhyphen{}1380 (1998)


\subsection{“Sniffer” Global Optimization}
\label{\detokenize{text/references:sniffer-global-optimization}}
Generalized Descent for Global Optimization, A. O. Griewank, J. Opt. Theor. Appl., 34, 11\sphinxhyphen{}39 (1981)

An Evaluation of the Sniffer Global Optimization Algorithm Using Standard Test Functions, R. A. R. Butler and E. E. Slaminka, J. Comput. Phys., 99, 28\sphinxhyphen{}32 (1993)

Potential Transformation Methods for Large\sphinxhyphen{}Scale Global Optimization, J. W. Rogers and R. A. Donnelly, SIAM J. Optim., 5, 871\sphinxhyphen{}891 (1995)


\subsection{Integration Methods for Molecular Dynamics}
\label{\detokenize{text/references:integration-methods-for-molecular-dynamics}}
Molecular Dynamics With Deterministic and Stochastic Numerical Methods, B. Leimkuhler and C. Matthews, Springer, New York, 2015

Pushing the Limits of Multiple\sphinxhyphen{}Time\sphinxhyphen{}Step Strategies for Polarizable Point Dipole Molecular Dynamics, L. Lagardere, F. Aviat and J.\sphinxhyphen{}P. Piquemal, J. Phys. Chem. Lett., 10, 2593\sphinxhyphen{}2599 (2019)

Some Multistep Methods for Use in Molecular Dynamics Calculations, D. Beeman, J. Comput. Phys., 20, 130\sphinxhyphen{}139 (1976)

Integrating the Equations of Motion, M. Levitt and H. Meirovitch, J. Mol. Biol., 168, 617\sphinxhyphen{}620 (1983)

A Molecular Dynamics Study of the C\sphinxhyphen{}Terminal Fragment of the L7/L12 Ribosomal Protein, J. Aqvist, W. F. van Gunsteren, M. Leijonmarck and O. Tapia, J. Mol. Biol., 183, 461\sphinxhyphen{}477 (1985)

A Computer Simulation Method for the Calculation of Equilibrium Constants for the Formation of Physical Clusters of Molecules: Application to Small Water Clusters, W. C. Swope, H. C. Andersen, P. H. Berens and K. R. Wilson, J. Chem. Phys., 76, 637\sphinxhyphen{}649 (1982)

A Multiple\sphinxhyphen{}Time\sphinxhyphen{}Step Molecular Dynamics Algorithm for Macromolecules, D. D. Humphreys, R. A. Friesner and B. J. Berne, J. Phys. Chem., 98, 6885\sphinxhyphen{}6892 (1994)

Efficient Multiple\sphinxhyphen{}Time\sphinxhyphen{}Step Integrators with Distance\sphinxhyphen{}Based Force Splitting for Particle\sphinxhyphen{}Mesh\sphinxhyphen{}Ewald Molecular Dynamics Simulations, X. Qian and T. Schlick, J. Chem. Phys., 115, 4019\sphinxhyphen{}4029 (2001)


\subsection{Constraint Dynamics}
\label{\detokenize{text/references:constraint-dynamics}}
Algorithms for Macromolecular Dynamics and Constraint Dynamics, W. F. van Gunsteren and H. J. C. Berendsen, Mol. Phys., 34, 1311\sphinxhyphen{}1327 (1977)

Molecular Dynamics of Rigid Systems in Cartesian Coordinates: A General Formulation, G. Ciccotti, M. Ferrario and J.\sphinxhyphen{}P. Ryckaert, Mol. Phys., 47, 1253\sphinxhyphen{}1264 (1982)

Rattle: A “Velocity” Version of the Shake Algorithm for Molecular Dynamics Calculations, H. C. Andersen, J. Comput. Phys., 52, 24\sphinxhyphen{}34 (1983)

RATTLE Recipe for General Holonomic Constraints: Angle and Torsion Constraints, R. Kutteh, CCP5 Newsletter, 46, 9\sphinxhyphen{}17 (1998), available from the site \sphinxurl{https://www.ccp5.ac.uk/infoweb/newsletters/}

Direct Application of SHAKE to the Velocity Verlet Algorithm, B. J. Palmer, J. Comput. Phys., 104, 470\sphinxhyphen{}472 (1993)

SETTLE: An Analytical Version of the SHAKE and RATTLE Algorithm for Rigid Water Models, S. Miyamoto and P. A. Kollman, J. Comput. Chem., 13, 952\sphinxhyphen{}962 (1992)

LINCS: A Linear Constraint Solver for Molecular Simulations, B. Hess, H. Bekker, H. J. C. Berendsen and J. G. E. M. Fraaije, J. Comput. Chem., 18, 1463\sphinxhyphen{}1472 (1997)

Non\sphinxhyphen{}Iterative Constraint Dynamics using Velocity\sphinxhyphen{}Explicit Verlet Methods, J. T. Slusher and P. T. Cummings, Mol. Simul., 18, 213\sphinxhyphen{}224 (1996)


\subsection{Langevin, Brownian and Stochastic Dynamics}
\label{\detokenize{text/references:langevin-brownian-and-stochastic-dynamics}}
Brownian Dynamics Simulation of a Chemical Reaction in Solution, M. P. Allen, Mol. Phys., 40, 1073\sphinxhyphen{}1087 (1980)

Algorithms for Brownian Dynamics, W. F. van Gunsteren and H. J. C. Berendsen, Mol. Phys., 45, 637\sphinxhyphen{}647 (1982)

A Rapidly Convergent Simulation Method: Mixed Monte Carlo/Stochastic Dynamics, F. Guarnieri and W. C. Still, J. Comput. Chem., 15, 1302\sphinxhyphen{}1310 (1994)

Constant Temperature Simulations using the Langevin Equation with Velocity Verlet Integration, M. G. Paterlini and D. M. Ferguson, Chem. Phys., 236, 243\sphinxhyphen{}252 (1998)


\subsection{Constant Temperature and Pressure Dynamics}
\label{\detokenize{text/references:constant-temperature-and-pressure-dynamics}}
Molecular Dynamics with Coupling to an External Bath, H. J. C. Berendsen, J. P. M. Postma, W. F. van Gunsteren, A. DiNola and J. R. Haak, J. Chem. Phys., 81, 3684\sphinxhyphen{}3690 (1984)

Canonical Dynamics: Equilibrium Phase\sphinxhyphen{}space Distributions, W. G. Hoover, Phys. Rev. A, 31, 1695\sphinxhyphen{}1697 (1985)

Computer Simulation of a Phase Transition at Constant Temperature and Pressure, J. J. Morales, S. Toxvaerd and L. F. Rull, Phys. Rev. A, 34, 1495\sphinxhyphen{}1498 (1986)

Algorithms for Molecular Dynamics at Constant Temperature and Pressure, B. R. Brooks, Internal Report of Division of Computer Research and Technology, National Institutes of Health, 1988.

Molecular Dynamics of Native Protein: Computer Simulation of Trajectories, M. Levitt, J. Mol. Biol., 168, 595\sphinxhyphen{}620 (1983)


\subsection{Out\sphinxhyphen{}of\sphinxhyphen{}Plane Deformation Terms}
\label{\detokenize{text/references:out-of-plane-deformation-terms}}
Derivation of Force Fields for Molecular Mechanics and Dynamics from ab initio Energy Surfaces, J. R. Maple, U. Dinar and A. T. Hagler, Proc. Natl. Acad. Sci. USA, 85, 5350\sphinxhyphen{}5354 (1988)

New Out\sphinxhyphen{}of\sphinxhyphen{}Plane Angle and Bond Angle Internal Coordinates and Related Potential Energy Functions for Molecular Mechanics and Dynamics Simulations, S.\sphinxhyphen{}H. Lee, K. Palmo and S. Krimm, J. Comput. Chem., 20, 1067\sphinxhyphen{}1084 (1999)


\subsection{Geometry\sphinxhyphen{}Dependent Charge Flux Terms}
\label{\detokenize{text/references:geometry-dependent-charge-flux-terms}}
Geometry\sphinxhyphen{}Dependent Atomic Charges: Methodology and Application to Alkanes, Aldehydes, Ketones, and Amides, U. Dinar and A. T. Hagler, J. Comput. Chem., 16, 154\sphinxhyphen{}170 (1995)

Inclusion of Charge and Polarizability Fluxes Provides Needed Physical Accuracy in Molecular Mechanics Force Fields, K. Palmo, B. Mannifors, N. G. Mirkin and S. Krimm, Chem. Phys. Lett., 429, 628\sphinxhyphen{}632 (2006)

Implementation of Geometry\sphinxhyphen{}Dependent Charge Flux into the Polarizable AMOEBA+ Potential, C. Liu, J.\sphinxhyphen{}P. Piquemal and P. Ren, J. Phys. Chem. Lett., 11, 419\sphinxhyphen{}426 (2020)


\subsection{Analytical Derivatives of Potential Functions}
\label{\detokenize{text/references:analytical-derivatives-of-potential-functions}}
First and Second Derivative Matrix Elements for the Stretching, Bending, and Torsional Energy, K. J. Miller, R. J. Hinde and J. Anderson, J. Comput. Chem., 10, 63\sphinxhyphen{}76 (1989)

Alternative Expressions for Energies and Forces Due to Angle Bending and Torsional Energy, Report G320\sphinxhyphen{}3561, W. C. Swope and D. M. Ferguson, J. Comput. Chem., 13, 585\sphinxhyphen{}594 (1992)

New Formulation for Derivatives of Torsion Angles and Improper Torsion Angles in Molecular Mechanics: Elimination of Singularities, A. Blondel and M. Karplus, J. Comput. Chem., 17, 1132\sphinxhyphen{}1141 (1996)

Efficient Treatment of Out\sphinxhyphen{}of\sphinxhyphen{}Plane Bend and Improper Torsion Interactions in MM2, MM3, and MM4 Molecular Mechanics Calculations, R. E. Tuzun, D. W. Noid and B. G. Sumpter, J. Comput. Chem., 18, 1804\sphinxhyphen{}1811 (1997)


\subsection{Torsional Space Derivatives and Normal Modes}
\label{\detokenize{text/references:torsional-space-derivatives-and-normal-modes}}
Protein Normal\sphinxhyphen{}mode Dynamics:  Trypsin Inhibitor, Crambin, Ribonuclease and Lysozyme, M. Levitt, C. Sander and P. S. Stern, J. Mol. Biol., 181, 423\sphinxhyphen{}447 (1985)

Protein Folding by Restrained Energy Minimization and Molecular Dynamics, M. Levitt, J. Mol. Biol., 170, 723\sphinxhyphen{}764 (1983)

Algorithm for Rapid Calculation of Hessian of Conformational Energy Function of Proteins by Supercomputer, H. Wako and N. Go, J. Comput. Chem., 8, 625\sphinxhyphen{}635 (1987)

Rapid Calculation of First and Second Derivatives of Conformational Energy with Respect to Dihedral Angles for Proteins: General Recurrent Equations, H. Abe, W. Braun, T. Noguti and N. Go, Computers \& Chemistry, 8, 239\sphinxhyphen{}247 (1984)

A Method of Rapid Calculation of a Second Derivative Matrix of Conformational Energy for Large Molecules, T. Noguti and N. Go, J. Phys. Soc. Japan, 52, 3685\sphinxhyphen{}3690 (1983)


\subsection{Analytical Surface Area and Volume}
\label{\detokenize{text/references:analytical-surface-area-and-volume}}
Analytical Molecular Surface Calculation, M. L. Connolly, J. Appl. Cryst., 16, 548\sphinxhyphen{}558 (1983)

Computation of Molecular Volume, M. L. Connolly, J. Am. Chem. Soc., 107, 1118\sphinxhyphen{}1124 (1985)

Molecular Surfaces: A Review, M. L. Connolly, available from the site \sphinxurl{https://web.archive.org/web/20120311082019/http://www.netsci.org/Science/Compchem/feature14.html/}

Algorithms for Calculating Excluded Volume and Its Derivatives as a Function of Molecular Conformation and Their Use in Energy Minimization, C. E. Kundrot, J. W. Ponder and F. M. Richards, J. Comput. Chem., 12, 402\sphinxhyphen{}409 (1991)

Solvent Accessible Surface Area and Excluded Volume in Proteins, T. J. Richmond, J. Mol. Biol., 178, 63\sphinxhyphen{}89 (1984)

Atomic Solvation Parameters Applied to Molecular Dynamics of Proteins in Solution, L. Wesson and D. Eisenberg, Protein Science, 1, 227\sphinxhyphen{}235 (1992)

Implementation of Solvent Effect in Molecular Mechanics, Part 3. The First\sphinxhyphen{} and Second\sphinxhyphen{}order Analytical Derivatives of Excluded Volume, V. Gononea and E. Osawa, J. Mol. Struct. (Theochem), 311 305\sphinxhyphen{}324 (1994)

Exact Calculation of the Volume and Surface Area of Fused Hard\sphinxhyphen{}sphere Molecules with Unequal Atomic Radii, K. D. Gibson and H. A. Scheraga, Mol. Phys., 62, 1247\sphinxhyphen{}1265 (1987)

Surface Area of the Intersection of Three Spheres with Unequal Radii: A Simplified Analytical Formula, K. D. Gibson and H. A. Scheraga, Mol. Phys., 64, 641\sphinxhyphen{}644 (1988)

A Rapid Method for Calculating Derivatives of Solvent Accessible Surface Areas of Molecules, S. Sridharan, A. Nichols and K. A. Sharp, J. Comput, Chem., 16, 1038\sphinxhyphen{}1044 (1995)


\subsection{Approximate Surface Area and Volume}
\label{\detokenize{text/references:approximate-surface-area-and-volume}}
Analytical Approximation to the Accessible Surface Area of Proteins, S. J. Wodak and J. Janin, Proc. Natl. Acad. Sci. USA, 77, 1736\sphinxhyphen{}1740 (1980)

A Rapid Approximation to the Solvent Accessible Surface Areas of Atoms, W. Hasel, T. F. Hendrickson and W. C. Still, Tetrahedron Comput. Method., 1, 103\sphinxhyphen{}116 (1988)

Approximate Solvent\sphinxhyphen{}Accessible Surface Areas from Tetrahedrally Directed Neighber Densities, J. Weiser, P. S. Shenkin and W. C. Still, Biopolymers, 50, 373\sphinxhyphen{}380 (1999)


\subsection{Boundary Conditions and Neighbor Methods}
\label{\detokenize{text/references:boundary-conditions-and-neighbor-methods}}
On Searching Neighbors in Computer Simulations of Macromolecular Systems, W. F. van Gunsteren, H. J. C. Berendsen, F. Colonna, D. Perahia, J. P. Hollenberg and D. Lellouch, J. Comput. Chem., 5, 272\sphinxhyphen{}279  (1984)

Molecular Dynamics on Vector Computers, F. Sullivan, R. D. Mountain and J. O’Connell, J. Comput. Phys., 61, 138\sphinxhyphen{}153 (1985)

A Vectorized “Near Neighbors” Algorithm of Order N Using a Monotonic Logical Grid, J. Boris, J. Comput. Phys., 66, 1\sphinxhyphen{}20 (1986)

Geometric Properties of the Monotonic Lagrangian Grid Algorithm for Near Neighbors Calculations, S. G. Lambrakos and J. P. Boris, J. Comput. Phys., 73, 183\sphinxhyphen{}202 (1987)

The Role of Long Ranged Forces in Determining the Structure and Properties of Liquid Water, T. A. Andrea, W. C. Swope and H. C. Andersen, J. Chem. Phys., 79, 4576\sphinxhyphen{}4584 (1983)

Geometrical Considerations in Model Systems with Periodic Boundary Conditions, D. N. Theodorou and U. W. Suter, J. Chem. Phys., 82, 955\sphinxhyphen{}966 (1985)

A Hierarchical O(NlogN) Force\sphinxhyphen{}calculation Algorithm, J. Barnes and P. Hut, Nature, 234, 446\sphinxhyphen{}449 (1986)


\subsection{Cutoff and Truncation Methods}
\label{\detokenize{text/references:cutoff-and-truncation-methods}}
New Spherical\sphinxhyphen{}Cutoff Methods for Long\sphinxhyphen{}Range Forces in Macromolecular Simulation, P. J. Steinbach and B. R. Brooks, J. Comput. Chem., 15, 667\sphinxhyphen{}683 (1993)

The Effects of Truncating Long\sphinxhyphen{}Range Forces on Protein Dynamics, R. J. Loncharich and B. R. Brooks, Proteins, 6, 32\sphinxhyphen{}45 (1989)

Structural and Energetic Effects of Truncating Long Ranged Interactions in Ionic and Polar Fluids, C. L. Brooks III, B. M. Pettitt and M. Karplus, J. Chem. Phys., 83, 5897\sphinxhyphen{}5908 (1985)


\subsection{Ewald Summation Techniques}
\label{\detokenize{text/references:ewald-summation-techniques}}
Ewald Summation Techniques in Perspective: A Survey, A. Y. Toukmaji and J. A. Board, Jr., Comp. Phys. Commun., 95, 73\sphinxhyphen{}92 (1996)

New Tricks for Modelers from the Crystallography Toolkit: The Particle Mesh Ewald Algorithm and its Use in Nucleic Acid Simulations, T. Darden, L. Perera, L. Li and L. Pedersen, Structure, 7, R550\sphinxhyphen{}R60 (1999)

Particle Mesh Ewald: An Nlog(N) Method for Ewald Sums in Large Systems, T. Darden, D. York and L. G. Pedersen, J. Chem. Phys., 98, 10089\sphinxhyphen{}10092 (1993)

A Smooth Particle Mesh Ewald Method, U. Essmann, L. Perera, M. L. Berkowitz, T. Darden, H. Lee and L. G. Pedersen, J. Chem. Phys., 103, 8577\sphinxhyphen{}8593 (1995)

Point Multipoles in the Ewald Summation (Revisited), W. Smith, CCP5 Newsletter, 46, 18\sphinxhyphen{}30 (1998), available at the site \sphinxurl{https://www.ccp5.ac.uk/infoweb/newsletters/}

Effect of Electrostatic Force Truncation on Interfacial and Transport Properties of Water, S. E. Feller, R. W. Pastor, A. Rojnuckarin, S. Bogusz and B. R. Brooks, J. Phys. Chem., 100, 17011\sphinxhyphen{}17020 (1996)

Molecular Dynamics Simulations of a Polyalanine Octapeptide under Ewald Boundary Conditions: Influence of Artificial Periodicity on Peptide Conformation, W. Weber, P. H. Hunenberger and J. A. McCammon, J. Phys. Chem. B, 104, 3668\sphinxhyphen{}3675 (2000)


\subsection{Conjugated and Aromatic Systems}
\label{\detokenize{text/references:conjugated-and-aromatic-systems}}
Molecular Mechanics (MM3) Calculations on Conjugated Hydrocarbons, N. L. Allinger, F. Li, L. Yan and J. C. Tai, J. Comput. Chem., 11, 868\sphinxhyphen{}895 (1990)

The MMP2 Calculational Method, J. T. Sprague, J. C. Tai, Y. Yuh and N. L. Allinger, J. Comput. Chem., 8, 581\sphinxhyphen{}603 (1987)

A Molecular Orbital Based Molecular Mechanics Approach to Study Conjugated Hydrocarbons, J. Kao, J. Am. Chem. Soc., 109, 3818\sphinxhyphen{}3829 (1987)

Conformational Analysis: Heats of Formation of Conjugated Hydrocarbons by the Force Field Method, J. Kao and N. L. Allinger, J. Am. Chem. Soc., 99, 975\sphinxhyphen{}986 (1977)

Accurate Heats of Atomization and Accurate Bond Lengths: Benzenoid Hydrocarbons, D. H. Lo and M. A. Whitehead, Can. J. Chem., 46, 2027\sphinxhyphen{}2040 (1968)

Hetero\sphinxhyphen{}atomic Molecules: Semi\sphinxhyphen{}empirical Molecular Orbital Calculations and Prediction of Physical Properties, G. D. Zeiss and M. A. Whitehead, J. Chem. Soc. A, 1727\sphinxhyphen{}1738 (1971)


\subsection{Free Energy Simulation Methods}
\label{\detokenize{text/references:free-energy-simulation-methods}}
Free Energy Calculations: Applications to Chemical and Biochemical Phenomena, P. Kollman, Chem. Rev., 93, 2395\sphinxhyphen{}2417 (1993)

Ligand\sphinxhyphen{}Receptor Interactions, B. L. Tembe and J. A. McCammon, Computers \& Chemistry, 8, 281\sphinxhyphen{}283 (1984)

Monte Carlo Simulation of Differences in Free Energy of Hydration, W. L. Jorgensen and C. Ravimohan, J. Chem. Phys., 83, 3050\sphinxhyphen{}3054 (1985)

Efficient Computation of Absolute Free Energies of Binding by Computer Simulations:  Application to the Methane Dimer in Water, W. L. Jorgensen, J. K. Buckner, S. Boudon and J. Tirado\sphinxhyphen{}Rives, J. Chem. Phys., 89, 3742\sphinxhyphen{}3746 (1988)

Thermodynamics of Aqueous Solvation:  Solution Properties of Alcohols and Alkanes, S. H. Fleischman and C. L. Brooks III, J. Chem. Phys., 87, 3029\sphinxhyphen{}3037 (1987)

An Approach to the Application of Free Energy Perturbation Methods Using Molecular Dynamics, U. C. Singh, F. K. Brown, P. A. Bash and P. A. Kollman, J. Am. Chem. Soc., 109, 1607\sphinxhyphen{}1614 (1987)

A New Method for Carrying out Free Energy Perturbation Calculations: Dynamically Modified Windows, D. A. Pearlman and P. A. Kollman, J. Chem. Phys., 90, 2460\sphinxhyphen{}2470 (1989)

Free Energy of Hydrophobic Hydration:  A Molecular Dynamics Study of Noble Gases in Water, T. P. Straatsma, H. J. C. Berendsen and J. P. M. Postma, J. Chem. Phys., 85, 6720\sphinxhyphen{}6727 (1986)

Free Energy of Ionic Hydration:  Analysis of a Thermodynamic Integration Technique to Evaluate Free Energy Differences by Molecular Dynamics Simulations, T. P. Straatsma and H. J. C. Berendsen, J. Chem. Phys., 89, 5876\sphinxhyphen{}5886 (1988)

The Finite Difference Thermodynamic Integration, Tested on Calculating the Hydration Free Energy Difference between Acetone and Dimethylamine in Water, M. Mezei, J. Chem. Phys., 86, 7084\sphinxhyphen{}7088 (1987)

Decomposition of the Free Energy of a System in Terms of Specific Interactions, A. E. Mark and W. F. van Gunsteren, J. Mol. Biol., 240, 167\sphinxhyphen{}176 (1994)

The Meaning of Copmponent Analysis: Decomposition of the Free Energy in Terms of Specific Interactions, S. Boresch and M. Karplus, J. Mol. Biol., 254, 801\sphinxhyphen{}807 (1995)


\subsection{Methods for Parameter Determination}
\label{\detokenize{text/references:methods-for-parameter-determination}}
Molecular Mechanics Parameters, N. L. Allinger, X. Zhou and J. Bergsma, J. Mol. Struct. (THEOCHEM), 312, 69\sphinxhyphen{}83 (1994)

The Atom\sphinxhyphen{}Atom Potential Method: Application to Organic Molecular Solids, A. J. Pertsin and A. I. Kitaigorodsky, Springer\sphinxhyphen{}Verlag, Berlin, 1987

Transferable Empirical Nonbonded Potential Functions, D. E. Williams, in Crystal Cohesion and Conformational Energies, Ed. by R. M. Metzger, Springer\sphinxhyphen{}Verlag, Berlin, 1981

A Procedure for Obtaining Energy Parameters from Crystal Packing, A. T. Hagler and S. Lifson, Acta Cryst., B30, 1336\sphinxhyphen{}1341 (1974)

Consistent Force Field Studies of Intermolecular Forces in Hydrogen\sphinxhyphen{}Bonded Crystals:  A Benchmark for the Objective Comparison of Alternative Force Fields, A. T. Hagler, S. Lifson and P. Dauber, J. Am. Chem. Soc., 101, 5122\sphinxhyphen{}5130 (1979)

Optimized Intermolecular Potential Functions for Liquid Hydrocarbons, W. L. Jorgensen, J. D. Madura and C. J. Swenson, J. Am. Chem. Soc., 106, 6638\sphinxhyphen{}6646 (1984)

Optimized Intermolecular Potential Functions for Amides and Peptides: Structure and Properties of Liquid Amides, W. L. Jorgensen and C. J. Swenson, J. Am. Chem. Soc., 107, 569\sphinxhyphen{}578 (1985)

Derivation of Force Fields for Molecular Mechanics and Dynamics from ab Initio Surfaces, J. R. Maple, U. Dinur and A. T. Hagler, Proc. Nat. Acad. Sci. USA, 85, 5350\sphinxhyphen{}5354 (1988)

Direct Evaluation of Nonbonding Interactions from ab Initio Calculations, U. Dinur and A. T. Hagler, J. Am. Chem. Soc., 111, 5149\sphinxhyphen{}5151 (1989)


\subsection{Electrostatic Interactions}
\label{\detokenize{text/references:electrostatic-interactions}}
Towards More Accurate Model Intermolecular Potentials for Organic Molecules, S. L. Price, Rev. Comput. Chem., 14, 225\sphinxhyphen{}289 (2000)

A Transferable Distributed Multipole Model for the Electrostatic Interactions of Peptides and Amides, C. H. Faerman and S. L. Price, J. Am. Chem. Soc., 112, 4915\sphinxhyphen{}4926 (1990)

Electrostatic Interaction Potentials in Molecular Force Fields, C. E. Dykstra, Chem. Rev., 93, 2339\sphinxhyphen{}2353 (1993)

Accurate Modeling of the Intramolecular Electrostatic Energy of Proteins, M. J. Dudek and J. W. Ponder, J. Comput. Chem., 16, 791\sphinxhyphen{}816 (1995)

An Improved Description of the Molecular Charge Density in Force Fields with Atomic Multipole Moments, U. Koch and E. Egert, J. Comput. Chem., 16, 937\sphinxhyphen{}944 (1995)

Representation of the Molecular Electrostatic Potential by Atomic Multipole and Bond Dipole Models, D. E. Williams, J. Comput. Chem., 9, 745\sphinxhyphen{}763 (1988)

Critical Analysis of Electric Field Modeling: Formamide, F. Colonna, E. Evleth and J. G. Angyan, J. Comput. Chem., 13, 1234\sphinxhyphen{}1245 (1992)


\subsection{Polarization Effects}
\label{\detokenize{text/references:polarization-effects}}
Incorporating Electric Polarizabilities in Water\sphinxhyphen{}Water Interaction Potentials, S. Kuwajima and A. Warshel, J. Phys. Chem., 94, 460\sphinxhyphen{}466 (1990)

Structure and Properties of Neat Liquids Using Nonadditive Molecular Dynamics: Water, Methanol, and N\sphinxhyphen{}Methylacetamide, J. W. Caldwell and P. A. Kollman, J. Phys. Chem., 99, 6208\sphinxhyphen{}6219 (1995)

An Anisotropic Polarizable Water Model: Incorporation of All\sphinxhyphen{}Atom Polarizabilities into Molecular Mechanics Force Fields, D. N. Bernardo, Y. Ding, K. Kroegh\sphinxhyphen{}Jespersen and R. M. Levy, J. Phys. Chem., 98, 4180\sphinxhyphen{}4187 (1994)

Molecular and Atomic Polarizabilities: Thole’s Model Revisited, P. T. van Duijnen and M. Swart, J. Phys. Chem. A, 102, 2399\sphinxhyphen{}2407 (1998)

Calculation of the Molecular Polarizability Tensor, K. J. Miller, J. Am. Chem. Soc., 112, 8543\sphinxhyphen{}8551 (1990)

An Atom Dipole Interaction Model for Molecular Polarizability. Application to Polyatomic Molecules and Determination of Atom Polarizabilities, J. Applequist, J. R. Carl and K.\sphinxhyphen{}K. Fung, J. Am. Chem. Soc., 94, 2952\sphinxhyphen{}2960 (1972)

Atom Charge Transfer in Molecular Polarizabilities. Application of the Olson\sphinxhyphen{}Sundberg Model to Aliphatic and Aromatic Hydrocarbons, J. Applequist, J. Phys. Chem., 97, 6016\sphinxhyphen{}6023 (1993)

Distributed Polarizabilities, A. J. Stone, Mol. Phys., 56, 1065\sphinxhyphen{}1082 (1985)

A Distributed Model of the Electrical Response of Organic Molecules, J. M. Stout and C. E. Dykstra, J. Phys. Chem. A, 102, 1576\sphinxhyphen{}1582 (1998)


\subsection{Macroscopic Treatment of Solvent}
\label{\detokenize{text/references:macroscopic-treatment-of-solvent}}
Continuum Solvation Models: Classical and Quantum Mechanical Implementations, C. J. Cramer and D. G. Truhlar, Rev. Comput. Chem., 6, 1\sphinxhyphen{}72 (1995)

Implicit Solvation Models, B. Roux and T. Simonson, Biophys. Chem., 78, 1\sphinxhyphen{}20 (1999)

Introduction to Continuum Electrostatics with Molecular Applications, M. K. Gilson, available at the site \sphinxurl{http://gilsonlab.umbi.umd.edu/}


\subsection{Surface Area\sphinxhyphen{}Based Solvation Models}
\label{\detokenize{text/references:surface-area-based-solvation-models}}
Solvation Energy in Protein Folding and Binding, D. Eisenberg and A. D. McLachlan, Nature, 319, 199\sphinxhyphen{}203 (1986)

Atomic Solvation Parameters Applied to Molecular Dynamics of Proteins in Solution, L. Wesson and D. Eisenberg, Prot. Sci., 1, 227\sphinxhyphen{}235 (1992)

Accessible Surface Areas as a Measure of the Thermodynamic Parameters of Hydration of Peptides, T. Ooi, M. Oobatake, G. Nemethy and H. A. Scheraga, Proc. Natl. Acad. Sci. USA, 84, 3086\sphinxhyphen{}3090 (1987)

An Efficient, Differentiable Hydration Potential for Peptides and Proteins, J. D. Augspurger and H. A. Scheraga, J. Comput. Chem., 17, 1549\sphinxhyphen{}1558 (1996)


\subsection{Generalized Born Solvation Models}
\label{\detokenize{text/references:generalized-born-solvation-models}}
A Semiempirical Treatment of Solvation for Molecular Mechanics and Dynamics, W. C. Still, A. Tempczyk, R. C. Hawley and T. Hendrickson, J. Am. Chem. Soc., 112, 6127\sphinxhyphen{}6129 (1990)

The GB/SA Continuum Model for Solvation. A Fast Analytical Method for the Calculation of Approximate Born Radii, D. Qiu, P. S. Shenkin, F. P. Hollinger and W. C. Still, J. Phys. Chem. A, 101, 3005\sphinxhyphen{}3014 (1997)

Pairwise Solute Descreening of Solute Charges from a Dielectric Medium, G. D. Hawkins, C. J. Cramer and D. G. Truhlar, Chem. Phys. Lett., 246, 122\sphinxhyphen{}129 (1995)

Parametrized Models of Aqueous Free Energies of Solvation Based on Pairwise Descreening of Solute Atomic Charges from a Dielectric Medium, G. D. Hawkins, C. J. Cramer and D. G. Truhlar, J. Phys. Chem., 100, 19824\sphinxhyphen{}19839 (1996)

Modification of the Generalized Born Model Suitable for Macromolecules, A. Onufriev, D. Bashford and D. A. Case, J. Phys. Chem. B, 104, 3712\sphinxhyphen{}3720 (2000)

A Comprehensive Analytical Treatment of Continuum Electrostatics, M. Schaefer and M. Karplus, J. Phys. Chem., 100, 1578\sphinxhyphen{}1599 (1996)

Solution Conformations and Thermodynamics of Structured Peptides: Molecular Dynamics Simulation with an Implicit Solvation Model, M. Schaefer, C. Bartels and M. Karplus, J. Mol. Biol., 284, 835\sphinxhyphen{}848 (1998)


\subsection{Superposition of Coordinate Sets}
\label{\detokenize{text/references:superposition-of-coordinate-sets}}
An Algorithm for the Simultaneous Superposition of a Structural Series, S. J. Kearsley, J. Comput. Chem., 11, 1187\sphinxhyphen{}1192 (1990)

A Note on the Rotational Superposition Problem, R. Diamond, Acta Cryst., A44, 211\sphinxhyphen{}216 (1988)

Rapid Comparison of Protein Structures, A. D. McLachlan, Acta Cryst., A38, 871\sphinxhyphen{}873 (1982)

Some Uses of a Best Molecular Fit Routine, S. C. Nyburg, Acta Cryst., B30, 251\sphinxhyphen{}253 (1974)


\subsection{Location of Transition States}
\label{\detokenize{text/references:location-of-transition-states}}
Reaction Path Study of Conformational Transitions and Helix Formation in a Tetrapeptide, R. Czerminski and R. Elber, Proc. Nat. Acad. Sci. USA, 86, 6963 (1989)

Finding Saddles on Multidimensional Potential Surfaces, R. S. Berry, H. L. Davis and T. L. Beck, Chem. Phys. Lett., 147, 13 (1988)

Reaction Paths on Multidimensional Energy Hypersurfaces, K. Muller, Ang. Chem. Int. Ed. Engl., 19, 1\sphinxhyphen{}13 (1980)

Locating Transition States, S. Bell and J. S. Crighton, J. Chem. Phys., 80, 2464\sphinxhyphen{}2475 (1984)

Conjugate Peak Refinement: An Algorithm for Finding Reaction Paths and Accurate Transition States in Systems with Many Degrees of Freedom, S. Fischer and M. Karplus, Chem. Phys. Lett., 194, 252\sphinxhyphen{}261 (1992)

A New Method of Saddle\sphinxhyphen{}Point Location for the Calculation of Defect Migration Energies, J. E. Sinclair and R. Fletcher, J. Phys. C, 7, 864\sphinxhyphen{}870 (1974)

A Method for Determining Reaction Paths in Large Molecules:  Application to Myoglobin, R. Elber and M. Karplus, Chem. Phys. Lett., 139, 375\sphinxhyphen{}380 (1987)

On Finding Stationary States on Large\sphinxhyphen{}Molecule Potential Energy Surfaces, D. T. Nguyen and D. A. Case, J. Phys. Chem., 89, 4020\sphinxhyphen{}4026 (1985)

The Synchronous\sphinxhyphen{}Transit Method for Determining Reaction Pathways and Locating Molecular Transition States, T. A. Halgren and W. N. Lipscomb, Chem. Phys. Lett., 49, 225\sphinxhyphen{}232 (1977)

Event\sphinxhyphen{}Based Relaxation of Continuous Disordered Systems, G. T. Barkema and N. Mousseau, Phys. Rev. Lett., 77, 4358\sphinxhyphen{}4361 (1996)



\renewcommand{\indexname}{Index}
\printindex
\end{document}